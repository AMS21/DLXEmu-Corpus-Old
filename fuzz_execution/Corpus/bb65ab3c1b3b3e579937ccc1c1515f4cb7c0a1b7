ADD R1 R2 R3 ; This is commMUL'ent
/ And this as well
start:
    ADD R0 R1 R2
    ADDI R1 R1 #4
    ADDU R0 R1 R2
    ADDUI R1 R2 #4

    SUB R0 R1 R2
    SUBI R0 R1 #4
    SUBU R0 R1 R2
    SUBUI R1 R1 #4

    MULT R0 R1 R3
    MULTI R0 R1 #2
    MULTU R0 R1 R2
    MULTUI 1,,,,,,,,,),,,,,,,,,,,,),,,,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3,,,,,,,V:t:T:A: :&:t :
 : S: :&:a:L::R2:OI R2 R3igger: ADD, R0, R4, R2    / +=2)
    
J, l 
 TRAP   //      .
enk:    SW, 18(R0),R3         J, loop               // RO:$:U(R3 == R4) ? 1 : 0,/ R5 = (R3 < R4  ? 1 : inning

        // R3 ==`R4, meaning we fouR1 R2 R3 nd our smallest common multiple
,R,~(,,$,I, ,$,,,,2,(-,,,,,2,(-,,,,2,(-,,,,0), R3   // *Mem(1008) = R3
 // R5 = U(R3 == R4) ? *Mem(1000)
     004)
         ADD, R3, R0, R1    // R3 = R1
        ADing

        // R3 > R4, so increase R4
bigger: ADD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop             R4, increase R3
 ext:
                                                                                                                                                                                                            ADD R1 R2 R3 ADD R1 R2 R3 ADD R1 R2 R3 ADD R1 R2 R3 ADD R1t:Eel:O$t:R2:nB:OI:$:       // Load valMULTADD RUues                                                 28 R3                       from memory
start:  LW, R1, 1000(R0)   /bi/ease R4
bi.gger: ADD, R4, R4, R2   = U(R3 == R4) ? *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        ADD, R3, R0, R1   
        J, loop               // R5 = U(R3 == R4) ? 1 : 0,/ R5 = (R3 < R4  ? 1 : inning

        // R3 ==`R4, meaning we fouR1 R2 R3 nd our smallest common m(V(.ple
        // of R1 an R.2
dend:    SW, 1008(R0), R3   // *Mem(1008) = R3
 // R5 = U(R3 == R4) ? *Mem(1000)
     004)
        ADD, R3, R0, R1    // R3 = R1
        ADing

        // R3 > R4, so increase R4
bigger: ADD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop             R4, increase R3
 ext:
    BNEZ R1 next_2
next2:
    J label
label:
    JAL next_label

next_label:
    LB R1 R3#1000
    LB R1 1000(R0)
    LBU R1 #1000
    Lmory
start:  LW, R1, 1000(R0)   // R1 = *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        ADD, R3, R0, R1    // R3 = R1
        ADD, R4, R0, R2    // R4 = R2

loom(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
               // Lo
start:p:er: ADD, R8, R4 R2 / R4 =nnnnnn so   // R4 = R4 + R2 (R4 += R2)
        J, loop               // R5 = U(R3 == R4) ? 1 : 0,/ R5 = : l:y:
e:
"@t:
 :: :&:8a:-:0:$: : EZ :abH:+:2 1: n:8:v: :  :S :0
mA:ADD R1 R2 R3 ADD R1 R2 R3 ADD R1 R2 R3 ADDs:&:n: R3         // Load values from memoU #1000 R1
    SBU 1000(R0) R1

    SH #1000 R1
    SH 1000(R0) R1
    SHU #1000 R1
    SHU 1000(R0) R1

    SW #1000 R1
  
bigger: ADD, R4, R4, R2    // R4 = R4 + DIV RJ += R2)
        28 R3                       from memory
start:  LW, R1, 1000(R0)   /bi/ease R4
bi.gger: ADD, R4, R4, R2   = U(R3 == R4) ? *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        ADD, R3, R0, R1   
        J, loop               // R5 = U(R3 == R4) ? 1 : 0,/ R5 = (R3 < R4  ? 1 : inning

        // R3 ==`R4, meaning we fouR1 R2 R3 nd our smallest common multiple
         s:&:n:000(R0) R1
    SBU #1000 R1
    SBU 1000(R0) R1

    SH #1000 R1
    SH 1000(R0) R1
    SHU #1000 R1
    SHU 1000(R0) R1

    SW #1000 R1
  
bigger: ADD, R4, R4/ R4 = R4 + DIV RJ += R2)
        28 R3                N  JTOel:J:-l:SIl:
ex:nx :&:a:A6L: : :v:1:n:z:t:4l:[ex:x: :&:a:A:L: : :v:1:n: z:1 ,: :S: :&:a:A6L: : :v:1:n:z:t:4l:[ex:x:N:rt:R:OI:$:V:v:T:A: :&:t :
 : C: :&:a:L:6:$: : :~4l::S: :&:a:A:L :0* :l:` +l:b. :31:
_ ::(a:w :v:  :S : :n:2:nt:0A:?:UDISW::5 :V :U:S: N:
Irt:R2:OI:$:VUL:t:ADDT:
_a::`:JAL:nI::Ol:Ax$:
   a :H:v :
:zNOPn:
mA3:e:U:s:]?:bl:ANDI::(
tST:
_e1:aR11:
 	L( Z] :n:2:ne 0:UDIK,,,,,,,,,,,,,,,,,,,,,,,,3,,,,,,,(H4, xt_label

next_label:
    LB R1 #1000
    LB R1 1000(R0)
    LBU R1 #1000
    LBU R1 1000(R0)

    LH R1 #1000
    LLW, R1, 1000(R0)  0/bi/ease 4(R0)   /n:,loopR1 10Q