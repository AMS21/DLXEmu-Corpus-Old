/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/IntRegister.cpp:
    1|       |#include "DLX/IntRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    IntRegister::IntRegister()
    6|       |        : m_ValueSigned{0}
    7|       |        , m_IsReadOnly{false}
    8|  15.3k|    {}
    9|       |
   10|       |    void IntRegister::SetSignedValue(phi::i32 val)
   11|  30.3k|    {
   12|  30.3k|        m_ValueSigned = val;
   13|  30.3k|    }
   14|       |
   15|       |    void IntRegister::SetUnsignedValue(phi::u32 val)
   16|  10.0k|    {
   17|  10.0k|        m_ValueUnsigned = val;
   18|  10.0k|    }
   19|       |
   20|       |    phi::i32 IntRegister::GetSignedValue() const
   21|  32.7k|    {
   22|  32.7k|        return m_ValueSigned;
   23|  32.7k|    }
   24|       |
   25|       |    phi::u32 IntRegister::GetUnsignedValue() const
   26|  20.1k|    {
   27|  20.1k|        return m_ValueUnsigned;
   28|  20.1k|    }
   29|       |
   30|       |    phi::Boolean IntRegister::IsReadOnly() const
   31|  27.7k|    {
   32|  27.7k|        return m_IsReadOnly;
   33|  27.7k|    }
   34|       |
   35|       |    void IntRegister::SetReadOnly(phi::Boolean read_only)
   36|    479|    {
   37|    479|        m_IsReadOnly = read_only;
   38|    479|    }
   39|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Instruction.cpp:
    1|       |#include "DLX/Instruction.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include <Phi/Core/Assert.hpp>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    Instruction::Instruction(const InstructionInfo& info)
    9|       |        : m_Info(info)
   10|  3.25k|    {}
   11|       |
   12|       |    void Instruction::SetArgument(phi::u8 argument_number, InstructionArg argument)
   13|  7.03k|    {
   14|  7.03k|        PHI_ASSERT(argument_number < 3u);
   15|  7.03k|
   16|  7.03k|        switch (argument_number.get())
   17|  7.03k|        {
   18|  2.60k|            case 0u:
   19|  2.60k|                m_Arg1 = argument;
   20|  2.60k|                break;
   21|  2.46k|            case 1u:
   22|  2.46k|                m_Arg2 = argument;
   23|  2.46k|                break;
   24|  1.96k|            case 2u:
   25|  1.96k|                m_Arg3 = argument;
   26|  1.96k|                break;
   27|      0|            default:
   28|      0|                PHI_ASSERT_NOT_REACHED();
   29|  7.03k|        }
   30|  7.03k|    }
   31|       |
   32|       |    std::string Instruction::DebugInfo() const noexcept
   33|  1.22k|    {
   34|  1.22k|        return std::string("Instruction");
   35|  1.22k|    }
   36|       |
   37|       |    void Instruction::Execute(Processor& processor) const noexcept
   38|  50.2k|    {
   39|  50.2k|        m_Info.Execute(processor, m_Arg1, m_Arg2, m_Arg3);
   40|  50.2k|    }
   41|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionLibrary.cpp:
    1|       |#include "DLX/InstructionLibrary.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionImplementation.hpp"
    5|       |#include <magic_enum.hpp>
    6|       |
    7|       |namespace dlx
    8|       |{
    9|       |    InstructionLibrary::InstructionLibrary()
   10|       |        : m_Instructions()
   11|    479|    {
   12|    479|        PHI_ASSERT(Initialize());
   13|    479|    }
   14|       |
   15|       |    phi::Boolean InstructionLibrary::Initialize()
   16|    479|    {
   17|    479|        /* Arithmetic */
   18|    479|
   19|    479|        // Addition
   20|    479|        InitInstruction(OpCode::ADD, ArgumentType::IntRegister, ArgumentType::IntRegister,
   21|    479|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::ADD);
   22|    479|        InitInstruction(OpCode::ADDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   23|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::ADDI);
   24|    479|        InitInstruction(OpCode::ADDU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   25|    479|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::ADDU);
   26|    479|        InitInstruction(OpCode::ADDUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   27|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::ADDUI);
   28|    479|
   29|    479|        // Subtraction
   30|    479|        InitInstruction(OpCode::SUB, ArgumentType::IntRegister, ArgumentType::IntRegister,
   31|    479|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SUB);
   32|    479|        InitInstruction(OpCode::SUBI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   33|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SUBI);
   34|    479|        InitInstruction(OpCode::SUBU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   35|    479|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SUBU);
   36|    479|        InitInstruction(OpCode::SUBUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   37|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SUBUI);
   38|    479|
   39|    479|        // Multiplikation
   40|    479|        InitInstruction(OpCode::MULT, ArgumentType::IntRegister, ArgumentType::IntRegister,
   41|    479|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::MULT);
   42|    479|        InitInstruction(OpCode::MULTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   43|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::MULTI);
   44|    479|        InitInstruction(OpCode::MULTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   45|    479|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::MULTU);
   46|    479|        InitInstruction(OpCode::MULTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   47|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::MULTUI);
   48|    479|
   49|    479|        // Division
   50|    479|        InitInstruction(OpCode::DIV, ArgumentType::IntRegister, ArgumentType::IntRegister,
   51|    479|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::DIV);
   52|    479|        InitInstruction(OpCode::DIVI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   53|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::DIVI);
   54|    479|        InitInstruction(OpCode::DIVU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   55|    479|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::DIVU);
   56|    479|        InitInstruction(OpCode::DIVUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   57|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::DIVUI);
   58|    479|
   59|    479|        // Shift left logical
   60|    479|        InitInstruction(OpCode::SLL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   61|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLL);
   62|    479|        InitInstruction(OpCode::SLLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   63|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLLI);
   64|    479|
   65|    479|        // Shift right logical
   66|    479|        InitInstruction(OpCode::SRL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   67|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRL);
   68|    479|        InitInstruction(OpCode::SRLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   69|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRLI);
   70|    479|
   71|    479|        // Shift left arithmetic
   72|    479|        InitInstruction(OpCode::SLA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   73|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLA);
   74|    479|        InitInstruction(OpCode::SLAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   75|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLAI);
   76|    479|
   77|    479|        // Shift right arithmetic
   78|    479|        InitInstruction(OpCode::SRA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   79|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRA);
   80|    479|        InitInstruction(OpCode::SRAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   81|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRAI);
   82|    479|
   83|    479|        /* Logical */
   84|    479|
   85|    479|        // And
   86|    479|        InitInstruction(OpCode::AND, ArgumentType::IntRegister, ArgumentType::IntRegister,
   87|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::AND);
   88|    479|        InitInstruction(OpCode::ANDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   89|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ANDI);
   90|    479|
   91|    479|        // Or
   92|    479|        InitInstruction(OpCode::OR, ArgumentType::IntRegister, ArgumentType::IntRegister,
   93|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::OR);
   94|    479|        InitInstruction(OpCode::ORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   95|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ORI);
   96|    479|
   97|    479|        // Xor
   98|    479|        InitInstruction(OpCode::XOR, ArgumentType::IntRegister, ArgumentType::IntRegister,
   99|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::XOR);
  100|    479|        InitInstruction(OpCode::XORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  101|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::XORI);
  102|    479|
  103|    479|        /* Conditionals */
  104|    479|
  105|    479|        // Set less than
  106|    479|        InitInstruction(OpCode::SLT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  107|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLT);
  108|    479|        InitInstruction(OpCode::SLTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  109|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLTI);
  110|    479|
  111|    479|        // Set greater than
  112|    479|        InitInstruction(OpCode::SGT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  113|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SGT);
  114|    479|        InitInstruction(OpCode::SGTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  115|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SGTI);
  116|    479|
  117|    479|        // Set less than or equal
  118|    479|        InitInstruction(OpCode::SLE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  119|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLE);
  120|    479|        InitInstruction(OpCode::SLEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  121|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLEI);
  122|    479|
  123|    479|        // Set greater than or equal
  124|    479|        InitInstruction(OpCode::SGE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  125|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SGE);
  126|    479|        InitInstruction(OpCode::SGEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  127|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SGEI);
  128|    479|
  129|    479|        // Set equal
  130|    479|        InitInstruction(OpCode::SEQ, ArgumentType::IntRegister, ArgumentType::IntRegister,
  131|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SEQ);
  132|    479|        InitInstruction(OpCode::SEQI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  133|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SEQI);
  134|    479|
  135|    479|        // Set not equal
  136|    479|        InitInstruction(OpCode::SNE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  137|    479|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SNE);
  138|    479|        InitInstruction(OpCode::SNEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  139|    479|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SNEI);
  140|    479|
  141|    479|        /* Conditional branching */
  142|    479|
  143|    479|        // Branch equal zero
  144|    479|        InitInstruction(OpCode::BEQZ, ArgumentType::IntRegister, ArgumentType::Label,
  145|    479|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BEQZ);
  146|    479|
  147|    479|        // Branch not equal zero
  148|    479|        InitInstruction(OpCode::BNEZ, ArgumentType::IntRegister, ArgumentType::Label,
  149|    479|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BNEZ);
  150|    479|
  151|    479|        /* Unconditional branching */
  152|    479|
  153|    479|        // Jump
  154|    479|        InitInstruction(OpCode::J, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  155|    479|                        RegisterAccessType::None, impl::J);
  156|    479|
  157|    479|        // Jump to register
  158|    479|        InitInstruction(OpCode::JR, ArgumentType::IntRegister, ArgumentType::None,
  159|    479|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JR);
  160|    479|
  161|    479|        // Jump and link
  162|    479|        InitInstruction(OpCode::JAL, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  163|    479|                        RegisterAccessType::Unsigned, impl::JAL);
  164|    479|
  165|    479|        // Jump and link to register
  166|    479|        InitInstruction(OpCode::JALR, ArgumentType::IntRegister, ArgumentType::None,
  167|    479|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JALR);
  168|    479|
  169|    479|        /* Loading data */
  170|    479|
  171|    479|        // Load byte
  172|    479|        InitInstruction(OpCode::LB, ArgumentType::IntRegister,
  173|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  174|    479|                        ArgumentType::None, RegisterAccessType::Signed, impl::LB);
  175|    479|
  176|    479|        // Load byte unsigned
  177|    479|        InitInstruction(OpCode::LBU, ArgumentType::IntRegister,
  178|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  179|    479|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LBU);
  180|    479|
  181|    479|        // Load half word
  182|    479|        InitInstruction(OpCode::LH, ArgumentType::IntRegister,
  183|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  184|    479|                        ArgumentType::None, RegisterAccessType::Signed, impl::LH);
  185|    479|
  186|    479|        // Load half word unsigned
  187|    479|        InitInstruction(OpCode::LHU, ArgumentType::IntRegister,
  188|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  189|    479|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LHU);
  190|    479|
  191|    479|        // Load word
  192|    479|        InitInstruction(OpCode::LW, ArgumentType::IntRegister,
  193|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  194|    479|                        ArgumentType::None, RegisterAccessType::Signed, impl::LW);
  195|    479|
  196|    479|        // Load word unsigned
  197|    479|        InitInstruction(OpCode::LWU, ArgumentType::IntRegister,
  198|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  199|    479|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LWU);
  200|    479|
  201|    479|        /* Storing data */
  202|    479|
  203|    479|        // Store byte
  204|    479|        InitInstruction(OpCode::SB,
  205|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  206|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  207|    479|                        impl::SB);
  208|    479|
  209|    479|        // Store byte unsigned
  210|    479|        InitInstruction(OpCode::SBU,
  211|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  212|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  213|    479|                        impl::SBU);
  214|    479|
  215|    479|        // Store half word
  216|    479|        InitInstruction(OpCode::SH,
  217|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  218|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  219|    479|                        impl::SH);
  220|    479|
  221|    479|        // Store half word unsigned
  222|    479|        InitInstruction(OpCode::SHU,
  223|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  224|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  225|    479|                        impl::SHU);
  226|    479|
  227|    479|        // Store word
  228|    479|        InitInstruction(OpCode::SW,
  229|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  230|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  231|    479|                        impl::SW);
  232|    479|
  233|    479|        // Store word unsigned
  234|    479|        InitInstruction(OpCode::SWU,
  235|    479|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  236|    479|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  237|    479|                        impl::SWU);
  238|    479|
  239|    479|        /* Special */
  240|    479|
  241|    479|        // Trap
  242|    479|        InitInstruction(OpCode::TRAP, ArgumentType::ImmediateInteger, ArgumentType::None,
  243|    479|                        ArgumentType::None, RegisterAccessType::None, impl::TRAP);
  244|    479|
  245|    479|        // Halt
  246|    479|        InitInstruction(OpCode::HALT, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  247|    479|                        RegisterAccessType::None, impl::HALT);
  248|    479|
  249|    479|        // No operation
  250|    479|        InitInstruction(OpCode::NOP, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  251|    479|                        RegisterAccessType::None, impl::NOP);
  252|    479|
  253|    479|        return true;
  254|    479|    }
  255|       |
  256|       |    const InstructionInfo& InstructionLibrary::LookUp(OpCode instruction) const noexcept
  257|  33.4k|    {
  258|  33.4k|        return m_Instructions.at(static_cast<std::size_t>(instruction));
  259|  33.4k|    }
  260|       |
  261|       |    void InstructionLibrary::InitInstruction(OpCode opcode, ArgumentType arg1, ArgumentType arg2,
  262|       |                                             ArgumentType        arg3,
  263|       |                                             RegisterAccessType  register_access_type,
  264|       |                                             InstructionExecutor executor)
  265|  30.1k|    {
  266|  30.1k|        PHI_ASSERT(LookUp(opcode).GetExecutor() == nullptr, "Already registered instruction {}",
  267|  30.1k|                   magic_enum::enum_name(opcode));
  268|  30.1k|
  269|  30.1k|        m_Instructions.at(static_cast<std::size_t>(opcode)) =
  270|  30.1k|                InstructionInfo(opcode, arg1, arg2, arg3, register_access_type, executor);
  271|  30.1k|    }
  272|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/MemoryBlock.cpp:
    1|       |#include "DLX/MemoryBlock.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    MemoryBlock::MemoryBlock(phi::usize start_address, phi::usize starting_size)
    6|       |        : m_StartingAddress(start_address)
    7|    479|    {
    8|    479|        m_Values.resize(starting_size.get());
    9|    479|    }
   10|       |
   11|       |    std::optional<phi::i8> MemoryBlock::LoadByte(phi::usize address) const
   12|      1|    {
   13|      1|        if (!IsAddressValid(address, 1u))
   14|      0|        {
   15|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   16|      0|            return {};
   17|      0|        }
   18|      1|
   19|      1|        return m_Values.at((address - m_StartingAddress).get()).signed_value;
   20|      1|    }
   21|       |
   22|       |    std::optional<phi::u8> MemoryBlock::LoadUnsignedByte(phi::usize address) const
   23|      2|    {
   24|      2|        if (!IsAddressValid(address, 1u))
   25|      0|        {
   26|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   27|      0|            return {};
   28|      0|        }
   29|      2|
   30|      2|        return m_Values.at((address - m_StartingAddress).get()).unsigned_value;
   31|      2|    }
   32|       |
   33|       |    std::optional<phi::i16> MemoryBlock::LoadHalfWord(phi::usize address) const
   34|      2|    {
   35|      2|        if (!IsAddressValid(address, 2u))
   36|      0|        {
   37|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   38|      0|            return {};
   39|      0|        }
   40|      2|
   41|      2|        phi::usize   start_address = address - m_StartingAddress;
   42|      2|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   43|      2|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   44|      2|        std::int16_t result        = first_byte << 8 | second_byte;
   45|      2|
   46|      2|        return result;
   47|      2|    }
   48|       |
   49|       |    std::optional<phi::u16> MemoryBlock::LoadUnsignedHalfWord(phi::usize address) const
   50|      2|    {
   51|      2|        if (!IsAddressValid(address, 2u))
   52|      0|        {
   53|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   54|      0|            return {};
   55|      0|        }
   56|      2|
   57|      2|        phi::usize    start_address = address - m_StartingAddress;
   58|      2|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   59|      2|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   60|      2|        std::uint16_t result        = first_byte << 8 | second_byte;
   61|      2|
   62|      2|        return result;
   63|      2|    }
   64|       |
   65|       |    std::optional<phi::i32> MemoryBlock::LoadWord(phi::usize address) const
   66|  2.50k|    {
   67|  2.50k|        if (!IsAddressValid(address, 4u))
   68|      1|        {
   69|      1|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   70|      1|            return {};
   71|      1|        }
   72|  2.50k|
   73|  2.50k|        phi::usize   start_address = address - m_StartingAddress;
   74|  2.50k|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   75|  2.50k|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   76|  2.50k|        std::int8_t  third_byte    = m_Values.at((start_address + 2u).get()).signed_value;
   77|  2.50k|        std::int8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).signed_value;
   78|  2.50k|        std::int32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
   79|  2.50k|
   80|  2.50k|        return result;
   81|  2.50k|    }
   82|       |
   83|       |    std::optional<phi::u32> MemoryBlock::LoadUnsignedWord(phi::usize address) const
   84|      2|    {
   85|      2|        if (!IsAddressValid(address, 4u))
   86|      0|        {
   87|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   88|      0|            return {};
   89|      0|        }
   90|      2|
   91|      2|        phi::usize    start_address = address - m_StartingAddress;
   92|      2|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   93|      2|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   94|      2|        std::uint8_t  third_byte    = m_Values.at((start_address + 2u).get()).unsigned_value;
   95|      2|        std::uint8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).unsigned_value;
   96|      2|        std::uint32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
   97|      2|
   98|      2|        return result;
   99|      2|    }
  100|       |
  101|       |    phi::Boolean MemoryBlock::StoreByte(phi::usize address, phi::i8 value)
  102|      4|    {
  103|      4|        if (!IsAddressValid(address, 1u))
  104|      2|        {
  105|      2|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  106|      2|            return false;
  107|      2|        }
  108|      2|
  109|      2|        m_Values.at((address - m_StartingAddress).get()).signed_value = value.get();
  110|      2|        return true;
  111|      2|    }
  112|       |
  113|       |    phi::Boolean MemoryBlock::StoreUnsignedByte(phi::usize address, phi::u8 value)
  114|      2|    {
  115|      2|        if (!IsAddressValid(address, 1u))
  116|      0|        {
  117|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  118|      0|            return false;
  119|      0|        }
  120|      2|
  121|      2|        m_Values.at((address - m_StartingAddress).get()).unsigned_value = value.get();
  122|      2|        return true;
  123|      2|    }
  124|       |
  125|       |    phi::Boolean MemoryBlock::StoreHalfWord(phi::usize address, phi::i16 value)
  126|      2|    {
  127|      2|        if (!IsAddressValid(address, 2u))
  128|      0|        {
  129|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  130|      0|            return false;
  131|      0|        }
  132|      2|
  133|      2|        phi::usize  start_address = address - m_StartingAddress;
  134|      2|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  135|      2|        std::int8_t second_byte   = value.get() & 0b00000000'11111111;
  136|      2|
  137|      2|        m_Values.at(start_address.get()).signed_value        = first_byte;
  138|      2|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  139|      2|
  140|      2|        return true;
  141|      2|    }
  142|       |
  143|       |    phi::Boolean MemoryBlock::StoreUnsignedHalfWord(phi::usize address, phi::u16 value)
  144|      2|    {
  145|      2|        if (!IsAddressValid(address, 2u))
  146|      0|        {
  147|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  148|      0|            return false;
  149|      0|        }
  150|      2|
  151|      2|        phi::usize   start_address = address - m_StartingAddress;
  152|      2|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  153|      2|        std::uint8_t second_byte   = value.get() & 0b00000000'11111111;
  154|      2|
  155|      2|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  156|      2|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  157|      2|
  158|      2|        return true;
  159|      2|    }
  160|       |
  161|       |    phi::Boolean MemoryBlock::StoreWord(phi::usize address, phi::i32 value)
  162|      4|    {
  163|      4|        if (!IsAddressValid(address, 4u))
  164|      1|        {
  165|      1|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  166|      1|            return false;
  167|      1|        }
  168|      3|
  169|      3|        phi::usize  start_address = address - m_StartingAddress;
  170|      3|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  171|      3|        std::int8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  172|      3|        std::int8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  173|      3|        std::int8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  174|      3|
  175|      3|        m_Values.at(start_address.get()).signed_value        = first_byte;
  176|      3|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  177|      3|        m_Values.at((start_address + 2u).get()).signed_value = third_byte;
  178|      3|        m_Values.at((start_address + 3u).get()).signed_value = fourth_byte;
  179|      3|
  180|      3|        return true;
  181|      3|    }
  182|       |
  183|       |    phi::Boolean MemoryBlock::StoreUnsignedWord(phi::usize address, phi::u32 value)
  184|      2|    {
  185|      2|        if (!IsAddressValid(address, 4u))
  186|      0|        {
  187|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  188|      0|            return false;
  189|      0|        }
  190|      2|
  191|      2|        phi::usize   start_address = address - m_StartingAddress;
  192|      2|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  193|      2|        std::uint8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  194|      2|        std::uint8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  195|      2|        std::uint8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  196|      2|
  197|      2|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  198|      2|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  199|      2|        m_Values.at((start_address + 2u).get()).unsigned_value = third_byte;
  200|      2|        m_Values.at((start_address + 3u).get()).unsigned_value = fourth_byte;
  201|      2|
  202|      2|        return true;
  203|      2|    }
  204|       |
  205|       |    phi::Boolean MemoryBlock::IsAddressValid(phi::usize address, phi::usize size) const
  206|  2.53k|    {
  207|  2.53k|        return address >= m_StartingAddress &&
  208|  2.53k|               (address + size) <= (m_StartingAddress + m_Values.size());
  209|  2.53k|    }
  210|       |
  211|       |    void MemoryBlock::Clear()
  212|    479|    {
  213|    479|        for (auto& val : m_Values)
  214|   479k|        {
  215|   479k|            val.signed_value = 0;
  216|   479k|        }
  217|    479|    }
  218|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionInfo.cpp:
    1|       |#include "DLX/InstructionInfo.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void InstructionInfo::Execute(Processor& processor, const InstructionArg& arg1,
    6|       |                                  const InstructionArg& arg2,
    7|       |                                  const InstructionArg& arg3) const noexcept
    8|  50.2k|    {
    9|  50.2k|        PHI_ASSERT(m_Executor, "No execution function defined");
   10|  50.2k|
   11|  50.2k|        m_Executor(processor, arg1, arg2, arg3);
   12|  50.2k|    }
   13|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionArg.cpp:
    1|       |#include "DLX/InstructionArg.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    InstructionArg::InstructionArg()
    6|       |        : m_Type(ArgumentType::None)
    7|       |        , address_displacement()
    8|  16.8k|    {}
    9|       |
   10|       |    ArgumentType InstructionArg::GetType() const
   11|   155k|    {
   12|   155k|        return m_Type;
   13|   155k|    }
   14|       |
   15|       |    std::string InstructionArg::DebugInfo() const
   16|      0|    {
   17|      0|        return "InstructionArgument";
   18|      0|    }
   19|       |
   20|       |    const InstructionArg::RegisterInt& InstructionArg::AsRegisterInt() const
   21|  68.0k|    {
   22|  68.0k|        PHI_ASSERT(m_Type == ArgumentType::IntRegister);
   23|  68.0k|
   24|  68.0k|        return register_int;
   25|  68.0k|    }
   26|       |
   27|       |    const InstructionArg::ImmediateValue& InstructionArg::AsImmediateValue() const
   28|    107|    {
   29|    107|        PHI_ASSERT(m_Type == ArgumentType::ImmediateInteger);
   30|    107|
   31|    107|        return immediate_value;
   32|    107|    }
   33|       |
   34|       |    const InstructionArg::AddressDisplacement& InstructionArg::AsAddressDisplacement() const
   35|  2.51k|    {
   36|  2.51k|        PHI_ASSERT(m_Type == ArgumentType::AddressDisplacement);
   37|  2.51k|
   38|  2.51k|        return address_displacement;
   39|  2.51k|    }
   40|       |
   41|       |    const InstructionArg::Label& InstructionArg::AsLabel() const
   42|  12.5k|    {
   43|  12.5k|        PHI_ASSERT(m_Type == ArgumentType::Label);
   44|  12.5k|
   45|  12.5k|        return label;
   46|  12.5k|    }
   47|       |
   48|       |    phi::Boolean operator==(const InstructionArg& lhs, const InstructionArg& rhs)
   49|      0|    {
   50|      0|        if (lhs.GetType() != rhs.GetType())
   51|      0|        {
   52|      0|            return false;
   53|      0|        }
   54|      0|
   55|      0|        switch (lhs.GetType())
   56|      0|        {
   57|      0|            case ArgumentType::AddressDisplacement:
   58|      0|                return (lhs.AsAddressDisplacement().displacement ==
   59|      0|                        rhs.AsAddressDisplacement().displacement) &&
   60|      0|                       (lhs.AsAddressDisplacement().register_id ==
   61|      0|                        rhs.AsAddressDisplacement().register_id);
   62|      0|            case ArgumentType::ImmediateInteger:
   63|      0|                return lhs.AsImmediateValue().signed_value == rhs.AsImmediateValue().signed_value;
   64|      0|            case ArgumentType::IntRegister:
   65|      0|                return lhs.AsRegisterInt().register_id == rhs.AsRegisterInt().register_id;
   66|      0|            case ArgumentType::Label:
   67|      0|                return lhs.AsLabel().label_name == rhs.AsLabel().label_name;
   68|      0|            case ArgumentType::None:
   69|      0|                return true;
   70|      0|            default:
   71|      0|                PHI_ASSERT_NOT_REACHED();
   72|      0|                break;
   73|      0|        }
   74|      0|
   75|      0|        PHI_ASSERT_NOT_REACHED();
   76|      0|        return false;
   77|      0|    }
   78|       |
   79|       |    phi::Boolean operator!=(const InstructionArg& lhs, const InstructionArg& rhs)
   80|      0|    {
   81|      0|        return !(lhs == rhs);
   82|      0|    }
   83|       |
   84|       |    InstructionArg ConstructInstructionArgRegisterInt(IntRegisterID id)
   85|  5.58k|    {
   86|  5.58k|        InstructionArg arg;
   87|  5.58k|        arg.m_Type                   = ArgumentType::IntRegister;
   88|  5.58k|        arg.register_int.register_id = id;
   89|  5.58k|        return arg;
   90|  5.58k|    }
   91|       |
   92|       |    InstructionArg ConstructInstructionArgImmediateValue(phi::i32 value)
   93|  1.11k|    {
   94|  1.11k|        InstructionArg arg;
   95|  1.11k|        arg.m_Type                       = ArgumentType::ImmediateInteger;
   96|  1.11k|        arg.immediate_value.signed_value = value;
   97|  1.11k|        return arg;
   98|  1.11k|    }
   99|       |
  100|       |    InstructionArg ConstructInstructionArgAddressDisplacement(IntRegisterID id,
  101|       |                                                              phi::i32      displacement)
  102|    193|    {
  103|    193|        InstructionArg arg;
  104|    193|        arg.m_Type                            = ArgumentType::AddressDisplacement;
  105|    193|        arg.address_displacement.register_id  = id;
  106|    193|        arg.address_displacement.displacement = displacement;
  107|    193|        return arg;
  108|    193|    }
  109|       |
  110|       |    InstructionArg ConstructInstructionArgLabel(std::string_view label_name)
  111|    146|    {
  112|    146|        InstructionArg arg;
  113|    146|        arg.m_Type           = ArgumentType::Label;
  114|    146|        arg.label.label_name = label_name;
  115|    146|        return arg;
  116|    146|    }
  117|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/RegisterNames.cpp:
    1|       |#include "DLX/RegisterNames.hpp"
    2|       |
    3|       |#include "DLX/Containers/LookUpMap.hpp"
    4|       |#include <algorithm>
    5|       |#include <cctype>
    6|       |
    7|       |namespace dlx
    8|       |{
    9|       |    static constexpr std::array<std::pair<std::string_view, IntRegisterID>, 32> RegisterValues{
   10|       |            {{"R0", IntRegisterID::R0},   {"R1", IntRegisterID::R1},   {"R2", IntRegisterID::R2},
   11|       |             {"R3", IntRegisterID::R3},   {"R4", IntRegisterID::R4},   {"R5", IntRegisterID::R5},
   12|       |             {"R6", IntRegisterID::R6},   {"R7", IntRegisterID::R7},   {"R8", IntRegisterID::R8},
   13|       |             {"R9", IntRegisterID::R9},   {"R10", IntRegisterID::R10}, {"R11", IntRegisterID::R11},
   14|       |             {"R12", IntRegisterID::R12}, {"R13", IntRegisterID::R13}, {"R14", IntRegisterID::R14},
   15|       |             {"R15", IntRegisterID::R15}, {"R16", IntRegisterID::R16}, {"R17", IntRegisterID::R17},
   16|       |             {"R18", IntRegisterID::R18}, {"R19", IntRegisterID::R19}, {"R20", IntRegisterID::R20},
   17|       |             {"R21", IntRegisterID::R21}, {"R22", IntRegisterID::R22}, {"R23", IntRegisterID::R23},
   18|       |             {"R24", IntRegisterID::R24}, {"R25", IntRegisterID::R25}, {"R26", IntRegisterID::R26},
   19|       |             {"R27", IntRegisterID::R27}, {"R28", IntRegisterID::R28}, {"R29", IntRegisterID::R29},
   20|       |             {"R30", IntRegisterID::R30}, {"R31", IntRegisterID::R31}}};
   21|       |
   22|       |    IntRegisterID StringToIntRegister(std::string token)
   23|  6.28k|    {
   24|  6.28k|        std::transform(token.begin(), token.end(), token.begin(), ::toupper);
   25|  6.28k|
   26|  6.28k|        static constexpr auto map =
   27|  6.28k|                LookUpMap<std::string_view, IntRegisterID, RegisterValues.size()>(RegisterValues, IntRegisterID::None);
   28|  6.28k|
   29|  6.28k|        return map.at(token.c_str());
   30|  6.28k|    }
   31|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/OpCode.cpp:
    1|       |#include "DLX/OpCode.hpp"
    2|       |
    3|       |#include <algorithm>
    4|       |#include <magic_enum.hpp>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    OpCode StringToOpCode(std::string token)
    9|  44.3k|    {
   10|  44.3k|        std::transform(token.begin(), token.end(), token.begin(), ::toupper);
   11|  44.3k|        std::optional<OpCode> opcode_casted = magic_enum::enum_cast<OpCode>(token);
   12|  44.3k|        if (opcode_casted.has_value())
   13|  3.40k|        {
   14|  3.40k|            // TODO: Bit of a hacky way around magic_enum begin able to cast every member...
   15|  3.40k|            if (opcode_casted.value() == OpCode::NUMBER_OF_ELEMENTS)
   16|      2|            {
   17|      2|                return OpCode::NONE;
   18|      2|            }
   19|  3.40k|            return opcode_casted.value();
   20|  3.40k|        }
   21|  40.9k|
   22|  40.9k|        // None found
   23|  40.9k|        return OpCode::NONE;
   24|  40.9k|    }
   25|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Processor.cpp:
    1|       |#include "DLX/Processor.hpp"
    2|       |
    3|       |#include "DLX/Parser.hpp"
    4|       |
    5|       |namespace dlx
    6|       |{
    7|       |    static phi::Boolean RegisterAccessTypeMatches(RegisterAccessType expected_access,
    8|       |                                                  RegisterAccessType access)
    9|  80.5k|    {
   10|  80.5k|        PHI_ASSERT(access == RegisterAccessType::Signed || access == RegisterAccessType::Unsigned);
   11|  80.5k|
   12|  80.5k|        switch (expected_access)
   13|  80.5k|        {
   14|  37.6k|            case RegisterAccessType::Ignored:
   15|  37.6k|                return true;
   16|      0|            case RegisterAccessType::None:
   17|      0|                return false;
   18|  42.9k|            default:
   19|  42.9k|                return expected_access == access;
   20|  80.5k|        }
   21|  80.5k|    }
   22|       |
   23|       |    Processor::Processor()
   24|       |        : m_MemoryBlock(1000u, 1000u)
   25|    479|    {
   26|    479|        // Mark R0 as ready only
   27|    479|        m_IntRegisters.at(0).SetReadOnly(true);
   28|    479|    }
   29|       |
   30|       |    IntRegister& Processor::GetIntRegister(IntRegisterID id)
   31|  27.7k|    {
   32|  27.7k|        PHI_ASSERT(id != IntRegisterID::None);
   33|  27.7k|        std::underlying_type_t<IntRegisterID> id_value =
   34|  27.7k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   35|  27.7k|
   36|  27.7k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   37|  27.7k|
   38|  27.7k|        return m_IntRegisters.at(id_value);
   39|  27.7k|    }
   40|       |
   41|       |    const IntRegister& Processor::GetIntRegister(IntRegisterID id) const
   42|  52.8k|    {
   43|  52.8k|        PHI_ASSERT(id != IntRegisterID::None);
   44|  52.8k|        std::underlying_type_t<IntRegisterID> id_value =
   45|  52.8k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   46|  52.8k|
   47|  52.8k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   48|  52.8k|
   49|  52.8k|        return m_IntRegisters.at(id_value);
   50|  52.8k|    }
   51|       |
   52|       |    phi::i32 Processor::IntRegisterGetSignedValue(IntRegisterID id) const
   53|  32.7k|    {
   54|  32.7k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   55|      6|        {
   56|      6|            PHI_LOG_WARN("Mismatch for instruction access type");
   57|      6|        }
   58|  32.7k|
   59|  32.7k|        return GetIntRegister(id).GetSignedValue();
   60|  32.7k|    }
   61|       |
   62|       |    phi::u32 Processor::IntRegisterGetUnsignedValue(IntRegisterID id) const
   63|  20.1k|    {
   64|  20.1k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Unsigned))
   65|      0|        {
   66|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   67|      0|        }
   68|  20.1k|
   69|  20.1k|        return GetIntRegister(id).GetUnsignedValue();
   70|  20.1k|    }
   71|       |
   72|       |    void Processor::IntRegisterSetSignedValue(IntRegisterID id, phi::i32 value)
   73|  17.6k|    {
   74|  17.6k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   75|      0|        {
   76|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   77|      0|        }
   78|  17.6k|
   79|  17.6k|        IntRegister& reg = GetIntRegister(id);
   80|  17.6k|
   81|  17.6k|        if (reg.IsReadOnly())
   82|  2.56k|        {
   83|  2.56k|            return;
   84|  2.56k|        }
   85|  15.0k|
   86|  15.0k|        reg.SetSignedValue(value);
   87|  15.0k|    }
   88|       |
   89|       |    void Processor::IntRegisterSetUnsignedValue(IntRegisterID id, phi::u32 value)
   90|  10.0k|    {
   91|  10.0k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Unsigned))
   92|      0|        {
   93|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   94|      0|        }
   95|  10.0k|
   96|  10.0k|        IntRegister& reg = GetIntRegister(id);
   97|  10.0k|
   98|  10.0k|        if (reg.IsReadOnly())
   99|     36|        {
  100|     36|            return;
  101|     36|        }
  102|  10.0k|
  103|  10.0k|        reg.SetUnsignedValue(value);
  104|  10.0k|    }
  105|       |
  106|       |    void Processor::ExecuteInstruction(const Instruction& inst)
  107|  50.2k|    {
  108|  50.2k|        m_CurrentInstructionAccessType = inst.m_Info.GetRegisterAccessType();
  109|  50.2k|
  110|  50.2k|        inst.Execute(*this);
  111|  50.2k|    }
  112|       |
  113|       |    void Processor::LoadProgram(ParsedProgram& programm)
  114|    479|    {
  115|    479|        m_CurrentProgram = &programm;
  116|    479|
  117|    479|        m_ProgramCounter = 0u;
  118|    479|        m_Halted         = false;
  119|    479|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  120|    479|    }
  121|       |
  122|       |    phi::ObserverPtr<ParsedProgram> Processor::GetCurrentProgramm() const noexcept
  123|  32.5k|    {
  124|  32.5k|        return m_CurrentProgram;
  125|  32.5k|    }
  126|       |
  127|       |    void Processor::ExecuteCurrentProgram()
  128|    479|    {
  129|    479|        PHI_ASSERT(m_CurrentProgram);
  130|    479|
  131|    479|        // Don't execute a program with parsing errors
  132|    479|        if (!m_CurrentProgram->m_ParseErrors.empty())
  133|    334|        {
  134|    334|            return;
  135|    334|        }
  136|    145|
  137|    145|        m_ProgramCounter      = 0u;
  138|    145|        m_Halted              = false;
  139|    145|        m_LastRaisedException = Exception::None;
  140|    145|
  141|    145|        phi::usize StepCount{0u};
  142|    145|
  143|  50.3k|        while (m_ProgramCounter < m_CurrentProgram->m_Instructions.size() && !m_Halted &&
  144|  50.3k|               (m_MaxNumberOfSteps != 0u && StepCount < m_MaxNumberOfSteps))
  145|  50.2k|        {
  146|  50.2k|            m_NextProgramCounter = m_ProgramCounter + 1u;
  147|  50.2k|
  148|  50.2k|            const auto& current_instruction =
  149|  50.2k|                    m_CurrentProgram->m_Instructions.at(m_ProgramCounter.get());
  150|  50.2k|            ExecuteInstruction(current_instruction);
  151|  50.2k|
  152|  50.2k|            m_ProgramCounter = m_NextProgramCounter;
  153|  50.2k|
  154|  50.2k|            ++StepCount;
  155|  50.2k|        }
  156|    145|    }
  157|       |
  158|       |    void Processor::ClearRegisters()
  159|    479|    {
  160|    479|        for (auto& reg : m_IntRegisters)
  161|  15.3k|        {
  162|  15.3k|            reg.SetSignedValue(0);
  163|  15.3k|        }
  164|    479|    }
  165|       |
  166|       |    void Processor::ClearMemory()
  167|    479|    {
  168|    479|        m_MemoryBlock.Clear();
  169|    479|    }
  170|       |
  171|       |    void Processor::Raise(Exception exception)
  172|     27|    {
  173|     27|        PHI_ASSERT(exception != Exception::None, "Cannot raise None exception");
  174|     27|
  175|     27|        m_LastRaisedException = exception;
  176|     27|
  177|     27|        switch (exception)
  178|     27|        {
  179|      0|            case Exception::None:
  180|      0|                PHI_ASSERT_NOT_REACHED();
  181|      0|                return;
  182|     14|            case Exception::DivideByZero:
  183|     14|                m_Halted = true;
  184|     14|                PHI_LOG_ERROR("Division through zero");
  185|     14|                return;
  186|      0|            case Exception::Overflow:
  187|      0|                PHI_LOG_WARN("Overflow");
  188|      0|                return;
  189|      1|            case Exception::Underflow:
  190|      1|                PHI_LOG_WARN("Underflow");
  191|      1|                return;
  192|      1|            case Exception::Trap:
  193|      1|                m_Halted = true;
  194|      1|                PHI_LOG_ERROR("Trapped");
  195|      1|                return;
  196|      1|            case Exception::Halt:
  197|      1|                m_Halted = true;
  198|      1|                return;
  199|      6|            case Exception::UnknownLabel:
  200|      6|                m_Halted = true;
  201|      6|                PHI_LOG_ERROR("Unknown label");
  202|      6|                return;
  203|      0|            case Exception::BadShift:
  204|      0|                PHI_LOG_ERROR("Bad shift");
  205|      0|                return;
  206|      4|            case Exception::AddressOutOfBounds:
  207|      4|                PHI_LOG_ERROR("Address out of bounds");
  208|      4|                m_Halted = true;
  209|      4|                return;
  210|      0|        }
  211|      0|
  212|      0|        PHI_ASSERT_NOT_REACHED();
  213|      0|    }
  214|       |
  215|       |    Exception Processor::GetLastRaisedException() const noexcept
  216|      0|    {
  217|      0|        return m_LastRaisedException;
  218|      0|    }
  219|       |
  220|       |    [[nodiscard]] phi::Boolean Processor::IsHalted() const noexcept
  221|      0|    {
  222|      0|        return m_Halted;
  223|      0|    }
  224|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Parser.cpp:
    1|       |#include "DLX/Parser.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/RegisterNames.hpp"
    5|       |#include <Phi/Config/FunctionLikeMacro.hpp>
    6|       |#include <Phi/Core/Conversion.hpp>
    7|       |#include <Phi/Core/Log.hpp>
    8|       |#include <magic_enum.hpp>
    9|       |#include <algorithm>
   10|       |#include <optional>
   11|       |
   12|       |using namespace phi::literals;
   13|       |
   14|       |namespace dlx
   15|       |{
   16|       |    phi::Boolean CharIsValidForIdentifer(const char c)
   17|    488|    {
   18|    488|        if (std::isalpha(c) || std::isdigit(c))
   19|    462|        {
   20|    462|            return true;
   21|    462|        }
   22|     26|
   23|     26|        switch (c)
   24|     26|        {
   25|     19|            case '_':
   26|     19|                return true;
   27|      0|
   28|      7|            default:
   29|      7|                return false;
   30|     26|        }
   31|     26|    }
   32|       |
   33|       |    static phi::Boolean is_integer_literal(std::string_view token)
   34|  63.6k|    {
   35|  63.6k|        if (token.length() == 0)
   36|      0|        {
   37|      0|            return false;
   38|      0|        }
   39|  63.6k|
   40|  63.6k|        // First character need to a plus sign a minus sign or a digit but only if theres a digit after that
   41|  63.6k|        if (!std::isdigit(token.at(0)) &&
   42|  63.6k|            !(token.length() > 1 && (token.at(0) == '+' || token.at(0) == '-')))
   43|  48.7k|        {
   44|  48.7k|            return false;
   45|  48.7k|        }
   46|  14.9k|
   47|  14.9k|        // Check that the rest of the token is only made up of numbers
   48|  31.0k|        for (phi::usize i{1u}; i < token.length(); ++i)
   49|  30.1k|        {
   50|  30.1k|            if (!std::isdigit(token.at(i.get())))
   51|  14.0k|            {
   52|  14.0k|                return false;
   53|  14.0k|            }
   54|  30.1k|        }
   55|  14.9k|
   56|  14.9k|        return true;
   57|  14.9k|    }
   58|       |
   59|       |    Token ParseToken(std::string_view token, phi::u64 line_number, phi::u64 column)
   60|  67.7k|    {
   61|  67.7k|        if (token.at(0) == '#' && token.size() > 1)
   62|  1.84k|        {
   63|  1.84k|            return Token(Token::Type::ImmediateInteger, token, line_number, column);
   64|  1.84k|        }
   65|  65.8k|        else if (token.at(0) == '/' || token.at(0) == ';')
   66|  2.19k|        {
   67|  2.19k|            return Token(Token::Type::Comment, token, line_number, column);
   68|  2.19k|        }
   69|  63.6k|        else if (is_integer_literal(token))
   70|    881|        {
   71|    881|            return Token(Token::Type::IntegerLiteral, token, line_number, column);
   72|    881|        }
   73|  62.7k|
   74|  62.7k|        return Token(Token::Type::Identifier, token, line_number, column);
   75|  62.7k|    }
   76|       |
   77|       |    std::vector<Token> Parser::Tokenize(std::string_view str)
   78|    479|    {
   79|    479|        std::vector<Token> tokens{};
   80|    479|        tokens.reserve(5);
   81|    479|
   82|    479|        std::string current_token;
   83|    479|        current_token.reserve(10);
   84|    479|
   85|    479|        phi::u64 current_line_number{1u};
   86|    479|        phi::u64 token_begin{0u};
   87|    479|
   88|    479|        phi::Boolean parsing_comment{false};
   89|    479|
   90|  2.10M|        for (phi::usize i{0u}; i < str.length(); ++i)
   91|  2.10M|        {
   92|  2.10M|            const char c{str.at(i.get())};
   93|  2.10M|
   94|  2.10M|            if (c == '\n')
   95|  15.6k|            {
   96|  15.6k|                if (current_token.empty())
   97|  2.51k|                {
   98|  2.51k|                    tokens.emplace_back(Token::Type::NewLine, str.substr(token_begin.get(), 1),
   99|  2.51k|                                        current_line_number, token_begin);
  100|  2.51k|                    // Skip empty lines
  101|  2.51k|                    continue;
  102|  2.51k|                }
  103|  13.0k|
  104|  13.0k|                // Otherwise a new line separates tokens
  105|  13.0k|                tokens.emplace_back(
  106|  13.0k|                        ParseToken(str.substr(token_begin.get(), current_token.length()),
  107|  13.0k|                                   current_line_number, token_begin));
  108|  13.0k|
  109|  13.0k|                token_begin = i;
  110|  13.0k|
  111|  13.0k|                tokens.emplace_back(Token::Type::NewLine, str.substr(token_begin.get(), 1),
  112|  13.0k|                                    current_line_number, token_begin);
  113|  13.0k|
  114|  13.0k|                current_token.clear();
  115|  13.0k|                parsing_comment = false;
  116|  13.0k|                current_line_number += 1u;
  117|  13.0k|            }
  118|  2.08M|            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  119|  2.08M|            else if (c == '/' || c == ';')
  120|  67.2k|            {
  121|  67.2k|                if (current_token.empty())
  122|  2.19k|                {
  123|  2.19k|                    token_begin = i;
  124|  2.19k|                }
  125|  67.2k|
  126|  67.2k|                parsing_comment = true;
  127|  67.2k|                current_token.push_back(c);
  128|  67.2k|            }
  129|  2.02M|            else if (parsing_comment)
  130|  1.47M|            {
  131|  1.47M|                // simply append the character
  132|  1.47M|                current_token.push_back(c);
  133|  1.47M|            }
  134|   547k|            else
  135|   547k|            {
  136|   547k|                // Not parsing a comment
  137|   547k|
  138|   547k|                switch (c)
  139|   547k|                {
  140|   156k|                    case ' ':
  141|   156k|                    case '\t':
  142|   156k|                    case '\v':
  143|   156k|                        if (current_token.empty())
  144|   123k|                        {
  145|   123k|                            // We haven't found any usable character for the current token so just skip the whitespace.
  146|   123k|                            continue;
  147|   123k|                        }
  148|  32.9k|
  149|  32.9k|                        // Otherwise a whitespace separates tokens
  150|  32.9k|                        tokens.push_back(
  151|  32.9k|                                ParseToken(str.substr(token_begin.get(), current_token.length()),
  152|  32.9k|                                           current_line_number, token_begin));
  153|  32.9k|                        current_token.clear();
  154|  32.9k|                        break;
  155|  32.9k|                    case ':':
  156|  15.3k|                        // Need to parse label names together with their colon
  157|  15.3k|                        if (!current_token.empty())
  158|  11.8k|                        {
  159|  11.8k|                            current_token.push_back(c);
  160|  11.8k|                            tokens.emplace_back(ParseToken(
  161|  11.8k|                                    str.substr(token_begin.get(), current_token.length()),
  162|  11.8k|                                    current_line_number, token_begin));
  163|  11.8k|
  164|  11.8k|                            current_token.clear();
  165|  11.8k|                        }
  166|  3.51k|                        else
  167|  3.51k|                        {
  168|  3.51k|                            // Orphan colon
  169|  3.51k|                            token_begin = i;
  170|  3.51k|
  171|  3.51k|                            tokens.emplace_back(Token::Type::Colon,
  172|  3.51k|                                                str.substr(token_begin.get(), 1),
  173|  3.51k|                                                current_line_number, token_begin);
  174|  3.51k|                            break;
  175|  3.51k|                        }
  176|  11.8k|                        break;
  177|  12.7k|                    case ',':
  178|  12.7k|                    case '(':
  179|  12.7k|                    case ')':
  180|  12.7k|                        if (!current_token.empty())
  181|  9.49k|                        {
  182|  9.49k|                            tokens.emplace_back(ParseToken(
  183|  9.49k|                                    str.substr(token_begin.get(), current_token.length()),
  184|  9.49k|                                    current_line_number, token_begin));
  185|  9.49k|
  186|  9.49k|                            current_token.clear();
  187|  9.49k|                        }
  188|  12.7k|
  189|  12.7k|                        Token::Type type;
  190|  12.7k|                        switch (c)
  191|  12.7k|                        {
  192|  4.28k|                            case ',':
  193|  4.28k|                                type = Token::Type::Comma;
  194|  4.28k|                                break;
  195|  4.31k|                            case '(':
  196|  4.31k|                                type = Token::Type::OpenBracket;
  197|  4.31k|                                break;
  198|  4.16k|                            case ')':
  199|  4.16k|                                type = Token::Type::ClosingBracket;
  200|  4.16k|                                break;
  201|  12.7k|                        }
  202|  12.7k|
  203|  12.7k|                        token_begin = i;
  204|  12.7k|
  205|  12.7k|                        tokens.emplace_back(type, str.substr(token_begin.get(), 1),
  206|  12.7k|                                            current_line_number, token_begin);
  207|  12.7k|                        break;
  208|  12.7k|
  209|   363k|                    default:
  210|   363k|                        if (current_token.empty())
  211|  65.5k|                        {
  212|  65.5k|                            token_begin = i;
  213|  65.5k|                        }
  214|   363k|
  215|   363k|                        // simply append the character
  216|   363k|                        current_token.push_back(c);
  217|   547k|                }
  218|   547k|            }
  219|  2.10M|        }
  220|    479|
  221|    479|        // Checked the entire string. Parse whats left if anything
  222|    479|        if (!current_token.empty())
  223|    329|        {
  224|    329|            tokens.emplace_back(ParseToken(str.substr(token_begin.get(), current_token.length()),
  225|    329|                                           current_line_number, token_begin));
  226|    329|        }
  227|    479|
  228|    479|        return tokens;
  229|    479|    }
  230|       |
  231|       |    static phi::Boolean has_x_more_tokens(const std::vector<Token>& tokens, phi::usize index,
  232|       |                                          phi::u64 x)
  233|  8.72k|    {
  234|  8.72k|        return index + x <= tokens.size();
  235|  8.72k|    }
  236|       |
  237|       |    static phi::Boolean has_one_more_token(const std::vector<Token>& tokens, phi::usize index)
  238|  8.53k|    {
  239|  8.53k|        return has_x_more_tokens(tokens, index, 1u);
  240|  8.53k|    }
  241|       |
  242|       |    static phi::Boolean next_token_is(const std::vector<Token>& tokens, phi::usize index,
  243|       |                                      Token::Type token_type)
  244|      0|    {
  245|      0|        PHI_ASSERT(has_one_more_token(tokens, index));
  246|      0|
  247|      0|        const auto& next_token = tokens.at((index + 1u).get());
  248|      0|
  249|      0|        return next_token.GetType() == token_type;
  250|      0|    }
  251|       |
  252|       |    static phi::Boolean has_one_more_token_of_type(const std::vector<Token>& tokens,
  253|       |                                                   phi::usize index, Token::Type token_type)
  254|      0|    {
  255|      0|        if (!has_one_more_token(tokens, index))
  256|      0|        {
  257|      0|            return false;
  258|      0|        }
  259|      0|
  260|      0|        return (next_token_is(tokens, index, token_type));
  261|      0|    }
  262|       |
  263|       |    static void AddParseError(ParsedProgram& program, const std::string& message)
  264|  59.2k|    {
  265|  59.2k|        ParseError err;
  266|  59.2k|        err.message = message;
  267|  59.2k|
  268|  59.2k|        PHI_LOG_ERROR("Parsing error: {}", message);
  269|  59.2k|
  270|  59.2k|        program.m_ParseErrors.emplace_back(err);
  271|  59.2k|    }
  272|       |
  273|       |    static std::optional<InstructionArg> parse_instruction_argument(
  274|       |            const Token& token, ArgumentType expected_argument_type,
  275|       |            const std::vector<Token>& tokens, phi::usize& index, ParsedProgram& program)
  276|  7.66k|    {
  277|  7.66k|        PHI_LOG_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
  278|  7.66k|                     magic_enum::enum_name(expected_argument_type));
  279|  7.66k|
  280|  7.66k|        switch (token.GetType())
  281|  7.66k|        {
  282|    208|            case Token::Type::IntegerLiteral: {
  283|    208|                if (!ArgumentTypeIncludes(expected_argument_type,
  284|    208|                                          ArgumentType::AddressDisplacement))
  285|     11|                {
  286|     11|                    AddParseError(program,
  287|     11|                                  fmt::format("Expected {} but got address displacement",
  288|     11|                                              magic_enum::enum_name(expected_argument_type)));
  289|     11|                    return {};
  290|     11|                }
  291|    197|
  292|    197|                // Parse address displacement
  293|    197|                std::int32_t displacement_value{0};
  294|    197|                try
  295|    197|                {
  296|    197|                    displacement_value = std::stoi(token.GetTextString());
  297|    197|                }
  298|    197|                catch (std::invalid_argument& /*e*/)
  299|    197|                {
  300|      0|                    AddParseError(program,
  301|      0|                                  "Failed to parse displacement value for Address displacement");
  302|      0|                    return {};
  303|      0|                }
  304|      1|                catch (std::out_of_range& /*e*/)
  305|      1|                {
  306|      1|                    AddParseError(program, "Value is out of range");
  307|      1|                    return {};
  308|      1|                }
  309|    196|
  310|    196|                if (!has_x_more_tokens(tokens, index, 3u))
  311|      2|                {
  312|      2|                    AddParseError(program,
  313|      2|                                  "Not enough arguments left to parse address displacement");
  314|      2|                    return {};
  315|      2|                }
  316|    194|
  317|    194|                const Token& first_token  = tokens.at(index.get());
  318|    194|                const Token& second_token = tokens.at((index + 1u).get());
  319|    194|                const Token& third_token  = tokens.at((index + 2u).get());
  320|    194|
  321|    194|                if (first_token.GetType() != Token::Type::OpenBracket)
  322|      0|                {
  323|      0|                    AddParseError(program, "Expected open bracket");
  324|      0|                    return {};
  325|      0|                }
  326|    194|
  327|    194|                // Second token is the address
  328|    194|                IntRegisterID reg_id = StringToIntRegister(
  329|    194|                        {second_token.GetText().data(), second_token.GetText().size()});
  330|    194|
  331|    194|                if (reg_id == IntRegisterID::None)
  332|      0|                {
  333|      0|                    AddParseError(program, "Expected IntRegister");
  334|      0|                    return {};
  335|      0|                }
  336|    194|
  337|    194|                if (third_token.GetType() != Token::Type::ClosingBracket)
  338|      1|                {
  339|      1|                    AddParseError(program, "Expected closing bracket");
  340|      1|                    return {};
  341|      1|                }
  342|    193|
  343|    193|                index += 3u;
  344|    193|
  345|    193|                PHI_LOG_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
  346|    193|                             displacement_value, magic_enum::enum_name(reg_id));
  347|    193|
  348|    193|                return ConstructInstructionArgAddressDisplacement(reg_id, displacement_value);
  349|    193|            }
  350|  6.08k|            case Token::Type::Identifier: {
  351|  6.08k|                IntRegisterID reg_id = StringToIntRegister(token.GetTextString());
  352|  6.08k|
  353|  6.08k|                if (reg_id != IntRegisterID::None)
  354|  5.59k|                {
  355|  5.59k|                    if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  356|     18|                    {
  357|     18|                        AddParseError(program,
  358|     18|                                      fmt::format("Got IntRegister but expected '{}'",
  359|     18|                                                  magic_enum::enum_name(expected_argument_type)));
  360|     18|                        return {};
  361|     18|                    }
  362|  5.58k|
  363|  5.58k|                    PHI_LOG_INFO("Parsed identifier as int register {}",
  364|  5.58k|                                 magic_enum::enum_name(reg_id));
  365|  5.58k|
  366|  5.58k|                    return ConstructInstructionArgRegisterInt(reg_id);
  367|  5.58k|                }
  368|    488|
  369|    488|                // Parse as Label
  370|    488|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  371|    335|                {
  372|    335|                    AddParseError(program,
  373|    335|                                  fmt::format("Got Label but expected '{}'",
  374|    335|                                              magic_enum::enum_name(expected_argument_type)));
  375|    335|                    return {};
  376|    335|                }
  377|    153|
  378|    153|                if (!std::all_of(token.GetText().begin(), token.GetText().end(),
  379|    153|                                 CharIsValidForIdentifer))
  380|      7|                {
  381|      7|                    AddParseError(program, fmt::format("Invalid label identifier found {}",
  382|      7|                                                       token.GetText()));
  383|      7|                    return {};
  384|      7|                }
  385|    146|
  386|    146|                PHI_LOG_INFO("Parsed Label identifier as '{}'", token.GetText());
  387|    146|
  388|    146|                return ConstructInstructionArgLabel(token.GetText());
  389|    146|            }
  390|  1.11k|            case Token::Type::ImmediateInteger: {
  391|  1.11k|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  392|      0|                {
  393|      0|                    AddParseError(program,
  394|      0|                                  fmt::format("Got ImmediateInteger but expected '{}'",
  395|      0|                                              magic_enum::enum_name(expected_argument_type)));
  396|      0|                    return {};
  397|      0|                }
  398|  1.11k|
  399|  1.11k|                std::int32_t value{0};
  400|  1.11k|                try
  401|  1.11k|                {
  402|  1.11k|                    value = std::stoi(token.GetTextString().substr(1));
  403|  1.11k|                }
  404|  1.11k|                catch (std::invalid_argument& /*e*/)
  405|  1.11k|                {
  406|      0|                    AddParseError(program, "Failed to parse immediate Integer value");
  407|      0|                    return {};
  408|      0|                }
  409|      0|                catch (std::out_of_range& /*e*/)
  410|      0|                {
  411|      0|                    AddParseError(program, "Value is out of range");
  412|      0|                    return {};
  413|      0|                }
  414|  1.11k|
  415|  1.11k|                PHI_LOG_INFO("Parsed Immediate Integer with value {}", value);
  416|  1.11k|
  417|  1.11k|                return ConstructInstructionArgImmediateValue(value);
  418|  1.11k|            }
  419|  1.11k|            default:
  420|    256|                AddParseError(program,
  421|    256|                              fmt::format("Unexpected token of type '{}'", token.GetTypeName()));
  422|    256|                return {};
  423|  7.66k|        }
  424|  7.66k|    }
  425|       |
  426|       |    static void consume_x_tokens(phi::usize& index, phi::usize x)
  427|  99.0k|    {
  428|  99.0k|        index += x;
  429|  99.0k|    }
  430|       |
  431|       |    static void consume_current_token(phi::usize& index)
  432|  99.0k|    {
  433|  99.0k|        consume_x_tokens(index, 1u);
  434|  99.0k|    }
  435|       |
  436|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::vector<Token>& tokens)
  437|    479|    {
  438|    479|        ParsedProgram program;
  439|    479|
  440|    479|        phi::Boolean line_has_instruction{false};
  441|    479|
  442|  90.9k|        for (phi::usize index{0u}; index < tokens.size();)
  443|  90.5k|        {
  444|  90.5k|            Token& current_token = tokens.at(index.get());
  445|  90.5k|
  446|  90.5k|            consume_current_token(index);
  447|  90.5k|
  448|  90.5k|            PHI_LOG_INFO("Parsing '{}'", current_token.DebugInfo());
  449|  90.5k|
  450|  90.5k|            switch (current_token.GetType())
  451|  90.5k|            {
  452|      0|                // Ignore comments
  453|  2.19k|                case Token::Type::Comment:
  454|  2.19k|                    PHI_LOG_DEBUG("Ignoring comment");
  455|  2.19k|                    break;
  456|  15.5k|                case Token::Type::NewLine:
  457|  15.5k|                    PHI_LOG_DEBUG("Ignoring newline");
  458|  15.5k|                    line_has_instruction = false;
  459|  15.5k|                    break;
  460|  56.5k|                case Token::Type::Identifier: {
  461|  56.5k|                    if (line_has_instruction)
  462|    607|                    {
  463|    607|                        AddParseError(program, "Expected new line but got identifer");
  464|    607|                        break;
  465|    607|                    }
  466|  55.9k|
  467|  55.9k|                    // Handle jump labels
  468|  55.9k|                    // Check if the last character of the identifier is a colon
  469|  55.9k|                    if (current_token.GetText().at(current_token.GetText().size() - 1) == ':')
  470|  11.5k|                    {
  471|  11.5k|                        std::string_view label_name = current_token.GetText().substr(
  472|  11.5k|                                0, current_token.GetText().size() - 1);
  473|  11.5k|
  474|  11.5k|                        program.m_JumpData[label_name] = static_cast<std::uint32_t>(program.m_Instructions.size());
  475|  11.5k|
  476|  11.5k|                        PHI_LOG_INFO("Added jump label {} -> {}", label_name,
  477|  11.5k|                                     program.m_Instructions.size());
  478|  11.5k|                        break;
  479|  11.5k|                    }
  480|  44.3k|
  481|  44.3k|                    // Handle normal instructions
  482|  44.3k|                    // First we need to parse the instruction itself so we know how many arguments it expects
  483|  44.3k|                    OpCode opcode = StringToOpCode(current_token.GetTextString());
  484|  44.3k|
  485|  44.3k|                    if (opcode == OpCode::NONE)
  486|  41.1k|                    {
  487|  41.1k|                        AddParseError(program,
  488|  41.1k|                                      fmt::format("Failed to parse instruction '{}' not found.",
  489|  41.1k|                                                  current_token.GetText()));
  490|  41.1k|                        break;
  491|  41.1k|                    }
  492|  3.25k|
  493|  3.25k|                    PHI_LOG_INFO("Instruction opcode: {}", magic_enum::enum_name(opcode));
  494|  3.25k|
  495|  3.25k|                    const InstructionInfo& info = lib.LookUp(opcode);
  496|  3.25k|
  497|  3.25k|                    // Make sure we got no problems here
  498|  3.25k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  499|  3.25k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  500|  3.25k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  501|  3.25k|                    PHI_ASSERT(info.GetExecutor());
  502|  3.25k|
  503|  3.25k|                    phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  504|  3.25k|                    PHI_LOG_INFO("Instruction requires {} arguments",
  505|  3.25k|                                 number_of_argument_required.get());
  506|  3.25k|
  507|  3.25k|                    // Create instruction
  508|  3.25k|                    Instruction instruction(info);
  509|  3.25k|
  510|  3.25k|                    // Parse arguments
  511|  11.0k|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  512|  8.53k|                    {
  513|  8.53k|                        // Get next token
  514|  8.53k|                        if (!has_one_more_token(tokens, index))
  515|     28|                        {
  516|     28|                            AddParseError(
  517|     28|                                    program,
  518|     28|                                    fmt::format("Missing {} arguments for instruction {}",
  519|     28|                                                (number_of_argument_required - argument_num).get(),
  520|     28|                                                magic_enum::enum_name(opcode)));
  521|     28|                            break;
  522|     28|                        }
  523|  8.50k|
  524|  8.50k|                        current_token = tokens.at(index.get());
  525|  8.50k|                        consume_current_token(index);
  526|  8.50k|
  527|  8.50k|                        // Skip commas
  528|  8.50k|                        if (current_token.GetType() == Token::Type::Comma)
  529|    797|                        {
  530|    797|                            PHI_LOG_DEBUG("Skipping comma");
  531|    797|                            continue;
  532|    797|                        }
  533|  7.70k|
  534|  7.70k|                        if (current_token.GetType() == Token::Type::NewLine)
  535|     36|                        {
  536|     36|                            AddParseError(program, "Unexpected end of line");
  537|     36|                            break;
  538|     36|                        }
  539|  7.66k|
  540|  7.66k|                        std::optional<InstructionArg> optional_parsed_argument =
  541|  7.66k|                                parse_instruction_argument(current_token,
  542|  7.66k|                                                           info.GetArgumentType(argument_num),
  543|  7.66k|                                                           tokens, index, program);
  544|  7.66k|                        if (!optional_parsed_argument.has_value())
  545|    631|                        {
  546|    631|                            AddParseError(program, fmt::format("Failed to parse argument number {}",
  547|    631|                                                               argument_num.get()));
  548|    631|                            break;
  549|    631|                        }
  550|  7.03k|
  551|  7.03k|                        // Successfully parsed one argument
  552|  7.03k|                        InstructionArg parsed_argument = optional_parsed_argument.value();
  553|  7.03k|
  554|  7.03k|                        instruction.SetArgument(argument_num, parsed_argument);
  555|  7.03k|                        argument_num++;
  556|  7.03k|
  557|  7.03k|                        PHI_LOG_INFO("Successfully parsed argument {}", argument_num.get());
  558|  7.03k|                    }
  559|  3.25k|
  560|  3.25k|                    // Only add the instruction if we got no parsing errors
  561|  3.25k|                    if (program.m_ParseErrors.empty())
  562|  1.22k|                    {
  563|  1.22k|                        PHI_LOG_INFO("Successfully parsed instruction '{}'",
  564|  1.22k|                                     instruction.DebugInfo());
  565|  1.22k|                        program.m_Instructions.emplace_back(std::move(instruction));
  566|  1.22k|                        line_has_instruction = true;
  567|  1.22k|                    }
  568|  3.25k|                    break;
  569|  3.25k|                }
  570|  3.25k|
  571|  16.2k|                default:
  572|  16.2k|                    AddParseError(program, "Unexpected token");
  573|  16.2k|                    break;
  574|  90.5k|            }
  575|  90.5k|        }
  576|    479|
  577|    479|        return program;
  578|    479|    }
  579|       |
  580|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::string_view source)
  581|    479|    {
  582|    479|        std::vector<Token> tokens = Tokenize(source);
  583|    479|        return Parse(lib, tokens);
  584|    479|    }
  585|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionImplementation.cpp:
    1|       |#include "DLX/InstructionImplementation.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/Parser.hpp"
    5|       |#include "DLX/Processor.hpp"
    6|       |#include "DLX/RegisterNames.hpp"
    7|       |#include <string_view>
    8|       |
    9|       |namespace dlx
   10|       |{
   11|       |    static std::int32_t clear_top_n_bits(std::int32_t value, std::int32_t n)
   12|      0|    {
   13|      0|        PHI_ASSERT(n > 0 && n < 32, "Would invoke undefined behaviour");
   14|      0|
   15|      0|        return value & ~(-1 << (32 - n));
   16|      0|    }
   17|       |
   18|       |    static void JumpToLabel(Processor& processor, std::string_view label_name)
   19|  12.5k|    {
   20|  12.5k|        // Lookup the label
   21|  12.5k|        const phi::ObserverPtr<ParsedProgram> program = processor.GetCurrentProgramm();
   22|  12.5k|        PHI_ASSERT(program);
   23|  12.5k|
   24|  12.5k|        std::string label(label_name.data(), label_name.size());
   25|  12.5k|        if (program->m_JumpData.find(label) == program->m_JumpData.end())
   26|      6|        {
   27|      6|            PHI_LOG_ERROR("Unable to find jump label {}", label_name);
   28|      6|            processor.Raise(Exception::UnknownLabel);
   29|      6|            return;
   30|      6|        }
   31|  12.5k|
   32|  12.5k|        // Set program counter
   33|  12.5k|        processor.m_NextProgramCounter = program->m_JumpData.at(label);
   34|  12.5k|    }
   35|       |
   36|       |    static void JumpToRegister(Processor& processor, IntRegisterID reg_id)
   37|  20.0k|    {
   38|  20.0k|        phi::u32 address = processor.IntRegisterGetUnsignedValue(reg_id);
   39|  20.0k|
   40|  20.0k|        phi::u32 max_address =
   41|  20.0k|                static_cast<std::uint32_t>(processor.GetCurrentProgramm()->m_Instructions.size());
   42|  20.0k|        if (address >= max_address)
   43|      0|        {
   44|      0|            processor.Raise(Exception::AddressOutOfBounds);
   45|      0|            return;
   46|      0|        }
   47|  20.0k|
   48|  20.0k|        processor.m_NextProgramCounter = address.get();
   49|  20.0k|    }
   50|       |
   51|       |    static std::optional<phi::i32> CalculateDisplacementAddress(
   52|       |            Processor& processor, const InstructionArg::AddressDisplacement& adr_displacement)
   53|  2.51k|    {
   54|  2.51k|        phi::i32 register_value = processor.IntRegisterGetSignedValue(adr_displacement.register_id);
   55|  2.51k|
   56|  2.51k|        phi::i32 address = adr_displacement.displacement + register_value;
   57|  2.51k|
   58|  2.51k|        if (address < 0)
   59|      0|        {
   60|      0|            processor.Raise(Exception::AddressOutOfBounds);
   61|      0|            return {};
   62|      0|        }
   63|  2.51k|
   64|  2.51k|        return address;
   65|  2.51k|    }
   66|       |
   67|       |    static std::optional<phi::i32> GetLoadStoreAddress(Processor&           processor,
   68|       |                                                       const InstructionArg argument)
   69|  2.53k|    {
   70|  2.53k|        if (argument.GetType() == ArgumentType::ImmediateInteger)
   71|     16|        {
   72|     16|            const auto& imm_value = argument.AsImmediateValue();
   73|     16|
   74|     16|            if (imm_value.signed_value < 0)
   75|      0|            {
   76|      0|                return {};
   77|      0|            }
   78|     16|
   79|     16|            return imm_value.signed_value;
   80|     16|        }
   81|  2.51k|        else if (argument.GetType() == ArgumentType::AddressDisplacement)
   82|  2.51k|        {
   83|  2.51k|            const auto& adr_displacement = argument.AsAddressDisplacement();
   84|  2.51k|            return CalculateDisplacementAddress(processor, adr_displacement);
   85|  2.51k|        }
   86|      0|        else
   87|      0|        {
   88|      0|            PHI_ASSERT_NOT_REACHED();
   89|      0|        }
   90|  2.53k|    }
   91|       |
   92|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::i64 value)
   93|  2.58k|    {
   94|  2.58k|        constexpr phi::i64 min = phi::i32::limits_type::min();
   95|  2.58k|        constexpr phi::i64 max = phi::i32::limits_type::max();
   96|  2.58k|
   97|  2.58k|        // Check for underflow
   98|  2.58k|        if (value < min)
   99|      0|        {
  100|      0|            processor.Raise(Exception::Underflow);
  101|      0|
  102|      0|            value = max + (value % (min - 1));
  103|      0|        }
  104|  2.58k|        // Check for overflow
  105|  2.58k|        else if (value > max)
  106|      0|        {
  107|      0|            processor.Raise(Exception::Overflow);
  108|      0|
  109|      0|            value = min + (value % (max + 1));
  110|      0|        }
  111|  2.58k|
  112|  2.58k|        PHI_ASSERT(value >= min);
  113|  2.58k|        PHI_ASSERT(value <= max);
  114|  2.58k|
  115|  2.58k|        processor.IntRegisterSetSignedValue(dest_reg, static_cast<std::int32_t>(value.get()));
  116|  2.58k|    }
  117|       |
  118|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::u64 value)
  119|     67|    {
  120|     67|        constexpr phi::u64 min = phi::u32::limits_type::min();
  121|     67|        constexpr phi::u64 max = phi::u32::limits_type::max();
  122|     67|
  123|     67|        // Check for overflow
  124|     67|        if (value > max)
  125|      0|        {
  126|      0|            processor.Raise(Exception::Overflow);
  127|      0|
  128|      0|            value %= max + 1u;
  129|      0|        }
  130|     67|
  131|     67|        PHI_ASSERT(value <= max);
  132|     67|
  133|     67|        processor.IntRegisterSetUnsignedValue(dest_reg, static_cast<std::uint32_t>(value.get()));
  134|     67|    }
  135|       |
  136|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  137|  2.52k|    {
  138|  2.52k|        phi::i64 res = phi::i64(lhs) + rhs;
  139|  2.52k|
  140|  2.52k|        SafeWriteInteger(processor, dest_reg, res);
  141|  2.52k|    }
  142|       |
  143|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  144|     26|    {
  145|     26|        phi::u64 res = phi::u64(lhs) + rhs;
  146|     26|
  147|     26|        SafeWriteInteger(processor, dest_reg, res);
  148|     26|    }
  149|       |
  150|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  151|       |                            phi::i32 rhs)
  152|     26|    {
  153|     26|        phi::i64 res = phi::i64(lhs) - rhs;
  154|     26|
  155|     26|        SafeWriteInteger(processor, dest_reg, res);
  156|     26|    }
  157|       |
  158|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  159|       |                            phi::u32 rhs)
  160|     26|    {
  161|     26|        constexpr phi::u32 max = phi::u32::limits_type::max();
  162|     26|
  163|     26|        if (lhs < rhs)
  164|      1|        {
  165|      1|            processor.Raise(Exception::Underflow);
  166|      1|
  167|      1|            phi::u64 res = max - rhs + lhs + 1u;
  168|      1|            SafeWriteInteger(processor, dest_reg, res);
  169|      1|            return;
  170|      1|        }
  171|     25|
  172|     25|        phi::u64 res = phi::u64(lhs) - rhs;
  173|     25|
  174|     25|        SafeWriteInteger(processor, dest_reg, res);
  175|     25|    }
  176|       |
  177|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  178|       |                               phi::i32 rhs)
  179|     26|    {
  180|     26|        phi::i64 res = phi::i64(lhs) * rhs;
  181|     26|
  182|     26|        SafeWriteInteger(processor, dest_reg, res);
  183|     26|    }
  184|       |
  185|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  186|       |                               phi::u32 rhs)
  187|     14|    {
  188|     14|        phi::u64 res = phi::u64(lhs) * rhs;
  189|     14|
  190|     14|        SafeWriteInteger(processor, dest_reg, res);
  191|     14|    }
  192|       |
  193|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  194|     14|    {
  195|     14|        if (rhs == 0)
  196|     13|        {
  197|     13|            processor.Raise(Exception::DivideByZero);
  198|     13|            return;
  199|     13|        }
  200|      1|
  201|      1|        phi::i64 res = phi::i64(lhs) / rhs;
  202|      1|
  203|      1|        SafeWriteInteger(processor, dest_reg, res);
  204|      1|    }
  205|       |
  206|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  207|      2|    {
  208|      2|        if (rhs == 0u)
  209|      1|        {
  210|      1|            processor.Raise(Exception::DivideByZero);
  211|      1|            return;
  212|      1|        }
  213|      1|
  214|      1|        phi::u64 res = phi::u64(lhs) / rhs;
  215|      1|
  216|      1|        SafeWriteInteger(processor, dest_reg, res);
  217|      1|    }
  218|       |
  219|       |    static void ShiftRightLogical(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  220|       |                                  phi::i32 shift)
  221|      1|    {
  222|      1|        // Prevent undefined behavior by shifting by more than 31
  223|      1|        if (shift > 31)
  224|      0|        {
  225|      0|            processor.Raise(Exception::BadShift);
  226|      0|
  227|      0|            // Just set register to 0
  228|      0|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  229|      0|            return;
  230|      0|        }
  231|      1|        else if (shift == 0)
  232|      1|        {
  233|      1|            // Do nothing when shifting by zero to prevent undefined behavior
  234|      1|            return;
  235|      1|        }
  236|      0|        else if (shift < 0)
  237|      0|        {
  238|      0|            processor.Raise(Exception::BadShift);
  239|      0|            return;
  240|      0|        }
  241|      0|
  242|      0|        phi::i32 new_value = base.get() >> shift.get();
  243|      0|
  244|      0|        new_value = clear_top_n_bits(new_value.get(), shift.get());
  245|      0|
  246|      0|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  247|      0|    }
  248|       |
  249|       |    static void ShiftRightArithmetic(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  250|       |                                     phi::i32 shift)
  251|      2|    {
  252|      2|        // Prevent undefined behavior by shifting by more than 31
  253|      2|        if (shift > 31)
  254|      0|        {
  255|      0|            processor.Raise(Exception::BadShift);
  256|      0|
  257|      0|            // Is negative ie. sign bit is set
  258|      0|            if (base < 0)
  259|      0|            {
  260|      0|                // Set every byte to 1
  261|      0|                processor.IntRegisterSetSignedValue(dest_reg, ~0);
  262|      0|            }
  263|      0|            else
  264|      0|            {
  265|      0|                // Set every byte to 0
  266|      0|                processor.IntRegisterSetSignedValue(dest_reg, 0);
  267|      0|            }
  268|      0|            return;
  269|      0|        }
  270|      2|        else if (shift < 0)
  271|      0|        {
  272|      0|            processor.Raise(Exception::BadShift);
  273|      0|            return;
  274|      0|        }
  275|      2|
  276|      2|        phi::i32 new_value = base.get() >> shift.get();
  277|      2|
  278|      2|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  279|      2|    }
  280|       |
  281|       |    // Behavior is the same for logical and arithmetic shifts
  282|       |    static void ShiftLeft(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  283|       |                          phi::i32 shift)
  284|      4|    {
  285|      4|        if (shift > 31)
  286|      0|        {
  287|      0|            processor.Raise(Exception::BadShift);
  288|      0|
  289|      0|            // Just set register to 0
  290|      0|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  291|      0|            return;
  292|      0|        }
  293|      4|        else if (shift < 0)
  294|      0|        {
  295|      0|            processor.Raise(Exception::BadShift);
  296|      0|            return;
  297|      0|        }
  298|      4|
  299|      4|        phi::i32 new_value = base.get() << shift.get();
  300|      4|
  301|      4|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  302|      4|    }
  303|       |
  304|       |    namespace impl
  305|       |    {
  306|       |        void ADD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  307|       |                 const InstructionArg& arg3)
  308|  2.51k|        {
  309|  2.51k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  310|  2.51k|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  311|  2.51k|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  312|  2.51k|
  313|  2.51k|            const auto& dest_reg = arg1.AsRegisterInt();
  314|  2.51k|            const auto& lhs_reg  = arg2.AsRegisterInt();
  315|  2.51k|            const auto& rhs_reg  = arg3.AsRegisterInt();
  316|  2.51k|
  317|  2.51k|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  318|  2.51k|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  319|  2.51k|
  320|  2.51k|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  321|  2.51k|        }
  322|       |
  323|       |        void ADDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  324|       |                  const InstructionArg& arg3)
  325|     13|        {
  326|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  327|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  328|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  329|     13|
  330|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  331|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  332|     13|            const auto& imm_value = arg3.AsImmediateValue();
  333|     13|
  334|     13|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  335|     13|
  336|     13|            Addition(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  337|     13|        }
  338|       |
  339|       |        void ADDU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  340|       |                  const InstructionArg& arg3)
  341|     13|        {
  342|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  343|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  344|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  345|     13|
  346|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  347|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  348|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  349|     13|
  350|     13|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  351|     13|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  352|     13|
  353|     13|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  354|     13|        }
  355|       |
  356|       |        void ADDUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  357|       |                   const InstructionArg& arg3)
  358|     13|        {
  359|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  360|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  361|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  362|     13|
  363|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  364|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  365|     13|            const auto& imm_value = arg3.AsImmediateValue();
  366|     13|
  367|     13|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  368|     13|
  369|     13|            Addition(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  370|     13|        }
  371|       |
  372|       |        void SUB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  373|       |                 const InstructionArg& arg3)
  374|     13|        {
  375|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  376|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  377|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  378|     13|
  379|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  380|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  381|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  382|     13|
  383|     13|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  384|     13|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  385|     13|
  386|     13|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  387|     13|        }
  388|       |
  389|       |        void SUBI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  390|       |                  const InstructionArg& arg3)
  391|     13|        {
  392|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  393|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  394|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  395|     13|
  396|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  397|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  398|     13|            const auto& imm_value = arg3.AsImmediateValue();
  399|     13|
  400|     13|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  401|     13|
  402|     13|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  403|     13|        }
  404|       |
  405|       |        void SUBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  406|       |                  const InstructionArg& arg3)
  407|     13|        {
  408|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  409|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  410|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  411|     13|
  412|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  413|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  414|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  415|     13|
  416|     13|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  417|     13|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  418|     13|
  419|     13|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  420|     13|        }
  421|       |
  422|       |        void SUBUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  423|       |                   const InstructionArg& arg3)
  424|     13|        {
  425|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  426|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  427|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  428|     13|
  429|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  430|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  431|     13|            const auto& imm_value = arg3.AsImmediateValue();
  432|     13|
  433|     13|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  434|     13|
  435|     13|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  436|     13|        }
  437|       |
  438|       |        void MULT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  439|       |                  const InstructionArg& arg3)
  440|     13|        {
  441|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  442|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  443|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  444|     13|
  445|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  446|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  447|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  448|     13|
  449|     13|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  450|     13|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  451|     13|
  452|     13|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  453|     13|        }
  454|       |
  455|       |        void MULTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  456|       |                   const InstructionArg& arg3)
  457|     13|        {
  458|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  459|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  460|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  461|     13|
  462|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  463|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  464|     13|            const auto& imm_value = arg3.AsImmediateValue();
  465|     13|
  466|     13|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  467|     13|
  468|     13|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  469|     13|        }
  470|       |
  471|       |        void MULTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  472|       |                   const InstructionArg& arg3)
  473|     13|        {
  474|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  475|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  476|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  477|     13|
  478|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  479|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  480|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  481|     13|
  482|     13|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  483|     13|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  484|     13|
  485|     13|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  486|     13|        }
  487|       |
  488|       |        void MULTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  489|       |                    const InstructionArg& arg3)
  490|      1|        {
  491|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  492|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  493|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  494|      1|
  495|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  496|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  497|      1|            const auto& imm_value = arg3.AsImmediateValue();
  498|      1|
  499|      1|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  500|      1|
  501|      1|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  502|      1|        }
  503|       |
  504|       |        void DIV(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  505|       |                 const InstructionArg& arg3)
  506|     13|        {
  507|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  508|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  509|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  510|     13|
  511|     13|            const auto& dest_reg = arg1.AsRegisterInt();
  512|     13|            const auto& lhs_reg  = arg2.AsRegisterInt();
  513|     13|            const auto& rhs_reg  = arg3.AsRegisterInt();
  514|     13|
  515|     13|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  516|     13|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  517|     13|
  518|     13|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  519|     13|        }
  520|       |
  521|       |        void DIVI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  522|       |                  const InstructionArg& arg3)
  523|      1|        {
  524|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  525|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  526|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  527|      1|
  528|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  529|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  530|      1|            const auto& imm_value = arg3.AsImmediateValue();
  531|      1|
  532|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  533|      1|
  534|      1|            Division(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  535|      1|        }
  536|       |
  537|       |        void DIVU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  538|       |                  const InstructionArg& arg3)
  539|      1|        {
  540|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  541|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  542|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  543|      1|
  544|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  545|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  546|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  547|      1|
  548|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  549|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  550|      1|
  551|      1|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  552|      1|        }
  553|       |
  554|       |        void DIVUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  555|       |                   const InstructionArg& arg3)
  556|      1|        {
  557|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  558|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  559|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  560|      1|
  561|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  562|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  563|      1|            const auto& imm_value = arg3.AsImmediateValue();
  564|      1|
  565|      1|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  566|      1|
  567|      1|            Division(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  568|      1|        }
  569|       |
  570|       |        void SLL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  571|       |                 const InstructionArg& arg3)
  572|      1|        {
  573|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  574|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  575|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  576|      1|
  577|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  578|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  579|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  580|      1|
  581|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  582|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  583|      1|
  584|      1|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  585|      1|        }
  586|       |
  587|       |        void SLLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  588|       |                  const InstructionArg& arg3)
  589|      1|        {
  590|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  591|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  592|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  593|      1|
  594|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  595|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  596|      1|            const auto& imm_value = arg3.AsImmediateValue();
  597|      1|
  598|      1|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  599|      1|            phi::i32 shift_value = imm_value.signed_value;
  600|      1|
  601|      1|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  602|      1|        }
  603|       |
  604|       |        void SRL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  605|       |                 const InstructionArg& arg3)
  606|      1|        {
  607|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  608|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  609|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  610|      1|
  611|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  612|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  613|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  614|      1|
  615|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  616|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  617|      1|
  618|      1|            ShiftRightLogical(processor, dest_reg.register_id, lhs_value, rhs_value);
  619|      1|        }
  620|       |
  621|       |        void SRLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  622|       |                  const InstructionArg& arg3)
  623|      0|        {
  624|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  625|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  626|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  627|      0|
  628|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  629|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  630|      0|            const auto& imm_value = arg3.AsImmediateValue();
  631|      0|
  632|      0|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  633|      0|            phi::i32 shift_value = imm_value.signed_value;
  634|      0|
  635|      0|            ShiftRightLogical(processor, dest_reg.register_id, src_value, shift_value);
  636|      0|        }
  637|       |
  638|       |        void SLA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  639|       |                 const InstructionArg& arg3)
  640|      1|        {
  641|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  642|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  643|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  644|      1|
  645|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  646|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  647|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  648|      1|
  649|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  650|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  651|      1|
  652|      1|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  653|      1|        }
  654|       |
  655|       |        void SLAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  656|       |                  const InstructionArg& arg3)
  657|      1|        {
  658|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  659|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  660|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  661|      1|
  662|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  663|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  664|      1|            const auto& imm_value = arg3.AsImmediateValue();
  665|      1|
  666|      1|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  667|      1|            phi::i32 shift_value = imm_value.signed_value;
  668|      1|
  669|      1|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  670|      1|        }
  671|       |
  672|       |        void SRA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  673|       |                 const InstructionArg& arg3)
  674|      1|        {
  675|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  676|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  677|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  678|      1|
  679|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  680|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  681|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  682|      1|
  683|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  684|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  685|      1|
  686|      1|            ShiftRightArithmetic(processor, dest_reg.register_id, lhs_value, rhs_value);
  687|      1|        }
  688|       |
  689|       |        void SRAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  690|       |                  const InstructionArg& arg3)
  691|      1|        {
  692|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  693|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  694|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  695|      1|
  696|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  697|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  698|      1|            const auto& imm_value = arg3.AsImmediateValue();
  699|      1|
  700|      1|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  701|      1|            phi::i32 shift_value = imm_value.signed_value;
  702|      1|
  703|      1|            ShiftRightArithmetic(processor, dest_reg.register_id, src_value, shift_value);
  704|      1|        }
  705|       |
  706|       |        void AND(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  707|       |                 const InstructionArg& arg3)
  708|      1|        {
  709|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  710|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  711|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  712|      1|
  713|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  714|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  715|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  716|      1|
  717|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  718|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  719|      1|            phi::i32 new_value = lhs_value.get() & rhs_value.get();
  720|      1|
  721|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  722|      1|        }
  723|       |
  724|       |        void ANDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  725|       |                  const InstructionArg& arg3)
  726|      1|        {
  727|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  728|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  729|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  730|      1|
  731|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  732|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  733|      1|            const auto& imm_value = arg3.AsImmediateValue();
  734|      1|
  735|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  736|      1|            phi::i32 new_value = src_value.get() & imm_value.signed_value.get();
  737|      1|
  738|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  739|      1|        }
  740|       |
  741|       |        void OR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  742|       |                const InstructionArg& arg3)
  743|      1|        {
  744|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  745|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  746|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  747|      1|
  748|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  749|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  750|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  751|      1|
  752|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  753|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  754|      1|            phi::i32 new_value = lhs_value.get() | rhs_value.get();
  755|      1|
  756|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  757|      1|        }
  758|       |
  759|       |        void ORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  760|       |                 const InstructionArg& arg3)
  761|      1|        {
  762|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  763|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  764|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  765|      1|
  766|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  767|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  768|      1|            const auto& imm_value = arg3.AsImmediateValue();
  769|      1|
  770|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  771|      1|            phi::i32 new_value = src_value.get() | imm_value.signed_value.get();
  772|      1|
  773|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  774|      1|        }
  775|       |
  776|       |        void XOR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  777|       |                 const InstructionArg& arg3)
  778|      1|        {
  779|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  780|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  781|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  782|      1|
  783|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  784|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  785|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  786|      1|
  787|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  788|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  789|      1|            phi::i32 new_value = lhs_value.get() ^ rhs_value.get();
  790|      1|
  791|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  792|      1|        }
  793|       |
  794|       |        void XORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  795|       |                  const InstructionArg& arg3)
  796|      1|        {
  797|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  798|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  799|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  800|      1|
  801|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  802|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  803|      1|            const auto& imm_value = arg3.AsImmediateValue();
  804|      1|
  805|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  806|      1|            phi::i32 new_value = src_value.get() ^ imm_value.signed_value.get();
  807|      1|
  808|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  809|      1|        }
  810|       |
  811|       |        void SLT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  812|       |                 const InstructionArg& arg3)
  813|      1|        {
  814|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  815|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  816|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  817|      1|
  818|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  819|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  820|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  821|      1|
  822|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  823|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  824|      1|
  825|      1|            const phi::i32 new_value = (lhs_value < rhs_value ? 1 : 0);
  826|      1|
  827|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  828|      1|        }
  829|       |
  830|       |        void SLTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  831|       |                  const InstructionArg& arg3)
  832|      1|        {
  833|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  834|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  835|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  836|      1|
  837|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  838|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  839|      1|            const auto& imm_value = arg3.AsImmediateValue();
  840|      1|
  841|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  842|      1|
  843|      1|            const phi::i32 new_value = (src_value < imm_value.signed_value ? 1 : 0);
  844|      1|
  845|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  846|      1|        }
  847|       |
  848|       |        void SGT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  849|       |                 const InstructionArg& arg3)
  850|      1|        {
  851|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  852|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  853|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  854|      1|
  855|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  856|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  857|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  858|      1|
  859|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  860|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  861|      1|
  862|      1|            const phi::i32 new_value = (lhs_value > rhs_value ? 1 : 0);
  863|      1|
  864|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  865|      1|        }
  866|       |
  867|       |        void SGTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  868|       |                  const InstructionArg& arg3)
  869|      1|        {
  870|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  871|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  872|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  873|      1|
  874|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  875|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  876|      1|            const auto& imm_value = arg3.AsImmediateValue();
  877|      1|
  878|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  879|      1|
  880|      1|            const phi::i32 new_value = (src_value > imm_value.signed_value ? 1 : 0);
  881|      1|
  882|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  883|      1|        }
  884|       |
  885|       |        void SLE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  886|       |                 const InstructionArg& arg3)
  887|      1|        {
  888|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  889|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  890|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  891|      1|
  892|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  893|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  894|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  895|      1|
  896|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  897|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  898|      1|
  899|      1|            const phi::i32 new_value = (lhs_value <= rhs_value ? 1 : 0);
  900|      1|
  901|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  902|      1|        }
  903|       |
  904|       |        void SLEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  905|       |                  const InstructionArg& arg3)
  906|      1|        {
  907|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  908|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  909|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  910|      1|
  911|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  912|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  913|      1|            const auto& imm_value = arg3.AsImmediateValue();
  914|      1|
  915|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  916|      1|
  917|      1|            const phi::i32 new_value = (src_value <= imm_value.signed_value ? 1 : 0);
  918|      1|
  919|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  920|      1|        }
  921|       |
  922|       |        void SGE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  923|       |                 const InstructionArg& arg3)
  924|      0|        {
  925|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  926|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  927|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  928|      0|
  929|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  930|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  931|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  932|      0|
  933|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  934|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  935|      0|
  936|      0|            const phi::i32 new_value = (lhs_value >= rhs_value ? 1 : 0);
  937|      0|
  938|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  939|      0|        }
  940|       |
  941|       |        void SGEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  942|       |                  const InstructionArg& arg3)
  943|     12|        {
  944|     12|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  945|     12|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  946|     12|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  947|     12|
  948|     12|            const auto& dest_reg  = arg1.AsRegisterInt();
  949|     12|            const auto& src_reg   = arg2.AsRegisterInt();
  950|     12|            const auto& imm_value = arg3.AsImmediateValue();
  951|     12|
  952|     12|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  953|     12|
  954|     12|            const phi::i32 new_value = (src_value >= imm_value.signed_value ? 1 : 0);
  955|     12|
  956|     12|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  957|     12|        }
  958|       |
  959|       |        void SEQ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  960|       |                 const InstructionArg& arg3)
  961|  12.5k|        {
  962|  12.5k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  963|  12.5k|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  964|  12.5k|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  965|  12.5k|
  966|  12.5k|            const auto& dest_reg = arg1.AsRegisterInt();
  967|  12.5k|            const auto& lhs_reg  = arg2.AsRegisterInt();
  968|  12.5k|            const auto& rhs_reg  = arg3.AsRegisterInt();
  969|  12.5k|
  970|  12.5k|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  971|  12.5k|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  972|  12.5k|
  973|  12.5k|            const phi::i32 new_value = (lhs_value == rhs_value ? 1 : 0);
  974|  12.5k|
  975|  12.5k|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  976|  12.5k|        }
  977|       |
  978|       |        void SEQI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  979|       |                  const InstructionArg& arg3)
  980|      1|        {
  981|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  982|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  983|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  984|      1|
  985|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  986|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  987|      1|            const auto& imm_value = arg3.AsImmediateValue();
  988|      1|
  989|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  990|      1|
  991|      1|            const phi::i32 new_value = (src_value == imm_value.signed_value ? 1 : 0);
  992|      1|
  993|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  994|      1|        }
  995|       |
  996|       |        void SNE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  997|       |                 const InstructionArg& arg3)
  998|      1|        {
  999|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1000|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1001|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1002|      1|
 1003|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1004|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1005|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1006|      1|
 1007|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1008|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1009|      1|
 1010|      1|            const phi::i32 new_value = (lhs_value != rhs_value ? 1 : 0);
 1011|      1|
 1012|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1013|      1|        }
 1014|       |
 1015|       |        void SNEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1016|       |                  const InstructionArg& arg3)
 1017|      1|        {
 1018|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1019|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1020|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1021|      1|
 1022|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1023|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1024|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1025|      1|
 1026|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1027|      1|
 1028|      1|            const phi::i32 new_value = (src_value != imm_value.signed_value ? 1 : 0);
 1029|      1|
 1030|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1031|      1|        }
 1032|       |
 1033|       |        void BEQZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1034|       |                  const InstructionArg& arg3)
 1035|      3|        {
 1036|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1037|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1038|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1039|      3|
 1040|      3|            const auto& test_reg   = arg1.AsRegisterInt();
 1041|      3|            const auto& jump_label = arg2.AsLabel();
 1042|      3|
 1043|      3|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1044|      3|
 1045|      3|            if (test_value == 0)
 1046|      3|            {
 1047|      3|                JumpToLabel(processor, jump_label.label_name);
 1048|      3|            }
 1049|      3|        }
 1050|       |
 1051|       |        void BNEZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1052|       |                  const InstructionArg& arg3)
 1053|      2|        {
 1054|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1055|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1056|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1057|      2|
 1058|      2|            const auto& test_reg   = arg1.AsRegisterInt();
 1059|      2|            const auto& jump_label = arg2.AsLabel();
 1060|      2|
 1061|      2|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1062|      2|
 1063|      2|            if (test_value != 0)
 1064|      1|            {
 1065|      1|                JumpToLabel(processor, jump_label.label_name);
 1066|      1|            }
 1067|      2|        }
 1068|       |
 1069|       |        void J(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1070|       |               const InstructionArg& arg3)
 1071|  12.5k|        {
 1072|  12.5k|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1073|  12.5k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1074|  12.5k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1075|  12.5k|
 1076|  12.5k|            const auto& jump_label = arg1.AsLabel();
 1077|  12.5k|
 1078|  12.5k|            JumpToLabel(processor, jump_label.label_name);
 1079|  12.5k|        }
 1080|       |
 1081|       |        void JR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1082|       |                const InstructionArg& arg3)
 1083|  10.0k|        {
 1084|  10.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1085|  10.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1086|  10.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1087|  10.0k|
 1088|  10.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1089|  10.0k|
 1090|  10.0k|            JumpToRegister(processor, jump_register.register_id);
 1091|  10.0k|        }
 1092|       |
 1093|       |        void JAL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1094|       |                 const InstructionArg& arg3)
 1095|      1|        {
 1096|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1097|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1098|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1099|      1|
 1100|      1|            const auto& jump_label = arg1.AsLabel();
 1101|      1|
 1102|      1|            processor.IntRegisterSetUnsignedValue(
 1103|      1|                    IntRegisterID::R31,
 1104|      1|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1105|      1|
 1106|      1|            JumpToLabel(processor, jump_label.label_name);
 1107|      1|        }
 1108|       |
 1109|       |        void JALR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1110|       |                  const InstructionArg& arg3)
 1111|  10.0k|        {
 1112|  10.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1113|  10.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1114|  10.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1115|  10.0k|
 1116|  10.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1117|  10.0k|
 1118|  10.0k|            processor.IntRegisterSetUnsignedValue(
 1119|  10.0k|                    IntRegisterID::R31,
 1120|  10.0k|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1121|  10.0k|
 1122|  10.0k|            JumpToRegister(processor, jump_register.register_id);
 1123|  10.0k|        }
 1124|       |
 1125|       |        void LB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1126|       |                const InstructionArg& arg3)
 1127|      1|        {
 1128|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1129|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1130|      1|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1131|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1132|      1|
 1133|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1134|      1|
 1135|      1|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1136|      1|
 1137|      1|            if (!optional_address.has_value())
 1138|      0|            {
 1139|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1140|      0|                return;
 1141|      0|            }
 1142|      1|
 1143|      1|            phi::i32 address = optional_address.value();
 1144|      1|
 1145|      1|            auto optional_value =
 1146|      1|                    processor.m_MemoryBlock.LoadByte(static_cast<std::size_t>(address.get()));
 1147|      1|
 1148|      1|            if (!optional_value.has_value())
 1149|      0|            {
 1150|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1151|      0|                PHI_LOG_ERROR("Failed to load byte at address {}", address.get());
 1152|      0|                return;
 1153|      0|            }
 1154|      1|
 1155|      1|            phi::i32 value = optional_value.value();
 1156|      1|
 1157|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, value);
 1158|      1|        }
 1159|       |
 1160|       |        void LBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1161|       |                 const InstructionArg& arg3)
 1162|      2|        {
 1163|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1164|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1165|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1166|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1167|      2|
 1168|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1169|      2|
 1170|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1171|      2|
 1172|      2|            if (!optional_address.has_value())
 1173|      0|            {
 1174|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1175|      0|                return;
 1176|      0|            }
 1177|      2|
 1178|      2|            phi::i32 address = optional_address.value();
 1179|      2|
 1180|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedByte(
 1181|      2|                    static_cast<std::size_t>(address.get()));
 1182|      2|
 1183|      2|            if (!optional_value.has_value())
 1184|      0|            {
 1185|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1186|      0|                PHI_LOG_ERROR("Failed to load unsigned byte at address {}", address.get());
 1187|      0|                return;
 1188|      0|            }
 1189|      2|
 1190|      2|            phi::i32 value = optional_value.value();
 1191|      2|
 1192|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1193|      2|        }
 1194|       |
 1195|       |        void LH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1196|       |                const InstructionArg& arg3)
 1197|      2|        {
 1198|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1199|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1200|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1201|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1202|      2|
 1203|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1204|      2|
 1205|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1206|      2|
 1207|      2|            if (!optional_address.has_value())
 1208|      0|            {
 1209|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1210|      0|                return;
 1211|      0|            }
 1212|      2|
 1213|      2|            phi::i32 address = optional_address.value();
 1214|      2|
 1215|      2|            auto optional_value =
 1216|      2|                    processor.m_MemoryBlock.LoadHalfWord(static_cast<std::size_t>(address.get()));
 1217|      2|
 1218|      2|            if (!optional_value.has_value())
 1219|      0|            {
 1220|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1221|      0|                PHI_LOG_ERROR("Failed to load half byte at address {}", address.get());
 1222|      0|                return;
 1223|      0|            }
 1224|      2|
 1225|      2|            phi::i32 value = optional_value.value();
 1226|      2|
 1227|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1228|      2|        }
 1229|       |
 1230|       |        void LHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1231|       |                 const InstructionArg& arg3)
 1232|      2|        {
 1233|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1234|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1235|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1236|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1237|      2|
 1238|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1239|      2|
 1240|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1241|      2|
 1242|      2|            if (!optional_address.has_value())
 1243|      0|            {
 1244|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1245|      0|                return;
 1246|      0|            }
 1247|      2|
 1248|      2|            phi::i32 address = optional_address.value();
 1249|      2|
 1250|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedHalfWord(
 1251|      2|                    static_cast<std::size_t>(address.get()));
 1252|      2|
 1253|      2|            if (!optional_value.has_value())
 1254|      0|            {
 1255|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1256|      0|                PHI_LOG_ERROR("Failed to load unsigned half byte at address {}", address.get());
 1257|      0|                return;
 1258|      0|            }
 1259|      2|
 1260|      2|            phi::i32 value = optional_value.value();
 1261|      2|
 1262|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1263|      2|        }
 1264|       |
 1265|       |        void LW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1266|       |                const InstructionArg& arg3)
 1267|  2.50k|        {
 1268|  2.50k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1269|  2.50k|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1270|  2.50k|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1271|  2.50k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1272|  2.50k|
 1273|  2.50k|            const auto& dest_reg = arg1.AsRegisterInt();
 1274|  2.50k|
 1275|  2.50k|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1276|  2.50k|
 1277|  2.50k|            if (!optional_address.has_value())
 1278|      0|            {
 1279|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1280|      0|                return;
 1281|      0|            }
 1282|  2.50k|
 1283|  2.50k|            phi::i32 address = optional_address.value();
 1284|  2.50k|
 1285|  2.50k|            auto optional_value =
 1286|  2.50k|                    processor.m_MemoryBlock.LoadWord(static_cast<std::size_t>(address.get()));
 1287|  2.50k|
 1288|  2.50k|            if (!optional_value.has_value())
 1289|      1|            {
 1290|      1|                processor.Raise(Exception::AddressOutOfBounds);
 1291|      1|                PHI_LOG_ERROR("Failed to load word at address {}", address.get());
 1292|      1|                return;
 1293|      1|            }
 1294|  2.50k|
 1295|  2.50k|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1296|  2.50k|        }
 1297|       |
 1298|       |        void LWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1299|       |                 const InstructionArg& arg3)
 1300|      2|        {
 1301|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1302|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1303|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1304|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1305|      2|
 1306|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1307|      2|
 1308|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1309|      2|
 1310|      2|            if (!optional_address.has_value())
 1311|      0|            {
 1312|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1313|      0|                return;
 1314|      0|            }
 1315|      2|
 1316|      2|            phi::i32 address = optional_address.value();
 1317|      2|
 1318|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedWord(
 1319|      2|                    static_cast<std::size_t>(address.get()));
 1320|      2|
 1321|      2|            if (!optional_value.has_value())
 1322|      0|            {
 1323|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1324|      0|                PHI_LOG_ERROR("Failed to load unsigned word at address {}", address.get());
 1325|      0|                return;
 1326|      0|            }
 1327|      2|
 1328|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1329|      2|        }
 1330|       |
 1331|       |        void SB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1332|       |                const InstructionArg& arg3)
 1333|      4|        {
 1334|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1335|      4|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1336|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1337|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1338|      4|
 1339|      4|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1340|      4|
 1341|      4|            if (!optional_address.has_value())
 1342|      0|            {
 1343|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1344|      0|                return;
 1345|      0|            }
 1346|      4|
 1347|      4|            phi::i32 address = optional_address.value();
 1348|      4|
 1349|      4|            const auto& src_reg = arg2.AsRegisterInt();
 1350|      4|
 1351|      4|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1352|      4|
 1353|      4|            phi::Boolean success = processor.m_MemoryBlock.StoreByte(
 1354|      4|                    static_cast<std::size_t>(address.get()), static_cast<std::int8_t>(value.get()));
 1355|      4|
 1356|      4|            if (!success)
 1357|      2|            {
 1358|      2|                processor.Raise(Exception::AddressOutOfBounds);
 1359|      2|                PHI_LOG_ERROR("Failed to store byte at address {}", address.get());
 1360|      2|            }
 1361|      4|        }
 1362|       |
 1363|       |        void SBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1364|       |                 const InstructionArg& arg3)
 1365|      2|        {
 1366|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1367|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1368|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1369|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1370|      2|
 1371|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1372|      2|
 1373|      2|            if (!optional_address.has_value())
 1374|      0|            {
 1375|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1376|      0|                return;
 1377|      0|            }
 1378|      2|
 1379|      2|            phi::i32 address = optional_address.value();
 1380|      2|
 1381|      2|            const auto& src_reg = arg2.AsRegisterInt();
 1382|      2|
 1383|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1384|      2|
 1385|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedByte(
 1386|      2|                    static_cast<std::size_t>(address.get()),
 1387|      2|                    static_cast<std::uint8_t>(value.get()));
 1388|      2|
 1389|      2|            if (!success)
 1390|      0|            {
 1391|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1392|      0|                PHI_LOG_ERROR("Failed to store unsigned byte at address {}", address.get());
 1393|      0|            }
 1394|      2|        }
 1395|       |
 1396|       |        void SH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1397|       |                const InstructionArg& arg3)
 1398|      2|        {
 1399|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1400|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1401|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1402|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1403|      2|
 1404|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1405|      2|
 1406|      2|            if (!optional_address.has_value())
 1407|      0|            {
 1408|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1409|      0|                return;
 1410|      0|            }
 1411|      2|
 1412|      2|            phi::i32 address = optional_address.value();
 1413|      2|
 1414|      2|            const auto& src_reg = arg2.AsRegisterInt();
 1415|      2|
 1416|      2|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1417|      2|
 1418|      2|            phi::Boolean success =
 1419|      2|                    processor.m_MemoryBlock.StoreHalfWord(static_cast<std::size_t>(address.get()),
 1420|      2|                                                          static_cast<std::int16_t>(value.get()));
 1421|      2|
 1422|      2|            if (!success)
 1423|      0|            {
 1424|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1425|      0|                PHI_LOG_ERROR("Failed to store half word at address {}", address.get());
 1426|      0|            }
 1427|      2|        }
 1428|       |
 1429|       |        void SHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1430|       |                 const InstructionArg& arg3)
 1431|      2|        {
 1432|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1433|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1434|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1435|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1436|      2|
 1437|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1438|      2|
 1439|      2|            if (!optional_address.has_value())
 1440|      0|            {
 1441|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1442|      0|                return;
 1443|      0|            }
 1444|      2|
 1445|      2|            phi::i32 address = optional_address.value();
 1446|      2|
 1447|      2|            const auto& src_reg = arg2.AsRegisterInt();
 1448|      2|
 1449|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1450|      2|
 1451|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedHalfWord(
 1452|      2|                    static_cast<std::size_t>(address.get()),
 1453|      2|                    static_cast<std::uint16_t>(value.get()));
 1454|      2|
 1455|      2|            if (!success)
 1456|      0|            {
 1457|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1458|      0|                PHI_LOG_ERROR("Failed to store unsigned half word at address {}", address.get());
 1459|      0|            }
 1460|      2|        }
 1461|       |
 1462|       |        void SW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1463|       |                const InstructionArg& arg3)
 1464|      4|        {
 1465|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1466|      4|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1467|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1468|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1469|      4|
 1470|      4|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1471|      4|
 1472|      4|            if (!optional_address.has_value())
 1473|      0|            {
 1474|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1475|      0|                return;
 1476|      0|            }
 1477|      4|
 1478|      4|            phi::i32 address = optional_address.value();
 1479|      4|
 1480|      4|            const auto& src_reg = arg2.AsRegisterInt();
 1481|      4|
 1482|      4|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1483|      4|
 1484|      4|            phi::Boolean success = processor.m_MemoryBlock.StoreWord(
 1485|      4|                    static_cast<std::size_t>(address.get()), value);
 1486|      4|
 1487|      4|            if (!success)
 1488|      1|            {
 1489|      1|                processor.Raise(Exception::AddressOutOfBounds);
 1490|      1|                PHI_LOG_ERROR("Failed to store word at address {}", address.get());
 1491|      1|            }
 1492|      4|        }
 1493|       |
 1494|       |        void SWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1495|       |                 const InstructionArg& arg3)
 1496|      2|        {
 1497|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1498|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1499|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1500|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1501|      2|
 1502|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1503|      2|
 1504|      2|            if (!optional_address.has_value())
 1505|      0|            {
 1506|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1507|      0|                return;
 1508|      0|            }
 1509|      2|
 1510|      2|            phi::i32 address = optional_address.value();
 1511|      2|
 1512|      2|            const auto& src_reg = arg2.AsRegisterInt();
 1513|      2|
 1514|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1515|      2|
 1516|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedWord(
 1517|      2|                    static_cast<std::size_t>(address.get()), value);
 1518|      2|
 1519|      2|            if (!success)
 1520|      0|            {
 1521|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1522|      0|                PHI_LOG_ERROR("Failed to store unsigned word at address {}", address.get());
 1523|      0|            }
 1524|      2|        }
 1525|       |
 1526|       |        void TRAP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1527|       |                  const InstructionArg& arg3)
 1528|      1|        {
 1529|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::ImmediateInteger);
 1530|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1531|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1532|      1|
 1533|      1|            processor.Raise(Exception::Trap);
 1534|      1|        }
 1535|       |
 1536|       |        void HALT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1537|       |                  const InstructionArg& arg3)
 1538|      1|        {
 1539|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 1540|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1541|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1542|      1|
 1543|      1|            processor.Raise(Exception::Halt);
 1544|      1|        }
 1545|       |
 1546|       |        void NOP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1547|       |                 const InstructionArg& arg3)
 1548|      8|        {
 1549|      8|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 1550|      8|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1551|      8|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1552|      8|
 1553|      8|            /* Do nothing */
 1554|      8|        }
 1555|       |    } // namespace impl
 1556|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Token.cpp:
    1|       |#include "DLX/Token.hpp"
    2|       |
    3|       |#include <magic_enum.hpp>
    4|       |#include <string>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    Token::Token(Type type, std::string_view text, phi::u64 line_number, phi::u64 column)
    9|       |        : m_Type{type}
   10|       |        , m_Text{text}
   11|       |        , m_LineNumber{line_number}
   12|       |        , m_Column{column}
   13|  99.5k|    {}
   14|       |
   15|       |    Token::Type Token::GetType() const noexcept
   16|   114k|    {
   17|   114k|        return m_Type;
   18|   114k|    }
   19|       |
   20|       |    std::string_view Token::GetTypeName() const noexcept
   21|    256|    {
   22|    256|        return magic_enum::enum_name(m_Type);
   23|    256|    }
   24|       |
   25|       |    phi::u64 Token::GetLineNumber() const noexcept
   26|  98.1k|    {
   27|  98.1k|        return m_LineNumber;
   28|  98.1k|    }
   29|       |
   30|       |    phi::u64 Token::GetColumn() const noexcept
   31|  98.1k|    {
   32|  98.1k|        return m_Column;
   33|  98.1k|    }
   34|       |
   35|       |    phi::usize Token::GetLength() const noexcept
   36|      0|    {
   37|      0|        return m_Text.length();
   38|      0|    }
   39|       |
   40|       |    std::string_view Token::GetText() const noexcept
   41|   176k|    {
   42|   176k|        return m_Text;
   43|   176k|    }
   44|       |
   45|       |    std::string Token::GetTextString() const noexcept
   46|   119k|    {
   47|   119k|        return std::string(m_Text.data(), m_Text.length());
   48|   119k|    }
   49|       |
   50|       |    std::string Token::DebugInfo() const noexcept
   51|  98.1k|    {
   52|  98.1k|        std::string pos_info = "(" + std::to_string(GetLineNumber().get()) + ":" +
   53|  98.1k|                               std::to_string(GetColumn().get()) + ")";
   54|  98.1k|
   55|  98.1k|        switch (m_Type)
   56|  98.1k|        {
   57|  3.51k|            case Type::Colon:
   58|  3.51k|                return "Token[Colon]" + pos_info;
   59|  3.48k|            case Type::Comma:
   60|  3.48k|                return "Token[Comma]" + pos_info;
   61|  2.19k|            case Type::Comment:
   62|  2.19k|                return "Token[Comment]" + pos_info + ": '" + GetTextString() + "'";
   63|  62.5k|            case Type::Identifier:
   64|  62.5k|                return "Token[Identifier]" + pos_info + ": '" + GetTextString() + "'";
   65|  15.5k|            case Type::NewLine:
   66|  15.5k|                return "Token[NewLine]" + pos_info;
   67|  4.12k|            case Type::OpenBracket:
   68|  4.12k|                return "Token[OpenBracket]" + pos_info;
   69|  3.97k|            case Type::ClosingBracket:
   70|  3.97k|                return "Token[OpenBracket]" + pos_info;
   71|    881|            case Type::IntegerLiteral:
   72|    881|                return "Token[IntegerLiteral]" + pos_info + ": '" + GetTextString() + "'";
   73|  1.84k|            case Type::ImmediateInteger:
   74|  1.84k|                return "Token[ImmediateInteger]" + pos_info + ": " + GetTextString() + "'";
   75|      0|            case Type::Unknown:
   76|      0|                return "Token[Unknown]" + pos_info;
   77|      0|            default:
   78|      0|                PHI_ASSERT_NOT_REACHED();
   79|      0|                return "Token[NotFound]" + pos_info;
   80|  98.1k|        }
   81|  98.1k|    }
   82|       |} // namespace dlx

