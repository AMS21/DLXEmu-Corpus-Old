/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Instruction.cpp:
    1|       |#include "DLX/Instruction.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include <Phi/Core/Assert.hpp>
    5|       |#include <magic_enum.hpp>
    6|       |#include <spdlog/fmt/bundled/format.h>
    7|       |#include <spdlog/fmt/fmt.h>
    8|       |
    9|       |namespace dlx
   10|       |{
   11|       |    Instruction::Instruction(const InstructionInfo& info) noexcept
   12|       |        : m_Info(info)
   13|  2.62k|    {}
   14|       |
   15|       |    void Instruction::SetArgument(phi::u8 argument_number, InstructionArg argument) noexcept
   16|    708|    {
   17|    708|        PHI_ASSERT(argument_number < 3u);
   18|       |
   19|    708|        switch (argument_number.get())
   20|    708|        {
   21|    335|            case 0u:
   22|    335|                m_Arg1 = argument;
   23|    335|                break;
   24|    305|            case 1u:
   25|    305|                m_Arg2 = argument;
   26|    305|                break;
   27|     68|            case 2u:
   28|     68|                m_Arg3 = argument;
   29|     68|                break;
   30|      0|            default:
   31|      0|                PHI_ASSERT_NOT_REACHED();
   32|    708|        }
   33|    708|    }
   34|       |
   35|       |    std::string Instruction::DebugInfo() const noexcept
   36|      0|    {
   37|      0|        switch (m_Info.GetNumberOfRequiredArguments().get())
   38|      0|        {
   39|      0|            case 0:
   40|      0|                return fmt::format("{}", magic_enum::enum_name(m_Info.GetOpCode()));
   41|      0|            case 1:
   42|      0|                return fmt::format("{}, {}", magic_enum::enum_name(m_Info.GetOpCode()),
   43|      0|                                   m_Arg1.DebugInfo());
   44|      0|            case 2:
   45|      0|                return fmt::format("{}, {}, {}", magic_enum::enum_name(m_Info.GetOpCode()),
   46|      0|                                   m_Arg1.DebugInfo(), m_Arg2.DebugInfo());
   47|      0|            case 3:
   48|      0|                return fmt::format("{}, {}, {}, {}", magic_enum::enum_name(m_Info.GetOpCode()),
   49|      0|                                   m_Arg1.DebugInfo(), m_Arg2.DebugInfo(), m_Arg3.DebugInfo());
   50|      0|            default:
   51|      0|                PHI_ASSERT_NOT_REACHED();
   52|      0|                break;
   53|      0|        }
   54|       |
   55|      0|        PHI_ASSERT_NOT_REACHED();
   56|      0|        return "Unknown";
   57|      0|    }
   58|       |
   59|       |    void Instruction::Execute(Processor& processor) const noexcept
   60|  50.1k|    {
   61|  50.1k|        m_Info.Execute(processor, m_Arg1, m_Arg2, m_Arg3);
   62|  50.1k|    }
   63|       |
   64|       |    const InstructionInfo& Instruction::GetInfo() const noexcept
   65|  50.1k|    {
   66|  50.1k|        return m_Info;
   67|  50.1k|    }
   68|       |
   69|       |    const InstructionArg& Instruction::GetArg1() const noexcept
   70|      0|    {
   71|      0|        return m_Arg1;
   72|      0|    }
   73|       |
   74|       |    const InstructionArg& Instruction::GetArg2() const noexcept
   75|      0|    {
   76|      0|        return m_Arg2;
   77|      0|    }
   78|       |
   79|       |    const InstructionArg& Instruction::GetArg3() const noexcept
   80|      0|    {
   81|      0|        return m_Arg3;
   82|      0|    }
   83|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/IntRegister.cpp:
    1|       |#include "DLX/IntRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    IntRegister::IntRegister() noexcept
    6|       |        : m_ValueSigned{0}
    7|       |        , m_IsReadOnly{false}
    8|  32.1k|    {}
    9|       |
   10|       |    void IntRegister::SetSignedValue(phi::i32 val) noexcept
   11|  32.2k|    {
   12|  32.2k|        m_ValueSigned = val;
   13|  32.2k|    }
   14|       |
   15|       |    void IntRegister::SetUnsignedValue(phi::u32 val) noexcept
   16|  10.0k|    {
   17|  10.0k|        m_ValueUnsigned = val;
   18|  10.0k|    }
   19|       |
   20|       |    phi::i32 IntRegister::GetSignedValue() const noexcept
   21|     94|    {
   22|     94|        return m_ValueSigned;
   23|     94|    }
   24|       |
   25|       |    phi::u32 IntRegister::GetUnsignedValue() const noexcept
   26|  40.0k|    {
   27|  40.0k|        return m_ValueUnsigned;
   28|  40.0k|    }
   29|       |
   30|       |    phi::Boolean IntRegister::IsReadOnly() const noexcept
   31|  10.0k|    {
   32|  10.0k|        return m_IsReadOnly;
   33|  10.0k|    }
   34|       |
   35|       |    void IntRegister::SetReadOnly(phi::Boolean read_only) noexcept
   36|  1.00k|    {
   37|  1.00k|        m_IsReadOnly = read_only;
   38|  1.00k|    }
   39|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/OpCode.cpp:
    1|       |#include "DLX/OpCode.hpp"
    2|       |
    3|       |#include <magic_enum.hpp>
    4|       |#include <algorithm>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    OpCode StringToOpCode(std::string_view token) noexcept
    9|   183k|    {
   10|   183k|        std::optional<OpCode> opcode_casted = magic_enum::enum_cast<OpCode>(token);
   11|   183k|        if (opcode_casted.has_value())
   12|  3.33k|        {
   13|       |            // TODO: Bit of a hacky way around magic_enum begin able to cast every member...
   14|  3.33k|            if (opcode_casted.value() == OpCode::NUMBER_OF_ELEMENTS)
   15|      5|            {
   16|      5|                return OpCode::NONE;
   17|      5|            }
   18|  3.33k|            return opcode_casted.value();
   19|  3.33k|        }
   20|       |
   21|       |        // None found
   22|   179k|        return OpCode::NONE;
   23|   183k|    }
   24|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionLibrary.cpp:
    1|       |#include "DLX/InstructionLibrary.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionImplementation.hpp"
    5|       |#include "DLX/InstructionInfo.hpp"
    6|       |#include <magic_enum.hpp>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    InstructionLibrary::InstructionLibrary() noexcept
   11|       |        : m_Instructions()
   12|  1.00k|    {
   13|  1.00k|        PHI_ASSERT(Initialize());
   14|  1.00k|    }
   15|       |
   16|       |    phi::Boolean InstructionLibrary::Initialize() noexcept
   17|  1.00k|    {
   18|       |        /* Arithmetic */
   19|       |
   20|       |        // Addition
   21|  1.00k|        InitInstruction(OpCode::ADD, ArgumentType::IntRegister, ArgumentType::IntRegister,
   22|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::ADD);
   23|  1.00k|        InitInstruction(OpCode::ADDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   24|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::ADDI);
   25|  1.00k|        InitInstruction(OpCode::ADDU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   26|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::ADDU);
   27|  1.00k|        InitInstruction(OpCode::ADDUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   28|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::ADDUI);
   29|  1.00k|        InitInstruction(OpCode::ADDF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   30|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::ADDF);
   31|  1.00k|        InitInstruction(OpCode::ADDD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   32|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::ADDD);
   33|       |
   34|       |        // Subtraction
   35|  1.00k|        InitInstruction(OpCode::SUB, ArgumentType::IntRegister, ArgumentType::IntRegister,
   36|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SUB);
   37|  1.00k|        InitInstruction(OpCode::SUBI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   38|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SUBI);
   39|  1.00k|        InitInstruction(OpCode::SUBU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   40|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SUBU);
   41|  1.00k|        InitInstruction(OpCode::SUBUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   42|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SUBUI);
   43|  1.00k|        InitInstruction(OpCode::SUBF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   44|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::SUBF);
   45|  1.00k|        InitInstruction(OpCode::SUBD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   46|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::SUBD);
   47|       |
   48|       |        // Multiplikation
   49|  1.00k|        InitInstruction(OpCode::MULT, ArgumentType::IntRegister, ArgumentType::IntRegister,
   50|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::MULT);
   51|  1.00k|        InitInstruction(OpCode::MULTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   52|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::MULTI);
   53|  1.00k|        InitInstruction(OpCode::MULTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   54|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::MULTU);
   55|  1.00k|        InitInstruction(OpCode::MULTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   56|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::MULTUI);
   57|  1.00k|        InitInstruction(OpCode::MULTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   58|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::MULTF);
   59|  1.00k|        InitInstruction(OpCode::MULTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   60|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::MULTD);
   61|       |
   62|       |        // Division
   63|  1.00k|        InitInstruction(OpCode::DIV, ArgumentType::IntRegister, ArgumentType::IntRegister,
   64|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::DIV);
   65|  1.00k|        InitInstruction(OpCode::DIVI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   66|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::DIVI);
   67|  1.00k|        InitInstruction(OpCode::DIVU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   68|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::DIVU);
   69|  1.00k|        InitInstruction(OpCode::DIVUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   70|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::DIVUI);
   71|  1.00k|        InitInstruction(OpCode::DIVF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   72|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::DIVF);
   73|  1.00k|        InitInstruction(OpCode::DIVD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   74|  1.00k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::DIVD);
   75|       |
   76|       |        // Shift left logical
   77|  1.00k|        InitInstruction(OpCode::SLL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   78|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLL);
   79|  1.00k|        InitInstruction(OpCode::SLLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   80|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLLI);
   81|       |
   82|       |        // Shift right logical
   83|  1.00k|        InitInstruction(OpCode::SRL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   84|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRL);
   85|  1.00k|        InitInstruction(OpCode::SRLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   86|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRLI);
   87|       |
   88|       |        // Shift left arithmetic
   89|  1.00k|        InitInstruction(OpCode::SLA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   90|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLA);
   91|  1.00k|        InitInstruction(OpCode::SLAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   92|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLAI);
   93|       |
   94|       |        // Shift right arithmetic
   95|  1.00k|        InitInstruction(OpCode::SRA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   96|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRA);
   97|  1.00k|        InitInstruction(OpCode::SRAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   98|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRAI);
   99|       |
  100|       |        /* Logical */
  101|       |
  102|       |        // And
  103|  1.00k|        InitInstruction(OpCode::AND, ArgumentType::IntRegister, ArgumentType::IntRegister,
  104|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::AND);
  105|  1.00k|        InitInstruction(OpCode::ANDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  106|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ANDI);
  107|       |
  108|       |        // Or
  109|  1.00k|        InitInstruction(OpCode::OR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  110|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::OR);
  111|  1.00k|        InitInstruction(OpCode::ORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  112|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ORI);
  113|       |
  114|       |        // Xor
  115|  1.00k|        InitInstruction(OpCode::XOR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  116|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::XOR);
  117|  1.00k|        InitInstruction(OpCode::XORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  118|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::XORI);
  119|       |
  120|       |        /* Conditionals */
  121|       |
  122|       |        // Set less than
  123|  1.00k|        InitInstruction(OpCode::SLT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  124|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SLT);
  125|  1.00k|        InitInstruction(OpCode::SLTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  126|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SLTI);
  127|  1.00k|        InitInstruction(OpCode::SLTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  128|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SLTU);
  129|  1.00k|        InitInstruction(OpCode::SLTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  130|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SLTUI);
  131|  1.00k|        InitInstruction(OpCode::LTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  132|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::LTF);
  133|  1.00k|        InitInstruction(OpCode::LTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  134|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::LTD);
  135|       |
  136|       |        // Set greater than
  137|  1.00k|        InitInstruction(OpCode::SGT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  138|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SGT);
  139|  1.00k|        InitInstruction(OpCode::SGTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  140|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SGTI);
  141|  1.00k|        InitInstruction(OpCode::SGTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  142|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SGTU);
  143|  1.00k|        InitInstruction(OpCode::SGTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  144|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SGTUI);
  145|  1.00k|        InitInstruction(OpCode::GTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  146|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::GTF);
  147|  1.00k|        InitInstruction(OpCode::GTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  148|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::GTD);
  149|       |
  150|       |        // Set less than or equal
  151|  1.00k|        InitInstruction(OpCode::SLE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  152|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SLE);
  153|  1.00k|        InitInstruction(OpCode::SLEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  154|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SLEI);
  155|  1.00k|        InitInstruction(OpCode::SLEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  156|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SLEU);
  157|  1.00k|        InitInstruction(OpCode::SLEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  158|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SLEUI);
  159|  1.00k|        InitInstruction(OpCode::LEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  160|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::LEF);
  161|  1.00k|        InitInstruction(OpCode::LED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  162|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::LED);
  163|       |
  164|       |        // Set greater than or equal
  165|  1.00k|        InitInstruction(OpCode::SGE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  166|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SGE);
  167|  1.00k|        InitInstruction(OpCode::SGEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  168|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SGEI);
  169|  1.00k|        InitInstruction(OpCode::SGEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  170|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SGEU);
  171|  1.00k|        InitInstruction(OpCode::SGEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  172|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SGEUI);
  173|  1.00k|        InitInstruction(OpCode::GEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  174|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::GEF);
  175|  1.00k|        InitInstruction(OpCode::GED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  176|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::GED);
  177|       |
  178|       |        // Set equal
  179|  1.00k|        InitInstruction(OpCode::SEQ, ArgumentType::IntRegister, ArgumentType::IntRegister,
  180|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SEQ);
  181|  1.00k|        InitInstruction(OpCode::SEQI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  182|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SEQI);
  183|  1.00k|        InitInstruction(OpCode::SEQU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  184|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SEQU);
  185|  1.00k|        InitInstruction(OpCode::SEQUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  186|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SEQUI);
  187|  1.00k|        InitInstruction(OpCode::EQF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  188|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::EQF);
  189|  1.00k|        InitInstruction(OpCode::EQD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  190|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::EQD);
  191|       |
  192|       |        // Set not equal
  193|  1.00k|        InitInstruction(OpCode::SNE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  194|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SNE);
  195|  1.00k|        InitInstruction(OpCode::SNEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  196|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SNEI);
  197|  1.00k|        InitInstruction(OpCode::SNEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  198|  1.00k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SNEU);
  199|  1.00k|        InitInstruction(OpCode::SNEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  200|  1.00k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SNEUI);
  201|  1.00k|        InitInstruction(OpCode::NEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  202|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::NEF);
  203|  1.00k|        InitInstruction(OpCode::NED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  204|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::NED);
  205|       |
  206|       |        /* Conditional branching */
  207|       |
  208|       |        // Branch equal zero
  209|  1.00k|        InitInstruction(OpCode::BEQZ, ArgumentType::IntRegister, ArgumentType::Label,
  210|  1.00k|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BEQZ);
  211|       |
  212|       |        // Branch not equal zero
  213|  1.00k|        InitInstruction(OpCode::BNEZ, ArgumentType::IntRegister, ArgumentType::Label,
  214|  1.00k|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BNEZ);
  215|       |
  216|       |        // Branch floating point true
  217|  1.00k|        InitInstruction(OpCode::BFPT, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  218|  1.00k|                        RegisterAccessType::Ignored, impl::BFPT);
  219|       |
  220|       |        // Branch floating point false
  221|  1.00k|        InitInstruction(OpCode::BFPF, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  222|  1.00k|                        RegisterAccessType::Ignored, impl::BFPF);
  223|       |
  224|       |        /* Unconditional branching */
  225|       |
  226|       |        // Jump
  227|  1.00k|        InitInstruction(OpCode::J, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  228|  1.00k|                        RegisterAccessType::None, impl::J);
  229|       |
  230|       |        // Jump to register
  231|  1.00k|        InitInstruction(OpCode::JR, ArgumentType::IntRegister, ArgumentType::None,
  232|  1.00k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JR);
  233|       |
  234|       |        // Jump and link
  235|  1.00k|        InitInstruction(OpCode::JAL, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  236|  1.00k|                        RegisterAccessType::Unsigned, impl::JAL);
  237|       |
  238|       |        // Jump and link to register
  239|  1.00k|        InitInstruction(OpCode::JALR, ArgumentType::IntRegister, ArgumentType::None,
  240|  1.00k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JALR);
  241|       |
  242|       |        /* Loading data */
  243|       |
  244|       |        // Load high immediate
  245|  1.00k|        InitInstruction(OpCode::LHI, ArgumentType::IntRegister, ArgumentType::ImmediateInteger,
  246|  1.00k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LHI);
  247|       |
  248|       |        // Load byte
  249|  1.00k|        InitInstruction(OpCode::LB, ArgumentType::IntRegister,
  250|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  251|  1.00k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LB);
  252|       |
  253|       |        // Load byte unsigned
  254|  1.00k|        InitInstruction(OpCode::LBU, ArgumentType::IntRegister,
  255|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  256|  1.00k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LBU);
  257|       |
  258|       |        // Load half word
  259|  1.00k|        InitInstruction(OpCode::LH, ArgumentType::IntRegister,
  260|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  261|  1.00k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LH);
  262|       |
  263|       |        // Load half word unsigned
  264|  1.00k|        InitInstruction(OpCode::LHU, ArgumentType::IntRegister,
  265|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  266|  1.00k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LHU);
  267|       |
  268|       |        // Load word
  269|  1.00k|        InitInstruction(OpCode::LW, ArgumentType::IntRegister,
  270|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  271|  1.00k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LW);
  272|       |
  273|       |        // Load word unsigned
  274|  1.00k|        InitInstruction(OpCode::LWU, ArgumentType::IntRegister,
  275|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  276|  1.00k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LWU);
  277|       |
  278|       |        // Load float
  279|  1.00k|        InitInstruction(OpCode::LF, ArgumentType::FloatRegister,
  280|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  281|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::LF);
  282|       |
  283|       |        // Load double
  284|  1.00k|        InitInstruction(OpCode::LD, ArgumentType::FloatRegister,
  285|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  286|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::LD);
  287|       |
  288|       |        /* Storing data */
  289|       |
  290|       |        // Store byte
  291|  1.00k|        InitInstruction(OpCode::SB,
  292|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  293|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  294|  1.00k|                        impl::SB);
  295|       |
  296|       |        // Store byte unsigned
  297|  1.00k|        InitInstruction(OpCode::SBU,
  298|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  299|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  300|  1.00k|                        impl::SBU);
  301|       |
  302|       |        // Store half word
  303|  1.00k|        InitInstruction(OpCode::SH,
  304|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  305|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  306|  1.00k|                        impl::SH);
  307|       |
  308|       |        // Store half word unsigned
  309|  1.00k|        InitInstruction(OpCode::SHU,
  310|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  311|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  312|  1.00k|                        impl::SHU);
  313|       |
  314|       |        // Store word
  315|  1.00k|        InitInstruction(OpCode::SW,
  316|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  317|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  318|  1.00k|                        impl::SW);
  319|       |
  320|       |        // Store word unsigned
  321|  1.00k|        InitInstruction(OpCode::SWU,
  322|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  323|  1.00k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  324|  1.00k|                        impl::SWU);
  325|       |
  326|       |        // Store float
  327|  1.00k|        InitInstruction(OpCode::SF,
  328|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  329|  1.00k|                        ArgumentType::FloatRegister, ArgumentType::None, RegisterAccessType::Float,
  330|  1.00k|                        impl::SF);
  331|       |
  332|       |        // Store double
  333|  1.00k|        InitInstruction(OpCode::SD,
  334|  1.00k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  335|  1.00k|                        ArgumentType::FloatRegister, ArgumentType::None, RegisterAccessType::Double,
  336|  1.00k|                        impl::SD);
  337|       |
  338|       |        /* Moving data */
  339|       |
  340|       |        // Move float
  341|  1.00k|        InitInstruction(OpCode::MOVF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  342|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVF);
  343|       |
  344|       |        // Move double
  345|  1.00k|        InitInstruction(OpCode::MOVD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  346|  1.00k|                        ArgumentType::None, RegisterAccessType::Double, impl::MOVD);
  347|       |
  348|       |        // Move float to int
  349|  1.00k|        InitInstruction(OpCode::MOVFP2I, ArgumentType::IntRegister, ArgumentType::FloatRegister,
  350|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVFP2I);
  351|       |
  352|       |        // Move int to float
  353|  1.00k|        InitInstruction(OpCode::MOVI2FP, ArgumentType::FloatRegister, ArgumentType::IntRegister,
  354|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVI2FP);
  355|       |
  356|       |        /* Converting data */
  357|       |
  358|       |        // Convert float to double
  359|  1.00k|        InitInstruction(OpCode::CVTF2D, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  360|  1.00k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTF2D);
  361|       |
  362|       |        // Convert float to int
  363|  1.00k|        InitInstruction(OpCode::CVTF2I, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  364|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::CVTF2I);
  365|       |
  366|       |        // Convert double to float
  367|  1.00k|        InitInstruction(OpCode::CVTD2F, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  368|  1.00k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTD2F);
  369|       |
  370|       |        // Convert double to int
  371|  1.00k|        InitInstruction(OpCode::CVTD2I, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  372|  1.00k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTD2I);
  373|       |
  374|       |        // Convert int to float
  375|  1.00k|        InitInstruction(OpCode::CVTI2F, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  376|  1.00k|                        ArgumentType::None, RegisterAccessType::Float, impl::CVTI2F);
  377|       |
  378|       |        // Convert int to double
  379|  1.00k|        InitInstruction(OpCode::CVTI2D, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  380|  1.00k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTI2D);
  381|       |
  382|       |        /* Special */
  383|       |
  384|       |        // Trap
  385|  1.00k|        InitInstruction(OpCode::TRAP, ArgumentType::ImmediateInteger, ArgumentType::None,
  386|  1.00k|                        ArgumentType::None, RegisterAccessType::None, impl::TRAP);
  387|       |
  388|       |        // Halt
  389|  1.00k|        InitInstruction(OpCode::HALT, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  390|  1.00k|                        RegisterAccessType::None, impl::HALT);
  391|       |
  392|       |        // No operation
  393|  1.00k|        InitInstruction(OpCode::NOP, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  394|  1.00k|                        RegisterAccessType::None, impl::NOP);
  395|       |
  396|  1.00k|        return true;
  397|  1.00k|    }
  398|       |
  399|       |    const InstructionInfo& InstructionLibrary::LookUp(OpCode instruction) const noexcept
  400|   115k|    {
  401|   115k|        return m_Instructions.at(static_cast<std::size_t>(instruction));
  402|   115k|    }
  403|       |
  404|       |    void InstructionLibrary::InitInstruction(OpCode opcode, ArgumentType arg1, ArgumentType arg2,
  405|       |                                             ArgumentType        arg3,
  406|       |                                             RegisterAccessType  register_access_type,
  407|       |                                             InstructionExecutor executor) noexcept
  408|   112k|    {
  409|   112k|        PHI_ASSERT(LookUp(opcode).GetExecutor() == nullptr, "Already registered instruction {}",
  410|   112k|                   magic_enum::enum_name(opcode));
  411|       |
  412|   112k|        m_Instructions.at(static_cast<std::size_t>(opcode)) =
  413|   112k|                InstructionInfo(opcode, arg1, arg2, arg3, register_access_type, executor);
  414|   112k|    }
  415|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/RegisterNames.cpp:
    1|       |#include "DLX/RegisterNames.hpp"
    2|       |
    3|       |#include "DLX/Containers/LookUpMap.hpp"
    4|       |#include <algorithm>
    5|       |#include <cctype>
    6|       |#include <string_view>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    static constexpr std::array<std::pair<std::string_view, IntRegisterID>, 32> IntRegisterValues{
   11|       |            {{"R0", IntRegisterID::R0},   {"R1", IntRegisterID::R1},   {"R2", IntRegisterID::R2},
   12|       |             {"R3", IntRegisterID::R3},   {"R4", IntRegisterID::R4},   {"R5", IntRegisterID::R5},
   13|       |             {"R6", IntRegisterID::R6},   {"R7", IntRegisterID::R7},   {"R8", IntRegisterID::R8},
   14|       |             {"R9", IntRegisterID::R9},   {"R10", IntRegisterID::R10}, {"R11", IntRegisterID::R11},
   15|       |             {"R12", IntRegisterID::R12}, {"R13", IntRegisterID::R13}, {"R14", IntRegisterID::R14},
   16|       |             {"R15", IntRegisterID::R15}, {"R16", IntRegisterID::R16}, {"R17", IntRegisterID::R17},
   17|       |             {"R18", IntRegisterID::R18}, {"R19", IntRegisterID::R19}, {"R20", IntRegisterID::R20},
   18|       |             {"R21", IntRegisterID::R21}, {"R22", IntRegisterID::R22}, {"R23", IntRegisterID::R23},
   19|       |             {"R24", IntRegisterID::R24}, {"R25", IntRegisterID::R25}, {"R26", IntRegisterID::R26},
   20|       |             {"R27", IntRegisterID::R27}, {"R28", IntRegisterID::R28}, {"R29", IntRegisterID::R29},
   21|       |             {"R30", IntRegisterID::R30}, {"R31", IntRegisterID::R31}}};
   22|       |
   23|       |    static constexpr std::array<std::pair<std::string_view, FloatRegisterID>, 32>
   24|       |            FloatRegisterValues{{{"F0", FloatRegisterID::F0},   {"F1", FloatRegisterID::F1},
   25|       |                                 {"F2", FloatRegisterID::F2},   {"F3", FloatRegisterID::F3},
   26|       |                                 {"F4", FloatRegisterID::F4},   {"F5", FloatRegisterID::F5},
   27|       |                                 {"F6", FloatRegisterID::F6},   {"F7", FloatRegisterID::F7},
   28|       |                                 {"F8", FloatRegisterID::F8},   {"F9", FloatRegisterID::F9},
   29|       |                                 {"F10", FloatRegisterID::F10}, {"F11", FloatRegisterID::F11},
   30|       |                                 {"F12", FloatRegisterID::F12}, {"F13", FloatRegisterID::F13},
   31|       |                                 {"F14", FloatRegisterID::F14}, {"F15", FloatRegisterID::F15},
   32|       |                                 {"F16", FloatRegisterID::F16}, {"F17", FloatRegisterID::F17},
   33|       |                                 {"F18", FloatRegisterID::F18}, {"F19", FloatRegisterID::F19},
   34|       |                                 {"F20", FloatRegisterID::F20}, {"F21", FloatRegisterID::F21},
   35|       |                                 {"F22", FloatRegisterID::F22}, {"F23", FloatRegisterID::F23},
   36|       |                                 {"F24", FloatRegisterID::F24}, {"F25", FloatRegisterID::F25},
   37|       |                                 {"F26", FloatRegisterID::F26}, {"F27", FloatRegisterID::F27},
   38|       |                                 {"F28", FloatRegisterID::F28}, {"F29", FloatRegisterID::F29},
   39|       |                                 {"F30", FloatRegisterID::F30}, {"F31", FloatRegisterID::F31}}};
   40|       |
   41|       |    IntRegisterID StringToIntRegister(std::string_view token) noexcept
   42|   183k|    {
   43|   183k|        static constexpr auto map =
   44|   183k|                LookUpMap<std::string_view, IntRegisterID, IntRegisterValues.size()>(
   45|   183k|                        IntRegisterValues, IntRegisterID::None);
   46|       |
   47|   183k|        return map.at(token);
   48|   183k|    }
   49|       |
   50|       |    FloatRegisterID StringToFloatRegister(std::string_view token) noexcept
   51|   183k|    {
   52|   183k|        static constexpr auto map =
   53|   183k|                LookUpMap<std::string_view, FloatRegisterID, FloatRegisterValues.size()>(
   54|   183k|                        FloatRegisterValues, FloatRegisterID::None);
   55|       |
   56|   183k|        return map.at(token);
   57|   183k|    }
   58|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/StatusRegister.cpp:
    1|       |#include "DLX/StatusRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void StatusRegister::SetStatus(phi::Boolean value) noexcept
    6|  1.00k|    {
    7|  1.00k|        m_Value = value;
    8|  1.00k|    }
    9|       |
   10|       |    phi::Boolean StatusRegister::Get() const noexcept
   11|      0|    {
   12|      0|        return m_Value;
   13|      0|    }
   14|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Token.cpp:
    1|       |#include "DLX/Token.hpp"
    2|       |
    3|       |#include <Phi/Core/Assert.hpp>
    4|       |#include <Phi/Core/Boolean.hpp>
    5|       |#include <magic_enum.hpp>
    6|       |#include <string>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    Token::Token(Type type, std::string_view text, phi::u64 line_number, phi::u64 column) noexcept
   11|       |        : m_Type{type}
   12|       |        , m_Text{text}
   13|       |        , m_LineNumber{line_number}
   14|       |        , m_Column{column}
   15|       |        , m_HasHint{false}
   16|       |        , m_Hint{0u}
   17|   264k|    {}
   18|       |
   19|       |    Token::Token(Type type, std::string_view text, phi::u64 line_number, phi::u64 column,
   20|       |                 std::uint32_t hint) noexcept
   21|       |        : m_Type{type}
   22|       |        , m_Text{text}
   23|       |        , m_LineNumber{line_number}
   24|       |        , m_Column{column}
   25|       |        , m_HasHint{true}
   26|       |        , m_Hint{hint}
   27|  5.01k|    {}
   28|       |
   29|       |    Token::Type Token::GetType() const noexcept
   30|  21.1M|    {
   31|  21.1M|        return m_Type;
   32|  21.1M|    }
   33|       |
   34|       |    std::string_view Token::GetTypeName() const noexcept
   35|  1.30k|    {
   36|  1.30k|        return magic_enum::enum_name(m_Type);
   37|  1.30k|    }
   38|       |
   39|       |    phi::u64 Token::GetLineNumber() const noexcept
   40|   232k|    {
   41|   232k|        return m_LineNumber;
   42|   232k|    }
   43|       |
   44|       |    phi::u64 Token::GetColumn() const noexcept
   45|   215k|    {
   46|   215k|        return m_Column;
   47|   215k|    }
   48|       |
   49|       |    phi::usize Token::GetLength() const noexcept
   50|      0|    {
   51|      0|        return m_Text.length();
   52|      0|    }
   53|       |
   54|       |    std::string_view Token::GetText() const noexcept
   55|  12.3M|    {
   56|  12.3M|        return m_Text;
   57|  12.3M|    }
   58|       |
   59|       |    std::string Token::GetTextString() const noexcept
   60|      0|    {
   61|      0|        return std::string(m_Text.data(), m_Text.length());
   62|      0|    }
   63|       |
   64|       |    phi::Boolean Token::HasHint() const noexcept
   65|    261|    {
   66|    261|        return m_HasHint;
   67|    261|    }
   68|       |
   69|       |    std::uint32_t Token::GetHint() const noexcept
   70|  3.30k|    {
   71|  3.30k|        PHI_ASSERT(m_Type == Type::RegisterInt || m_Type == Type::RegisterFloat ||
   72|  3.30k|                   m_Type == Type::IntegerLiteral || m_Type == Type::OpCode ||
   73|  3.30k|                   m_Type == Type::ImmediateInteger);
   74|  3.30k|        PHI_ASSERT(m_HasHint);
   75|       |
   76|  3.30k|        return m_Hint;
   77|  3.30k|    }
   78|       |
   79|       |    std::string Token::DebugInfo() const noexcept
   80|      0|    {
   81|      0|        std::string pos_info = "(" + std::to_string(GetLineNumber().get()) + ":" +
   82|      0|                               std::to_string(GetColumn().get()) + ")";
   83|       |
   84|      0|        switch (m_Type)
   85|      0|        {
   86|      0|            case Type::Colon:
   87|      0|                return "Token[Colon]" + pos_info;
   88|      0|            case Type::Comma:
   89|      0|                return "Token[Comma]" + pos_info;
   90|      0|            case Type::Comment:
   91|      0|                return "Token[Comment]" + pos_info + ": '" + GetTextString() + "'";
   92|      0|            case Type::OpCode:
   93|      0|                return "Token[OpCode]" + pos_info + ": '" + GetTextString() + "'";
   94|      0|            case Type::RegisterInt:
   95|      0|                return "Token[RegisterInt]" + pos_info + ": '" + GetTextString() + "'";
   96|      0|            case Type::RegisterFloat:
   97|      0|                return "Token[RegisterFloat]" + pos_info + ": '" + GetTextString() + "'";
   98|      0|            case Type::RegisterStatus:
   99|      0|                return "Token[RegisterStatus]" + pos_info + ": '" + GetTextString() + "'";
  100|      0|            case Type::LabelIdentifier:
  101|      0|                return "Token[LabelIdentifier]" + pos_info + ": '" + GetTextString() + "'";
  102|      0|            case Type::NewLine:
  103|      0|                return "Token[NewLine]" + pos_info;
  104|      0|            case Type::OpenBracket:
  105|      0|                return "Token[OpenBracket]" + pos_info;
  106|      0|            case Type::ClosingBracket:
  107|      0|                return "Token[ClosingBracket]" + pos_info;
  108|      0|            case Type::IntegerLiteral:
  109|      0|                return "Token[IntegerLiteral]" + pos_info + ": '" + GetTextString() + "'";
  110|      0|            case Type::ImmediateInteger:
  111|      0|                return "Token[ImmediateInteger]" + pos_info + ": " + GetTextString() + "'";
  112|      0|            case Type::Unknown:
  113|      0|                return "Token[Unknown]" + pos_info;
  114|      0|            default:
  115|      0|                PHI_ASSERT_NOT_REACHED();
  116|      0|                return "Token[NotFound]" + pos_info;
  117|      0|        }
  118|      0|    }
  119|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Processor.cpp:
    1|       |#include "DLX/Processor.hpp"
    2|       |
    3|       |#include "DLX/FloatRegister.hpp"
    4|       |#include "DLX/Instruction.hpp"
    5|       |#include "DLX/InstructionInfo.hpp"
    6|       |#include "DLX/IntRegister.hpp"
    7|       |#include "DLX/Parser.hpp"
    8|       |#include "DLX/RegisterNames.hpp"
    9|       |#include "DLX/StatusRegister.hpp"
   10|       |#include <Phi/Core/Boolean.hpp>
   11|       |#include <Phi/Core/Log.hpp>
   12|       |#include <Phi/Core/Types.hpp>
   13|       |#include <magic_enum.hpp>
   14|       |#include <spdlog/fmt/bundled/core.h>
   15|       |#include <spdlog/fmt/bundled/format.h>
   16|       |#include <utility>
   17|       |
   18|       |namespace dlx
   19|       |{
   20|       |    static phi::Boolean RegisterAccessTypeMatches(RegisterAccessType expected_access,
   21|       |                                                  RegisterAccessType access) noexcept
   22|  50.1k|    {
   23|  50.1k|        PHI_ASSERT(access == RegisterAccessType::Signed || access == RegisterAccessType::Unsigned ||
   24|  50.1k|                   access == RegisterAccessType::Float || access == RegisterAccessType::Double);
   25|       |
   26|  50.1k|        switch (expected_access)
   27|  50.1k|        {
   28|     53|            case RegisterAccessType::Ignored:
   29|     53|                return true;
   30|      0|            case RegisterAccessType::None:
   31|      0|                return false;
   32|      0|            case RegisterAccessType::MixedFloatDouble:
   33|      0|                return access == RegisterAccessType::Float || access == RegisterAccessType::Double;
   34|  50.1k|            default:
   35|  50.1k|                return expected_access == access;
   36|  50.1k|        }
   37|  50.1k|    }
   38|       |
   39|       |    Processor::Processor() noexcept
   40|       |        : m_MemoryBlock(1000u, 1000u)
   41|  1.00k|    {
   42|       |        // Mark R0 as ready only
   43|  1.00k|        m_IntRegisters.at(0).SetReadOnly(true);
   44|  1.00k|    }
   45|       |
   46|       |    IntRegister& Processor::GetIntRegister(IntRegisterID id) noexcept
   47|  10.0k|    {
   48|  10.0k|        PHI_ASSERT(id != IntRegisterID::None);
   49|  10.0k|        std::underlying_type_t<IntRegisterID> id_value =
   50|  10.0k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   51|       |
   52|  10.0k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   53|       |
   54|  10.0k|        return m_IntRegisters.at(id_value);
   55|  10.0k|    }
   56|       |
   57|       |    const IntRegister& Processor::GetIntRegister(IntRegisterID id) const noexcept
   58|  40.1k|    {
   59|  40.1k|        PHI_ASSERT(id != IntRegisterID::None);
   60|  40.1k|        std::underlying_type_t<IntRegisterID> id_value =
   61|  40.1k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   62|       |
   63|  40.1k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   64|       |
   65|  40.1k|        return m_IntRegisters.at(id_value);
   66|  40.1k|    }
   67|       |
   68|       |    phi::i32 Processor::IntRegisterGetSignedValue(IntRegisterID id) const noexcept
   69|     94|    {
   70|     94|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   71|      7|        {
   72|      7|            PHI_LOG_WARN("Mismatch for instruction access type");
   73|      7|        }
   74|       |
   75|     94|        return GetIntRegister(id).GetSignedValue();
   76|     94|    }
   77|       |
   78|       |    phi::u32 Processor::IntRegisterGetUnsignedValue(IntRegisterID id) const noexcept
   79|  40.0k|    {
   80|  40.0k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
   81|  40.0k|                                       RegisterAccessType::Unsigned))
   82|      0|        {
   83|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   84|      0|        }
   85|       |
   86|  40.0k|        return GetIntRegister(id).GetUnsignedValue();
   87|  40.0k|    }
   88|       |
   89|       |    void Processor::IntRegisterSetSignedValue(IntRegisterID id, phi::i32 value) noexcept
   90|     48|    {
   91|     48|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   92|      0|        {
   93|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   94|      0|        }
   95|       |
   96|     48|        IntRegister& reg = GetIntRegister(id);
   97|       |
   98|     48|        if (reg.IsReadOnly())
   99|      0|        {
  100|      0|            return;
  101|      0|        }
  102|       |
  103|     48|        reg.SetSignedValue(value);
  104|     48|    }
  105|       |
  106|       |    void Processor::IntRegisterSetUnsignedValue(IntRegisterID id, phi::u32 value) noexcept
  107|  10.0k|    {
  108|  10.0k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
  109|  10.0k|                                       RegisterAccessType::Unsigned))
  110|      0|        {
  111|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  112|      0|        }
  113|       |
  114|  10.0k|        IntRegister& reg = GetIntRegister(id);
  115|       |
  116|  10.0k|        if (reg.IsReadOnly())
  117|      0|        {
  118|      0|            return;
  119|      0|        }
  120|       |
  121|  10.0k|        reg.SetUnsignedValue(value);
  122|  10.0k|    }
  123|       |
  124|       |    FloatRegister& Processor::GetFloatRegister(FloatRegisterID id) noexcept
  125|      0|    {
  126|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  127|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  128|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  129|       |
  130|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  131|       |
  132|      0|        return m_FloatRegisters.at(id_value);
  133|      0|    }
  134|       |
  135|       |    const FloatRegister& Processor::GetFloatRegister(FloatRegisterID id) const noexcept
  136|      0|    {
  137|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  138|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  139|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  140|       |
  141|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  142|       |
  143|      0|        return m_FloatRegisters.at(id_value);
  144|      0|    }
  145|       |
  146|       |    [[nodiscard]] phi::f32 Processor::FloatRegisterGetFloatValue(FloatRegisterID id) const noexcept
  147|      0|    {
  148|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  149|      0|        {
  150|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  151|      0|        }
  152|       |
  153|      0|        const FloatRegister& reg = GetFloatRegister(id);
  154|       |
  155|      0|        return reg.GetValue();
  156|      0|    }
  157|       |
  158|       |    [[nodiscard]] phi::f64 Processor::FloatRegisterGetDoubleValue(FloatRegisterID id) noexcept
  159|      0|    {
  160|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  161|      0|        {
  162|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  163|      0|        }
  164|       |
  165|      0|        if (id == FloatRegisterID::F31)
  166|      0|        {
  167|      0|            Raise(Exception::RegisterOutOfBounds);
  168|      0|            return phi::f64(0.0);
  169|      0|        }
  170|       |
  171|      0|        const FloatRegister& first_reg = GetFloatRegister(id);
  172|      0|        const FloatRegister& second_reg =
  173|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  174|       |
  175|      0|        const float first_value  = first_reg.GetValue().get();
  176|      0|        const float second_value = second_reg.GetValue().get();
  177|       |
  178|      0|        const std::uint32_t first_value_bits =
  179|      0|                *reinterpret_cast<const std::uint32_t*>(&first_value);
  180|      0|        const std::uint32_t second_value_bits =
  181|      0|                *reinterpret_cast<const std::uint32_t*>(&second_value);
  182|       |
  183|      0|        std::uint64_t final_value_bits =
  184|      0|                static_cast<std::uint64_t>(second_value_bits) << 32u | first_value_bits;
  185|       |
  186|      0|        return *reinterpret_cast<double*>(&final_value_bits);
  187|      0|    }
  188|       |
  189|       |    void Processor::FloatRegisterSetFloatValue(FloatRegisterID id, phi::f32 value) noexcept
  190|      0|    {
  191|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  192|      0|        {
  193|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  194|      0|        }
  195|       |
  196|      0|        FloatRegister& reg = GetFloatRegister(id);
  197|       |
  198|      0|        reg.SetValue(value);
  199|      0|    }
  200|       |
  201|       |    void Processor::FloatRegisterSetDoubleValue(FloatRegisterID id, phi::f64 value) noexcept
  202|      0|    {
  203|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  204|      0|        {
  205|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  206|      0|        }
  207|       |
  208|      0|        if (id == FloatRegisterID::F31)
  209|      0|        {
  210|      0|            Raise(Exception::RegisterOutOfBounds);
  211|      0|            return;
  212|      0|        }
  213|       |
  214|      0|        const constexpr std::uint64_t first_32_bits  = 0b11111111'11111111'11111111'11111111;
  215|      0|        const constexpr std::uint64_t second_32_bits = first_32_bits << 32u;
  216|       |
  217|      0|        double              value_raw  = value.get();
  218|      0|        const std::uint64_t value_bits = *reinterpret_cast<std::uint64_t*>(&value_raw);
  219|       |
  220|      0|        const std::uint32_t first_bits  = value_bits & first_32_bits;
  221|      0|        const std::uint32_t second_bits = (value_bits & second_32_bits) >> 32u;
  222|       |
  223|      0|        const float first_value  = *reinterpret_cast<const float*>(&first_bits);
  224|      0|        const float second_value = *reinterpret_cast<const float*>(&second_bits);
  225|       |
  226|      0|        FloatRegister& first_reg = GetFloatRegister(id);
  227|      0|        FloatRegister& second_reg =
  228|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  229|       |
  230|      0|        first_reg.SetValue(first_value);
  231|      0|        second_reg.SetValue(second_value);
  232|      0|    }
  233|       |
  234|       |    StatusRegister& Processor::GetFPSR() noexcept
  235|      0|    {
  236|      0|        return m_FPSR;
  237|      0|    }
  238|       |
  239|       |    const StatusRegister& Processor::GetFPSR() const noexcept
  240|      0|    {
  241|      0|        return m_FPSR;
  242|      0|    }
  243|       |
  244|       |    phi::Boolean Processor::GetFPSRValue() const noexcept
  245|      0|    {
  246|      0|        const StatusRegister& status_reg = GetFPSR();
  247|       |
  248|      0|        return status_reg.Get();
  249|      0|    }
  250|       |
  251|       |    void Processor::SetFPSRValue(phi::Boolean value) noexcept
  252|      0|    {
  253|      0|        StatusRegister& status_reg = GetFPSR();
  254|       |
  255|      0|        status_reg.SetStatus(value);
  256|      0|    }
  257|       |
  258|       |    void Processor::ExecuteInstruction(const Instruction& inst) noexcept
  259|  50.1k|    {
  260|  50.1k|        m_CurrentInstructionAccessType = inst.GetInfo().GetRegisterAccessType();
  261|       |
  262|  50.1k|        inst.Execute(*this);
  263|  50.1k|    }
  264|       |
  265|       |    phi::Boolean Processor::LoadProgram(ParsedProgram& program) noexcept
  266|  1.00k|    {
  267|  1.00k|        if (!program.m_ParseErrors.empty())
  268|    881|        {
  269|    881|            PHI_LOG_WARN("Trying to load program with parsing errors");
  270|    881|            return false;
  271|    881|        }
  272|       |
  273|    124|        m_CurrentProgram = &program;
  274|       |
  275|    124|        m_ProgramCounter               = 0u;
  276|    124|        m_Halted                       = false;
  277|    124|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  278|    124|        m_LastRaisedException          = Exception::None;
  279|    124|        m_CurrentStepCount             = 0u;
  280|       |
  281|    124|        return true;
  282|  1.00k|    }
  283|       |
  284|       |    phi::ObserverPtr<ParsedProgram> Processor::GetCurrentProgramm() const noexcept
  285|  50.0k|    {
  286|  50.0k|        return m_CurrentProgram;
  287|  50.0k|    }
  288|       |
  289|       |    void Processor::ExecuteStep() noexcept
  290|  50.1k|    {
  291|       |        // No nothing when no program is loaded
  292|  50.1k|        if (!m_CurrentProgram)
  293|      0|        {
  294|      0|            return;
  295|      0|        }
  296|       |
  297|       |        // Halt if there are no instruction to execute
  298|  50.1k|        if (m_CurrentProgram->m_Instructions.empty())
  299|     17|        {
  300|     17|            m_Halted = true;
  301|     17|        }
  302|       |
  303|       |        // Do nothing when processor is halted
  304|  50.1k|        if (m_Halted)
  305|     17|        {
  306|     17|            return;
  307|     17|        }
  308|       |
  309|       |        // Increase Next program counter (may be later overwritten by branch instructions)
  310|  50.1k|        m_NextProgramCounter = m_ProgramCounter + 1u;
  311|       |
  312|       |        // Get current instruction pointed to by the program counter
  313|  50.1k|        const auto& current_instruction =
  314|  50.1k|                m_CurrentProgram->m_Instructions.at(m_ProgramCounter.get());
  315|       |
  316|       |        // Execute current instruction
  317|  50.1k|        ExecuteInstruction(current_instruction);
  318|       |
  319|  50.1k|        m_ProgramCounter = m_NextProgramCounter;
  320|       |
  321|  50.1k|        ++m_CurrentStepCount;
  322|       |
  323|  50.1k|        if ((m_MaxNumberOfSteps != 0u && m_CurrentStepCount >= m_MaxNumberOfSteps) ||
  324|  50.1k|            (m_ProgramCounter >= m_CurrentProgram->m_Instructions.size()))
  325|    107|        {
  326|    107|            m_Halted = true;
  327|    107|        }
  328|  50.1k|    }
  329|       |
  330|       |    void Processor::ExecuteCurrentProgram() noexcept
  331|    124|    {
  332|       |        // Do nothing when no program is loaded
  333|    124|        if (!m_CurrentProgram)
  334|      0|        {
  335|      0|            return;
  336|      0|        }
  337|       |
  338|    124|        m_ProgramCounter               = 0u;
  339|    124|        m_Halted                       = false;
  340|    124|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  341|    124|        m_LastRaisedException          = Exception::None;
  342|    124|        m_CurrentStepCount             = 0u;
  343|       |
  344|  50.2k|        while (!m_Halted)
  345|  50.1k|        {
  346|  50.1k|            ExecuteStep();
  347|  50.1k|        }
  348|    124|    }
  349|       |
  350|       |    void Processor::ClearRegisters() noexcept
  351|  1.00k|    {
  352|  1.00k|        for (auto& reg : m_IntRegisters)
  353|  32.1k|        {
  354|  32.1k|            reg.SetSignedValue(0);
  355|  32.1k|        }
  356|       |
  357|  1.00k|        for (auto& reg : m_FloatRegisters)
  358|  32.1k|        {
  359|  32.1k|            reg.SetValue(0.0f);
  360|  32.1k|        }
  361|       |
  362|  1.00k|        m_FPSR.SetStatus(false);
  363|  1.00k|    }
  364|       |
  365|       |    void Processor::ClearMemory() noexcept
  366|  1.00k|    {
  367|  1.00k|        m_MemoryBlock.Clear();
  368|  1.00k|    }
  369|       |
  370|       |    void Processor::Raise(Exception exception) noexcept
  371|     26|    {
  372|     26|        PHI_ASSERT(exception != Exception::None, "Cannot raise None exception");
  373|       |
  374|     26|        m_LastRaisedException = exception;
  375|       |
  376|     26|        switch (exception)
  377|     26|        {
  378|      0|            case Exception::None:
  379|      0|                PHI_ASSERT_NOT_REACHED();
  380|      0|                return;
  381|      4|            case Exception::DivideByZero:
  382|      4|                m_Halted = true;
  383|      4|                PHI_LOG_ERROR("Division through zero");
  384|      4|                return;
  385|      0|            case Exception::Overflow:
  386|      0|                PHI_LOG_WARN("Overflow");
  387|      0|                return;
  388|      2|            case Exception::Underflow:
  389|      2|                PHI_LOG_WARN("Underflow");
  390|      2|                return;
  391|      1|            case Exception::Trap:
  392|      1|                m_Halted = true;
  393|      1|                PHI_LOG_ERROR("Trapped");
  394|      1|                return;
  395|      1|            case Exception::Halt:
  396|      1|                m_Halted = true;
  397|      1|                return;
  398|      4|            case Exception::UnknownLabel:
  399|      4|                m_Halted = true;
  400|      4|                PHI_LOG_ERROR("Unknown label");
  401|      4|                return;
  402|      8|            case Exception::BadShift:
  403|      8|                PHI_LOG_ERROR("Bad shift");
  404|      8|                return;
  405|      6|            case Exception::AddressOutOfBounds:
  406|      6|                PHI_LOG_ERROR("Address out of bounds");
  407|      6|                m_Halted = true;
  408|      6|                return;
  409|      0|            case Exception::RegisterOutOfBounds:
  410|      0|                PHI_LOG_ERROR("Register out of bounds");
  411|      0|                m_Halted = true;
  412|      0|                return;
  413|     26|        }
  414|       |
  415|      0|        PHI_ASSERT_NOT_REACHED();
  416|      0|    }
  417|       |
  418|       |    Exception Processor::GetLastRaisedException() const noexcept
  419|      0|    {
  420|      0|        return m_LastRaisedException;
  421|      0|    }
  422|       |
  423|       |    phi::Boolean Processor::IsHalted() const noexcept
  424|      0|    {
  425|      0|        return m_Halted;
  426|      0|    }
  427|       |
  428|       |    const MemoryBlock& Processor::GetMemory() const noexcept
  429|      0|    {
  430|      0|        return m_MemoryBlock;
  431|      0|    }
  432|       |
  433|       |    MemoryBlock& Processor::GetMemory() noexcept
  434|     31|    {
  435|     31|        return m_MemoryBlock;
  436|     31|    }
  437|       |
  438|       |    phi::u32 Processor::GetProgramCounter() const noexcept
  439|      0|    {
  440|      0|        return m_ProgramCounter;
  441|      0|    }
  442|       |
  443|       |    void Processor::SetProgramCounter(phi::u32 new_pc) noexcept
  444|      0|    {
  445|      0|        m_ProgramCounter = new_pc;
  446|      0|    }
  447|       |
  448|       |    [[nodiscard]] phi::u32 Processor::GetNextProgramCounter() const noexcept
  449|  10.0k|    {
  450|  10.0k|        return m_NextProgramCounter;
  451|  10.0k|    }
  452|       |
  453|       |    void Processor::SetNextProgramCounter(phi::u32 new_npc) noexcept
  454|  50.0k|    {
  455|  50.0k|        m_NextProgramCounter = new_npc;
  456|  50.0k|    }
  457|       |
  458|       |    phi::usize Processor::GetCurrentStepCount() const noexcept
  459|      0|    {
  460|      0|        return m_CurrentStepCount;
  461|      0|    }
  462|       |
  463|       |    std::string Processor::GetRegisterDump() const noexcept
  464|      0|    {
  465|      0|        std::string text{"Int registers:\n"};
  466|       |
  467|      0|        for (phi::usize i{0u}; i < m_IntRegisters.size(); ++i)
  468|      0|        {
  469|      0|            const IntRegister reg = m_IntRegisters.at(i.get());
  470|      0|            text.append(
  471|      0|                    fmt::format("R{0}: sdec: {1:d}, udec: {2:d}, hex: 0x{2:08X}, bin: {2:#032b}\n",
  472|      0|                                i.get(), reg.GetSignedValue().get(), reg.GetUnsignedValue().get()));
  473|      0|        }
  474|       |
  475|      0|        text.append("\nFloat registers:\n");
  476|       |
  477|      0|        for (phi::usize i{0u}; i < m_FloatRegisters.size(); ++i)
  478|      0|        {
  479|      0|            const FloatRegister reg        = m_FloatRegisters.at(i.get());
  480|      0|            float               value      = reg.GetValue().get();
  481|      0|            std::uint32_t       value_uint = *reinterpret_cast<std::uint32_t*>(&value);
  482|      0|            text.append(fmt::format("F{0}: flt: {1:f}, hex: 0x{2:08X}, bin: {2:#032b}\n", i.get(),
  483|      0|                                    reg.GetValue().get(), value_uint));
  484|      0|        }
  485|       |
  486|      0|        text.append("\nStatus registers:\n");
  487|       |
  488|      0|        text.append(fmt::format("FPSR: {}", m_FPSR.Get() ? "Set" : "Not Set"));
  489|       |
  490|      0|        return text;
  491|      0|    }
  492|       |
  493|       |    std::string Processor::GetMemoryDump() const noexcept
  494|      0|    {
  495|      0|        std::string text{};
  496|       |
  497|       |        // TODO: Properly implement
  498|       |
  499|      0|        return text;
  500|      0|    }
  501|       |
  502|       |    std::string Processor::GetProcessorDump() const noexcept
  503|      0|    {
  504|      0|        std::string text;
  505|       |
  506|      0|        text.append(fmt::format("H: {:s}\n", m_Halted ? "True" : "False"));
  507|      0|        text.append(fmt::format("PC: {:d}, NPC: {:d}\n", m_ProgramCounter.get(),
  508|      0|                                m_NextProgramCounter.get()));
  509|       |
  510|      0|        if (m_CurrentProgram)
  511|      0|        {
  512|      0|            if (m_CurrentProgram->m_ParseErrors.empty() &&
  513|      0|                m_ProgramCounter.get() < m_CurrentProgram->m_Instructions.size())
  514|      0|            {
  515|      0|                Instruction instr = m_CurrentProgram->m_Instructions.at(m_ProgramCounter.get());
  516|      0|                text.append(fmt::format("INSTR:\n{}\n", instr.DebugInfo()));
  517|      0|            }
  518|      0|            else
  519|      0|            {
  520|      0|                text.append(fmt::format("INSTR:\nPC >= Instruction count ({:d}))\n",
  521|      0|                                        m_CurrentProgram->m_Instructions.size()));
  522|      0|            }
  523|      0|        }
  524|      0|        else
  525|      0|        {
  526|      0|            text.append("INSTR:\nNo program loaded\n");
  527|      0|        }
  528|       |
  529|      0|        text.append(fmt::format("EX: {}\n", magic_enum::enum_name(m_LastRaisedException)));
  530|      0|        text.append(fmt::format("IAT: {}", magic_enum::enum_name(m_CurrentInstructionAccessType)));
  531|       |
  532|      0|        return text;
  533|      0|    }
  534|       |
  535|       |    std::string Processor::GetCurrentProgrammDump() const noexcept
  536|      0|    {
  537|      0|        if (m_CurrentProgram)
  538|      0|        {
  539|      0|            return m_CurrentProgram->GetDump();
  540|      0|        }
  541|       |
  542|      0|        return "No Program";
  543|      0|    }
  544|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Parser.cpp:
    1|       |#include "DLX/Parser.hpp"
    2|       |
    3|       |#include "DLX/Instruction.hpp"
    4|       |#include "DLX/InstructionArg.hpp"
    5|       |#include "DLX/OpCode.hpp"
    6|       |#include "DLX/ParserUtils.hpp"
    7|       |#include "DLX/RegisterNames.hpp"
    8|       |#include "DLX/Token.hpp"
    9|       |#include <Phi/Config/FunctionLikeMacro.hpp>
   10|       |#include <Phi/Core/Assert.hpp>
   11|       |#include <Phi/Core/Boolean.hpp>
   12|       |#include <Phi/Core/Conversion.hpp>
   13|       |#include <Phi/Core/Log.hpp>
   14|       |#include <Phi/Core/Types.hpp>
   15|       |#include <magic_enum.hpp>
   16|       |#include <spdlog/fmt/bundled/core.h>
   17|       |#include <spdlog/fmt/bundled/format.h>
   18|       |#include <spdlog/fmt/fmt.h>
   19|       |#include <algorithm>
   20|       |#include <limits>
   21|       |#include <optional>
   22|       |#include <regex>
   23|       |#include <stdexcept>
   24|       |#include <string_view>
   25|       |
   26|       |using namespace phi::literals;
   27|       |
   28|       |namespace dlx
   29|       |{
   30|       |    Token ParseToken(std::string_view token, phi::u64 line_number, phi::u64 column) noexcept
   31|   175k|    {
   32|   175k|        if (token.at(0) == '#' && token.size() > 1)
   33|  2.19k|        {
   34|  2.19k|            auto number = ParseNumber(token.substr(1u));
   35|       |
   36|  2.19k|            if (number)
   37|     61|            {
   38|       |                //PHI_LOG_TRACE("Parsed number: {:d}", number.value().get());
   39|     61|                return Token(Token::Type::ImmediateInteger, token, line_number, column,
   40|     61|                             number.value().get());
   41|     61|            }
   42|       |
   43|  2.13k|            return Token(Token::Type::ImmediateInteger, token, line_number, column);
   44|  2.19k|        }
   45|       |
   46|   173k|        if (token.at(0) == '/' || token.at(0) == ';')
   47|  8.19k|        {
   48|  8.19k|            return Token(Token::Type::Comment, token, line_number, column);
   49|  8.19k|        }
   50|       |
   51|   165k|        if (auto number = ParseNumber(token); number.has_value())
   52|  1.66k|        {
   53|  1.66k|            return Token(Token::Type::IntegerLiteral, token, line_number, column, number->get());
   54|  1.66k|        }
   55|       |
   56|   163k|        std::string token_upper(token.data(), token.size());
   57|   163k|        std::transform(token_upper.begin(), token_upper.end(), token_upper.begin(), ::toupper);
   58|       |
   59|   163k|        if (token_upper == "FPSR")
   60|      0|        {
   61|      0|            return Token(Token::Type::RegisterStatus, token, line_number, column);
   62|      0|        }
   63|       |
   64|   163k|        if (IntRegisterID id = StringToIntRegister(token_upper); id != IntRegisterID::None)
   65|    648|        {
   66|    648|            return Token(Token::Type::RegisterInt, token, line_number, column,
   67|    648|                         static_cast<std::uint32_t>(id));
   68|    648|        }
   69|       |
   70|   163k|        if (FloatRegisterID id = StringToFloatRegister(token_upper); id != FloatRegisterID::None)
   71|     13|        {
   72|     13|            return Token(Token::Type::RegisterFloat, token, line_number, column,
   73|     13|                         static_cast<std::uint32_t>(id));
   74|     13|        }
   75|       |
   76|   163k|        if (OpCode opcode = StringToOpCode(token_upper); opcode != OpCode::NONE)
   77|  2.62k|        {
   78|  2.62k|            return Token(Token::Type::OpCode, token, line_number, column,
   79|  2.62k|                         static_cast<std::uint32_t>(opcode));
   80|  2.62k|        }
   81|       |
   82|   160k|        return Token(Token::Type::LabelIdentifier, token, line_number, column);
   83|   163k|    }
   84|       |
   85|       |    std::vector<Token> Parser::Tokenize(std::string_view source) noexcept
   86|  1.00k|    {
   87|  1.00k|        std::vector<Token> tokens{};
   88|  1.00k|        tokens.reserve(5);
   89|       |
   90|  1.00k|        std::string_view current_token;
   91|       |
   92|  1.00k|        phi::u64 current_line_number{1u};
   93|  1.00k|        phi::u64 current_column{1u};
   94|  1.00k|        phi::u64 token_begin{0u};
   95|       |
   96|  1.00k|        phi::Boolean parsing_comment{false};
   97|       |
   98|  7.74M|        for (phi::usize i{0u}; i < source.length(); ++i)
   99|  7.74M|        {
  100|  7.74M|            const char c{source.at(i.get())};
  101|       |
  102|  7.74M|            if (c == '\n')
  103|  40.7k|            {
  104|  40.7k|                if (current_token.empty())
  105|  4.26k|                {
  106|       |                    // Skip empty lines
  107|  4.26k|                    tokens.emplace_back(Token::Type::NewLine, source.substr(token_begin.get(), 1),
  108|  4.26k|                                        current_line_number, current_column - 1u);
  109|       |
  110|  4.26k|                    parsing_comment = false;
  111|  4.26k|                    current_line_number += 1u;
  112|  4.26k|                    current_column = 1u;
  113|  4.26k|                    continue;
  114|  4.26k|                }
  115|       |
  116|       |                // Otherwise a new line separates tokens
  117|  36.4k|                tokens.emplace_back(
  118|  36.4k|                        ParseToken(source.substr(token_begin.get(), current_token.length()),
  119|  36.4k|                                   current_line_number, current_column - current_token.length()));
  120|       |
  121|  36.4k|                token_begin = i;
  122|       |
  123|  36.4k|                tokens.emplace_back(Token::Type::NewLine, source.substr(token_begin.get(), 1),
  124|  36.4k|                                    current_line_number, current_column - 1u);
  125|       |
  126|  36.4k|                current_token   = std::string_view{};
  127|  36.4k|                parsing_comment = false;
  128|  36.4k|                current_line_number += 1u;
  129|  36.4k|                current_column = 0u;
  130|  36.4k|            }
  131|       |            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  132|  7.70M|            else if (c == '/' || c == ';')
  133|   261k|            {
  134|   261k|                if (current_token.empty())
  135|  8.19k|                {
  136|  8.19k|                    token_begin = i;
  137|  8.19k|                }
  138|       |
  139|   261k|                parsing_comment = true;
  140|   261k|                current_token   = std::string_view(
  141|   261k|                        source.substr(token_begin.get(), current_token.length() + 1));
  142|   261k|            }
  143|  7.44M|            else if (parsing_comment)
  144|  5.71M|            {
  145|       |                // simply append the character
  146|  5.71M|                current_token = std::string_view(
  147|  5.71M|                        source.substr(token_begin.get(), current_token.length() + 1));
  148|  5.71M|            }
  149|  1.72M|            else
  150|  1.72M|            {
  151|       |                // Not parsing a comment
  152|       |
  153|  1.72M|                switch (c)
  154|  1.72M|                {
  155|   530k|                    case ' ':
  156|   531k|                    case '\t':
  157|   531k|                    case '\v':
  158|   531k|                        if (current_token.empty())
  159|   444k|                        {
  160|   444k|                            current_column += 1u;
  161|       |                            // We haven't found any usable character for the current token so just skip the whitespace.
  162|   444k|                            continue;
  163|   444k|                        }
  164|       |
  165|       |                        // Otherwise a whitespace separates tokens
  166|  86.6k|                        tokens.emplace_back(ParseToken(
  167|  86.6k|                                source.substr(token_begin.get(), current_token.length()),
  168|  86.6k|                                current_line_number, current_column - current_token.length()));
  169|  86.6k|                        current_token = std::string_view{};
  170|  86.6k|                        break;
  171|  31.6k|                    case ':':
  172|       |                        // Need to parse label names together with their colon
  173|  31.6k|                        if (!current_token.empty())
  174|  20.4k|                        {
  175|  20.4k|                            current_token = std::string_view(
  176|  20.4k|                                    source.substr(token_begin.get(), current_token.length() + 1));
  177|  20.4k|                            tokens.emplace_back(ParseToken(
  178|  20.4k|                                    source.substr(token_begin.get(), current_token.length()),
  179|  20.4k|                                    current_line_number,
  180|  20.4k|                                    current_column + 1u - current_token.length()));
  181|       |
  182|  20.4k|                            current_token = std::string_view{};
  183|  20.4k|                        }
  184|  11.1k|                        else
  185|  11.1k|                        {
  186|       |                            // Orphan colon
  187|  11.1k|                            token_begin = i;
  188|       |
  189|  11.1k|                            tokens.emplace_back(Token::Type::Colon,
  190|  11.1k|                                                source.substr(token_begin.get(), 1),
  191|  11.1k|                                                current_line_number, current_column);
  192|  11.1k|                        }
  193|  31.6k|                        break;
  194|  10.6k|                    case ',':
  195|  25.8k|                    case '(':
  196|  41.4k|                    case ')':
  197|  41.4k|                        if (!current_token.empty())
  198|  31.3k|                        {
  199|  31.3k|                            tokens.emplace_back(ParseToken(
  200|  31.3k|                                    source.substr(token_begin.get(), current_token.length()),
  201|  31.3k|                                    current_line_number, current_column - current_token.length()));
  202|       |
  203|  31.3k|                            current_token = std::string_view{};
  204|  31.3k|                        }
  205|       |
  206|  41.4k|                        Token::Type type;
  207|  41.4k|                        switch (c)
  208|  41.4k|                        {
  209|  10.6k|                            case ',':
  210|  10.6k|                                type = Token::Type::Comma;
  211|  10.6k|                                break;
  212|  15.1k|                            case '(':
  213|  15.1k|                                type = Token::Type::OpenBracket;
  214|  15.1k|                                break;
  215|  15.6k|                            case ')':
  216|  15.6k|                                type = Token::Type::ClosingBracket;
  217|  15.6k|                                break;
  218|      0|                            default:
  219|      0|                                PHI_ASSERT_NOT_REACHED();
  220|      0|                                break;
  221|  41.4k|                        }
  222|       |
  223|  41.4k|                        token_begin = i;
  224|       |
  225|  41.4k|                        tokens.emplace_back(type, source.substr(token_begin.get(), 1),
  226|  41.4k|                                            current_line_number, current_column);
  227|  41.4k|                        break;
  228|       |
  229|  1.11M|                    default:
  230|  1.11M|                        if (current_token.empty())
  231|   167k|                        {
  232|   167k|                            token_begin = i;
  233|   167k|                        }
  234|       |
  235|       |                        // simply append the character
  236|  1.11M|                        current_token = std::string_view(
  237|  1.11M|                                source.substr(token_begin.get(), current_token.length() + 1));
  238|  1.72M|                }
  239|  1.72M|            }
  240|       |
  241|  7.29M|            current_column += 1u;
  242|  7.29M|        }
  243|       |
  244|       |        // Checked the entire string. Parse whats left if anything
  245|  1.00k|        if (!current_token.empty())
  246|    793|        {
  247|    793|            tokens.emplace_back(ParseToken(source.substr(token_begin.get(), current_token.length()),
  248|    793|                                           current_line_number,
  249|    793|                                           current_column - current_token.length()));
  250|    793|        }
  251|       |
  252|  1.00k|        return tokens;
  253|  1.00k|    }
  254|       |
  255|       |    static phi::Boolean has_x_more_tokens(const std::vector<Token>& tokens, phi::usize index,
  256|       |                                          phi::u64 x) noexcept
  257|  3.77k|    {
  258|  3.77k|        return index + x <= tokens.size();
  259|  3.77k|    }
  260|       |
  261|       |    static phi::Boolean has_one_more_token(const std::vector<Token>& tokens,
  262|       |                                           phi::usize                index) noexcept
  263|  3.76k|    {
  264|  3.76k|        return has_x_more_tokens(tokens, index, 1u);
  265|  3.76k|    }
  266|       |
  267|       |    static phi::Boolean next_token_is(const std::vector<Token>& tokens, phi::usize index,
  268|       |                                      Token::Type token_type) noexcept
  269|      0|    {
  270|      0|        PHI_ASSERT(has_one_more_token(tokens, index));
  271|      0|
  272|      0|        const auto& next_token = tokens.at((index + 1u).get());
  273|      0|
  274|      0|        return next_token.GetType() == token_type;
  275|      0|    }
  276|       |
  277|       |    static phi::Boolean has_one_more_token_of_type(const std::vector<Token>& tokens,
  278|       |                                                   phi::usize                index,
  279|       |                                                   Token::Type               token_type) noexcept
  280|      0|    {
  281|      0|        if (!has_one_more_token(tokens, index))
  282|      0|        {
  283|      0|            return false;
  284|      0|        }
  285|      0|
  286|      0|        return (next_token_is(tokens, index, token_type));
  287|      0|    }
  288|       |
  289|       |    static const Token* find_first_token_of_type(const std::vector<Token>& tokens,
  290|       |                                                 const Token::Type         type) noexcept
  291|      0|    {
  292|      0|        for (const Token& token : tokens)
  293|      0|        {
  294|      0|            if (token.GetType() == type)
  295|      0|            {
  296|      0|                return &token;
  297|      0|            }
  298|      0|        }
  299|      0|
  300|      0|        return nullptr;
  301|      0|    }
  302|       |
  303|       |    static const Token* find_last_token_of_type(const std::vector<Token>& tokens,
  304|       |                                                const Token::Type         type) noexcept
  305|    178|    {
  306|    211|        for (auto it = tokens.rbegin(); it != tokens.rend(); ++it)
  307|    211|        {
  308|    211|            if (it->GetType() == type)
  309|    178|            {
  310|    178|                return &(*it);
  311|    178|            }
  312|    211|        }
  313|       |
  314|      0|        return nullptr;
  315|    178|    }
  316|       |
  317|       |    static void AddParseError(ParsedProgram& program, const Token& current_token,
  318|       |                              const std::string& message) noexcept
  319|   215k|    {
  320|   215k|        ParseError err;
  321|   215k|        err.line_number = current_token.GetLineNumber().get();
  322|   215k|        err.column      = current_token.GetColumn().get();
  323|   215k|        err.message     = message;
  324|       |
  325|       |        //PHI_LOG_ERROR("Parsing error: {}", message);
  326|       |
  327|   215k|        program.m_ParseErrors.emplace_back(err);
  328|   215k|    }
  329|       |
  330|       |    static std::optional<InstructionArg> parse_instruction_argument(
  331|       |            const Token& token, ArgumentType expected_argument_type,
  332|       |            const std::vector<Token>& tokens, phi::usize& index, ParsedProgram& program) noexcept
  333|  3.06k|    {
  334|       |        // PHI_LOG_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
  335|       |        //              magic_enum::enum_name(expected_argument_type));
  336|       |
  337|  3.06k|        switch (token.GetType())
  338|  3.06k|        {
  339|     18|            case Token::Type::IntegerLiteral: {
  340|     18|                if (!ArgumentTypeIncludes(expected_argument_type,
  341|     18|                                          ArgumentType::AddressDisplacement))
  342|      1|                {
  343|      1|                    AddParseError(program, token,
  344|      1|                                  fmt::format("Expected {} but got address displacement",
  345|      1|                                              magic_enum::enum_name(expected_argument_type)));
  346|      1|                    return {};
  347|      1|                }
  348|       |
  349|       |                // Parse address displacement
  350|     17|                auto displacement_value = ParseNumber(token.GetText());
  351|     17|                if (!displacement_value)
  352|      0|                {
  353|      0|                    AddParseError(program, token,
  354|      0|                                  "Failed to parse displacement value for Address displacement");
  355|      0|                    return {};
  356|      0|                }
  357|     17|                std::int16_t value = displacement_value.value().get();
  358|       |
  359|     17|                if (!has_x_more_tokens(tokens, index, 3u))
  360|      2|                {
  361|      2|                    AddParseError(program, token,
  362|      2|                                  "Not enough arguments left to parse address displacement");
  363|      2|                    return {};
  364|      2|                }
  365|       |
  366|     15|                const Token& first_token  = tokens.at(index.get());
  367|     15|                const Token& second_token = tokens.at((index + 1u).get());
  368|     15|                const Token& third_token  = tokens.at((index + 2u).get());
  369|       |
  370|     15|                if (first_token.GetType() != Token::Type::OpenBracket)
  371|      0|                {
  372|      0|                    AddParseError(program, token,
  373|      0|                                  fmt::format("Expected open bracket but got {:s}",
  374|      0|                                              magic_enum::enum_name(first_token.GetType())));
  375|      0|                    return {};
  376|      0|                }
  377|       |
  378|       |                // Second token is the register
  379|     15|                if (second_token.GetType() != Token::Type::RegisterInt)
  380|      0|                {
  381|      0|                    AddParseError(program, token,
  382|      0|                                  fmt::format("Expected IntRegister but got {:s}",
  383|      0|                                              magic_enum::enum_name(second_token.GetType())));
  384|      0|                    return {};
  385|      0|                }
  386|       |
  387|     15|                if (third_token.GetType() != Token::Type::ClosingBracket)
  388|      0|                {
  389|      0|                    AddParseError(program, token,
  390|      0|                                  fmt::format("Expected closing bracket but got {:s}",
  391|      0|                                              magic_enum::enum_name(third_token.GetType())));
  392|      0|                    return {};
  393|      0|                }
  394|       |
  395|     15|                index += 3u;
  396|       |
  397|       |                //PHI_LOG_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
  398|       |                //             value, magic_enum::enum_name(reg_id));
  399|       |
  400|     15|                return ConstructInstructionArgAddressDisplacement(
  401|     15|                        static_cast<IntRegisterID>(second_token.GetHint()), value);
  402|     15|            }
  403|    608|            case Token::Type::RegisterInt: {
  404|    608|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  405|      0|                {
  406|      0|                    AddParseError(program, token,
  407|      0|                                  fmt::format("Got IntRegister but expected '{}'",
  408|      0|                                              magic_enum::enum_name(expected_argument_type)));
  409|      0|                    return {};
  410|      0|                }
  411|       |
  412|       |                //PHI_LOG_INFO("Parsed identifier as int register {}",
  413|       |                //             magic_enum::enum_name(reg_id));
  414|       |
  415|    608|                return ConstructInstructionArgRegisterInt(
  416|    608|                        static_cast<IntRegisterID>(token.GetHint()));
  417|    608|            }
  418|      0|            case Token::Type::RegisterFloat: {
  419|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  420|      0|                {
  421|      0|                    AddParseError(program, token,
  422|      0|                                  fmt::format("Got FloatRegister but expected '{}'",
  423|      0|                                              magic_enum::enum_name(expected_argument_type)));
  424|      0|                    return {};
  425|      0|                }
  426|       |
  427|       |                //PHI_LOG_INFO("Parsed identifier as float register {}",
  428|       |                //             magic_enum::enum_name(float_reg_id));
  429|       |
  430|      0|                return ConstructInstructionArgRegisterFloat(
  431|      0|                        static_cast<FloatRegisterID>(token.GetHint()));
  432|      0|            }
  433|      0|            case Token::Type::RegisterStatus: {
  434|      0|            }
  435|    878|            case Token::Type::LabelIdentifier: {
  436|       |                // Parse as Label
  437|    878|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  438|    804|                {
  439|    804|                    AddParseError(program, token,
  440|    804|                                  fmt::format("Got Label but expected '{}'",
  441|    804|                                              magic_enum::enum_name(expected_argument_type)));
  442|    804|                    return {};
  443|    804|                }
  444|       |
  445|     74|                if (IsReservedIdentifier(token.GetText()))
  446|      0|                {
  447|      0|                    AddParseError(
  448|      0|                            program, token,
  449|      0|                            fmt::format("Cannot used reserved identifier {}", token.GetText()));
  450|      0|                    return {};
  451|      0|                }
  452|       |
  453|     74|                if (!IsValidIdentifier(token.GetText()))
  454|     48|                {
  455|     48|                    AddParseError(
  456|     48|                            program, token,
  457|     48|                            fmt::format("Invalid label identifier found {}", token.GetText()));
  458|     48|                    return {};
  459|     48|                }
  460|       |
  461|       |                //PHI_LOG_INFO("Parsed Label identifier as '{}'", token.GetText());
  462|       |
  463|     26|                return ConstructInstructionArgLabel(token.GetText());
  464|     74|            }
  465|    263|            case Token::Type::ImmediateInteger: {
  466|    263|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  467|      2|                {
  468|      2|                    AddParseError(program, token,
  469|      2|                                  fmt::format("Got ImmediateInteger but expected '{}'",
  470|      2|                                              magic_enum::enum_name(expected_argument_type)));
  471|      2|                    return {};
  472|      2|                }
  473|       |
  474|    261|                if (token.HasHint())
  475|     59|                {
  476|     59|                    return ConstructInstructionArgImmediateValue(
  477|     59|                            static_cast<std::int16_t>(token.GetHint()));
  478|     59|                }
  479|       |
  480|    202|                auto parsed_value = ParseNumber(token.GetText().substr(1));
  481|    202|                if (!parsed_value)
  482|    202|                {
  483|    202|                    AddParseError(program, token, "Failed to parse immediate Integer value");
  484|    202|                    return {};
  485|    202|                }
  486|       |
  487|       |                //PHI_LOG_INFO("Parsed Immediate Integer with value {}", parsed_value.value().get());
  488|       |
  489|      0|                return ConstructInstructionArgImmediateValue(parsed_value.value().get());
  490|    202|            }
  491|  1.30k|            default:
  492|  1.30k|                AddParseError(program, token,
  493|  1.30k|                              fmt::format("Unexpected token of type '{}'", token.GetTypeName()));
  494|  1.30k|                return {};
  495|  3.06k|        }
  496|  3.06k|    }
  497|       |
  498|       |    static void consume_x_tokens(phi::usize& index, phi::usize x) noexcept
  499|   269k|    {
  500|   269k|        index += x;
  501|   269k|    }
  502|       |
  503|       |    static void consume_current_token(phi::usize& index) noexcept
  504|   269k|    {
  505|   269k|        consume_x_tokens(index, 1u);
  506|   269k|    }
  507|       |
  508|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::vector<Token>& tokens) noexcept
  509|  1.00k|    {
  510|  1.00k|        ParsedProgram program;
  511|       |
  512|  1.00k|        program.m_Tokens = tokens;
  513|       |
  514|  1.00k|        phi::Boolean line_has_instruction{false};
  515|  1.00k|        phi::Boolean last_line_was_label{false};
  516|       |
  517|   266k|        for (phi::usize index{0u}; index < tokens.size();)
  518|   265k|        {
  519|   265k|            Token& current_token = tokens.at(index.get());
  520|       |
  521|   265k|            consume_current_token(index);
  522|       |
  523|       |            //PHI_LOG_INFO("Parsing '{}'", current_token.DebugInfo());
  524|       |
  525|   265k|            switch (current_token.GetType())
  526|   265k|            {
  527|       |                // Ignore comments
  528|  8.19k|                case Token::Type::Comment:
  529|       |                    //PHI_LOG_DEBUG("Ignoring comment");
  530|  8.19k|                    break;
  531|  40.6k|                case Token::Type::NewLine:
  532|       |                    //PHI_LOG_DEBUG("Ignoring newline");
  533|  40.6k|                    line_has_instruction = false;
  534|  40.6k|                    break;
  535|   159k|                case Token::Type::LabelIdentifier: {
  536|   159k|                    if (line_has_instruction)
  537|      0|                    {
  538|      0|                        AddParseError(program, current_token,
  539|      0|                                      "Expected new line but got label identifer");
  540|      0|                        break;
  541|      0|                    }
  542|       |
  543|       |                    // Handle jump labels
  544|       |                    // Check if the last character of the identifier is a colon
  545|   159k|                    if (current_token.GetText().at(current_token.GetText().size() - 1) != ':')
  546|   139k|                    {
  547|   139k|                        AddParseError(program, current_token,
  548|   139k|                                      "Label identifier is missing a colon");
  549|   139k|                        break;
  550|   139k|                    }
  551|       |
  552|  19.9k|                    std::string_view label_name = current_token.GetText();
  553|  19.9k|                    label_name.remove_suffix(1);
  554|       |
  555|  19.9k|                    if (IsReservedIdentifier(label_name))
  556|     17|                    {
  557|     17|                        AddParseError(program, current_token,
  558|     17|                                      fmt::format("Cannot use reserved identifier {} as jump label",
  559|     17|                                                  label_name));
  560|     17|                        break;
  561|     17|                    }
  562|       |
  563|       |                    // Check if label was already defined
  564|  19.9k|                    if (program.m_JumpData.find(label_name) != program.m_JumpData.end())
  565|  17.0k|                    {
  566|       |                        // Find first defintions of label
  567|  17.0k|                        const Token* first_label_definition = nullptr;
  568|  17.0k|                        for (const Token& token : tokens)
  569|  20.8M|                        {
  570|  20.8M|                            if (token.GetType() == Token::Type::LabelIdentifier)
  571|  12.0M|                            {
  572|  12.0M|                                std::string_view token_label_name = token.GetText();
  573|  12.0M|                                token_label_name.remove_suffix(1);
  574|       |
  575|  12.0M|                                if (token_label_name == label_name)
  576|  17.0k|                                {
  577|  17.0k|                                    first_label_definition = &token;
  578|  17.0k|                                    break;
  579|  17.0k|                                }
  580|  12.0M|                            }
  581|  20.8M|                        }
  582|       |
  583|  17.0k|                        PHI_ASSERT(first_label_definition);
  584|       |
  585|  17.0k|                        AddParseError(program, current_token,
  586|  17.0k|                                      fmt::format("Label '{:s}' already defined at line {:d}",
  587|  17.0k|                                                  label_name,
  588|  17.0k|                                                  first_label_definition->GetLineNumber().get()));
  589|  17.0k|                        break;
  590|  17.0k|                    }
  591|       |
  592|  2.87k|                    program.m_JumpData[label_name] =
  593|  2.87k|                            static_cast<std::uint32_t>(program.m_Instructions.size());
  594|  2.87k|                    last_line_was_label = true;
  595|       |
  596|       |                    //PHI_LOG_INFO("Added jump label {} -> {}", label_name,
  597|       |                    //             program.m_Instructions.size());
  598|       |
  599|  2.87k|                    break;
  600|  19.9k|                }
  601|  2.62k|                case Token::Type::OpCode: {
  602|  2.62k|                    if (line_has_instruction)
  603|      0|                    {
  604|      0|                        AddParseError(program, current_token,
  605|      0|                                      "You may only place one instruction per line");
  606|      0|                        break;
  607|      0|                    }
  608|       |
  609|  2.62k|                    last_line_was_label = false;
  610|       |
  611|       |                    // Handle normal instructions
  612|  2.62k|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  613|       |
  614|       |                    //PHI_LOG_INFO("Instruction opcode: {}", magic_enum::enum_name(opcode));
  615|       |
  616|  2.62k|                    const InstructionInfo& info = lib.LookUp(opcode);
  617|       |
  618|       |                    // Make sure we got no problems here
  619|  2.62k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  620|  2.62k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  621|  2.62k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  622|  2.62k|                    PHI_ASSERT(info.GetExecutor());
  623|       |
  624|  2.62k|                    phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  625|       |                    //PHI_LOG_INFO("Instruction requires {} arguments",
  626|       |                    //             number_of_argument_required.get());
  627|       |
  628|       |                    // Create instruction
  629|  2.62k|                    Instruction instruction(info);
  630|       |
  631|       |                    // Parse arguments
  632|  3.95k|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  633|  3.76k|                    {
  634|       |                        // Get next token
  635|  3.76k|                        if (!has_one_more_token(tokens, index))
  636|     12|                        {
  637|     12|                            AddParseError(
  638|     12|                                    program, current_token,
  639|     12|                                    fmt::format("Missing {} arguments for instruction {}",
  640|     12|                                                (number_of_argument_required - argument_num).get(),
  641|     12|                                                magic_enum::enum_name(opcode)));
  642|     12|                            break;
  643|     12|                        }
  644|       |
  645|  3.75k|                        current_token = tokens.at(index.get());
  646|  3.75k|                        consume_current_token(index);
  647|       |
  648|       |                        // Skip commas
  649|  3.75k|                        if (current_token.GetType() == Token::Type::Comma)
  650|    620|                        {
  651|       |                            //PHI_LOG_DEBUG("Skipping comma");
  652|    620|                            continue;
  653|    620|                        }
  654|       |
  655|  3.13k|                        if (current_token.GetType() == Token::Type::NewLine)
  656|     63|                        {
  657|     63|                            phi::u8 missing_arguments = number_of_argument_required - argument_num;
  658|     63|                            AddParseError(program, current_token,
  659|     63|                                          fmt::format("Unexpected end of line. Instruction {:s} "
  660|     63|                                                      "requires {:d} arguments, but only {:d} were "
  661|     63|                                                      "provided. Missing {:d} argument(s)",
  662|     63|                                                      magic_enum::enum_name(opcode),
  663|     63|                                                      number_of_argument_required.get(),
  664|     63|                                                      argument_num.get(), missing_arguments.get()));
  665|     63|                            break;
  666|     63|                        }
  667|       |
  668|  3.06k|                        std::optional<InstructionArg> optional_parsed_argument =
  669|  3.06k|                                parse_instruction_argument(current_token,
  670|  3.06k|                                                           info.GetArgumentType(argument_num),
  671|  3.06k|                                                           tokens, index, program);
  672|  3.06k|                        if (!optional_parsed_argument.has_value())
  673|  2.35k|                        {
  674|  2.35k|                            AddParseError(program, current_token,
  675|  2.35k|                                          fmt::format("Failed to parse argument number {:d} of "
  676|  2.35k|                                                      "{:s} instruction",
  677|  2.35k|                                                      argument_num.get(),
  678|  2.35k|                                                      magic_enum::enum_name(opcode)));
  679|  2.35k|                            break;
  680|  2.35k|                        }
  681|       |
  682|       |                        // Successfully parsed one argument
  683|    708|                        InstructionArg parsed_argument = optional_parsed_argument.value();
  684|       |
  685|    708|                        instruction.SetArgument(argument_num, parsed_argument);
  686|    708|                        argument_num++;
  687|       |
  688|       |                        //PHI_LOG_INFO("Successfully parsed argument {}", argument_num.get());
  689|    708|                    }
  690|       |
  691|       |                    // Only add the instruction if we got no parsing errors
  692|  2.62k|                    if (program.m_ParseErrors.empty())
  693|    134|                    {
  694|       |                        //PHI_LOG_INFO("Successfully parsed instruction '{}'",
  695|       |                        //            instruction.DebugInfo());
  696|    134|                        program.m_Instructions.emplace_back(instruction);
  697|    134|                        line_has_instruction = true;
  698|    134|                    }
  699|  2.62k|                    break;
  700|  2.62k|                }
  701|       |
  702|  54.2k|                default:
  703|  54.2k|                    AddParseError(program, current_token,
  704|  54.2k|                                  fmt::format("Unexpected token of type {:s}",
  705|  54.2k|                                              magic_enum::enum_name(current_token.GetType())));
  706|  54.2k|                    break;
  707|   265k|            }
  708|   265k|        }
  709|       |
  710|  1.00k|        if (last_line_was_label)
  711|    178|        {
  712|    178|            const Token* optional_token =
  713|    178|                    find_last_token_of_type(tokens, Token::Type::LabelIdentifier);
  714|    178|            PHI_ASSERT(optional_token);
  715|       |
  716|    178|            const std::string_view label_text = optional_token->GetText();
  717|    178|            const std::string_view label_name = label_text.substr(0, label_text.size() - 1);
  718|       |
  719|    178|            AddParseError(program, *optional_token,
  720|    178|                          fmt::format("Label '{:s}' does not have any instructions", label_name));
  721|    178|        }
  722|       |
  723|  1.00k|        return program;
  724|  1.00k|    }
  725|       |
  726|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::string_view source) noexcept
  727|  1.00k|    {
  728|  1.00k|        std::vector<Token> tokens = Tokenize(source);
  729|  1.00k|        return Parse(lib, tokens);
  730|  1.00k|    }
  731|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionInfo.cpp:
    1|       |#include "DLX/InstructionInfo.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void InstructionInfo::Execute(Processor& processor, const InstructionArg& arg1,
    6|       |                                  const InstructionArg& arg2,
    7|       |                                  const InstructionArg& arg3) const noexcept
    8|  50.1k|    {
    9|  50.1k|        PHI_ASSERT(m_Executor, "No execution function defined");
   10|       |
   11|  50.1k|        m_Executor(processor, arg1, arg2, arg3);
   12|  50.1k|    }
   13|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionImplementation.cpp:
    1|       |#include "DLX/InstructionImplementation.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionInfo.hpp"
    5|       |#include "DLX/Parser.hpp"
    6|       |#include "DLX/Processor.hpp"
    7|       |#include "DLX/RegisterNames.hpp"
    8|       |#include "Phi/Core/Assert.hpp"
    9|       |#include "Phi/Core/Boolean.hpp"
   10|       |#include "Phi/Core/Types.hpp"
   11|       |#include <string_view>
   12|       |
   13|       |namespace dlx
   14|       |{
   15|       |    static std::int32_t clear_top_n_bits(std::int32_t value, std::int32_t n) noexcept
   16|      1|    {
   17|      1|        PHI_ASSERT(n > 0 && n < 32, "Would invoke undefined behaviour");
   18|       |
   19|      1|        return value & ~(-1 << (32 - n));
   20|      1|    }
   21|       |
   22|       |    static void JumpToLabel(Processor& processor, std::string_view label_name) noexcept
   23|  10.0k|    {
   24|       |        // Lookup the label
   25|  10.0k|        const phi::ObserverPtr<ParsedProgram> program = processor.GetCurrentProgramm();
   26|  10.0k|        PHI_ASSERT(program);
   27|  10.0k|        PHI_ASSERT(!label_name.empty(), "Can't jump to empty label");
   28|       |
   29|  10.0k|        if (program->m_JumpData.find(label_name) == program->m_JumpData.end())
   30|      4|        {
   31|      4|            PHI_LOG_ERROR("Unable to find jump label {}", label_name);
   32|      4|            processor.Raise(Exception::UnknownLabel);
   33|      4|            return;
   34|      4|        }
   35|       |
   36|  10.0k|        const std::uint32_t jump_point = program->m_JumpData.at(label_name);
   37|  10.0k|        PHI_ASSERT(jump_point < program->m_Instructions.size(), "Jump point out of bounds");
   38|       |
   39|       |        // Set program counter
   40|  10.0k|        processor.SetNextProgramCounter(jump_point);
   41|  10.0k|    }
   42|       |
   43|       |    static void JumpToRegister(Processor& processor, IntRegisterID reg_id) noexcept
   44|  40.0k|    {
   45|  40.0k|        phi::u32 address = processor.IntRegisterGetUnsignedValue(reg_id);
   46|       |
   47|  40.0k|        phi::u32 max_address =
   48|  40.0k|                static_cast<std::uint32_t>(processor.GetCurrentProgramm()->m_Instructions.size());
   49|  40.0k|        if (address >= max_address)
   50|      0|        {
   51|      0|            processor.Raise(Exception::AddressOutOfBounds);
   52|      0|            return;
   53|      0|        }
   54|       |
   55|  40.0k|        processor.SetNextProgramCounter(address.get());
   56|  40.0k|    }
   57|       |
   58|       |    static std::optional<phi::i32> CalculateDisplacementAddress(
   59|       |            Processor&                                 processor,
   60|       |            const InstructionArg::AddressDisplacement& adr_displacement) noexcept
   61|     15|    {
   62|     15|        phi::i32 register_value = processor.IntRegisterGetSignedValue(adr_displacement.register_id);
   63|       |
   64|     15|        phi::i32 address = adr_displacement.displacement + register_value;
   65|       |
   66|     15|        if (address < 0)
   67|      0|        {
   68|      0|            processor.Raise(Exception::AddressOutOfBounds);
   69|      0|            return {};
   70|      0|        }
   71|       |
   72|     15|        return address;
   73|     15|    }
   74|       |
   75|       |    static std::optional<phi::i32> GetLoadStoreAddress(Processor&           processor,
   76|       |                                                       const InstructionArg argument) noexcept
   77|     33|    {
   78|     33|        if (argument.GetType() == ArgumentType::ImmediateInteger)
   79|     18|        {
   80|     18|            const auto& imm_value = argument.AsImmediateValue();
   81|       |
   82|     18|            if (imm_value.signed_value < 0)
   83|      2|            {
   84|      2|                return {};
   85|      2|            }
   86|       |
   87|     16|            return imm_value.signed_value;
   88|     18|        }
   89|       |
   90|     15|        if (argument.GetType() == ArgumentType::AddressDisplacement)
   91|     15|        {
   92|     15|            const auto& adr_displacement = argument.AsAddressDisplacement();
   93|     15|            return CalculateDisplacementAddress(processor, adr_displacement);
   94|     15|        }
   95|       |
   96|      0|        PHI_ASSERT_NOT_REACHED();
   97|      0|    }
   98|       |
   99|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg,
  100|       |                                 phi::i64 value) noexcept
  101|      9|    {
  102|      9|        constexpr phi::i64 min = phi::i32::limits_type::min();
  103|      9|        constexpr phi::i64 max = phi::i32::limits_type::max();
  104|       |
  105|       |        // Check for underflow
  106|      9|        if (value < min)
  107|      0|        {
  108|      0|            processor.Raise(Exception::Underflow);
  109|       |
  110|      0|            value = max + (value % (min - 1));
  111|      0|        }
  112|       |        // Check for overflow
  113|      9|        else if (value > max)
  114|      0|        {
  115|      0|            processor.Raise(Exception::Overflow);
  116|       |
  117|      0|            value = min + (value % (max + 1));
  118|      0|        }
  119|       |
  120|      9|        PHI_ASSERT(value >= min);
  121|      9|        PHI_ASSERT(value <= max);
  122|       |
  123|      9|        processor.IntRegisterSetSignedValue(dest_reg, static_cast<std::int32_t>(value.get()));
  124|      9|    }
  125|       |
  126|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg,
  127|       |                                 phi::u64 value) noexcept
  128|      9|    {
  129|      9|        constexpr phi::u64 min = phi::u32::limits_type::min();
  130|      9|        constexpr phi::u64 max = phi::u32::limits_type::max();
  131|       |
  132|       |        // Check for overflow
  133|      9|        if (value > max)
  134|      0|        {
  135|      0|            processor.Raise(Exception::Overflow);
  136|       |
  137|      0|            value %= max + 1u;
  138|      0|        }
  139|       |
  140|      9|        PHI_ASSERT(value <= max);
  141|       |
  142|      9|        processor.IntRegisterSetUnsignedValue(dest_reg, static_cast<std::uint32_t>(value.get()));
  143|      9|    }
  144|       |
  145|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  146|       |                         phi::i32 rhs) noexcept
  147|      4|    {
  148|      4|        phi::i64 res = phi::i64(lhs) + rhs;
  149|       |
  150|      4|        SafeWriteInteger(processor, dest_reg, res);
  151|      4|    }
  152|       |
  153|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  154|       |                         phi::u32 rhs) noexcept
  155|      3|    {
  156|      3|        phi::u64 res = phi::u64(lhs) + rhs;
  157|       |
  158|      3|        SafeWriteInteger(processor, dest_reg, res);
  159|      3|    }
  160|       |
  161|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  162|       |                            phi::i32 rhs) noexcept
  163|      2|    {
  164|      2|        phi::i64 res = phi::i64(lhs) - rhs;
  165|       |
  166|      2|        SafeWriteInteger(processor, dest_reg, res);
  167|      2|    }
  168|       |
  169|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  170|       |                            phi::u32 rhs) noexcept
  171|      3|    {
  172|      3|        constexpr phi::u32 max = phi::u32::limits_type::max();
  173|       |
  174|      3|        if (lhs < rhs)
  175|      2|        {
  176|      2|            processor.Raise(Exception::Underflow);
  177|       |
  178|      2|            phi::u64 res = max - rhs + lhs + 1u;
  179|      2|            SafeWriteInteger(processor, dest_reg, res);
  180|      2|            return;
  181|      2|        }
  182|       |
  183|      1|        phi::u64 res = phi::u64(lhs) - rhs;
  184|       |
  185|      1|        SafeWriteInteger(processor, dest_reg, res);
  186|      1|    }
  187|       |
  188|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  189|       |                               phi::i32 rhs) noexcept
  190|      2|    {
  191|      2|        phi::i64 res = phi::i64(lhs) * rhs;
  192|       |
  193|      2|        SafeWriteInteger(processor, dest_reg, res);
  194|      2|    }
  195|       |
  196|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  197|       |                               phi::u32 rhs) noexcept
  198|      2|    {
  199|      2|        phi::u64 res = phi::u64(lhs) * rhs;
  200|       |
  201|      2|        SafeWriteInteger(processor, dest_reg, res);
  202|      2|    }
  203|       |
  204|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  205|       |                         phi::i32 rhs) noexcept
  206|      3|    {
  207|      3|        if (rhs == 0)
  208|      2|        {
  209|      2|            processor.Raise(Exception::DivideByZero);
  210|      2|            return;
  211|      2|        }
  212|       |
  213|      1|        phi::i64 res = phi::i64(lhs) / rhs;
  214|       |
  215|      1|        SafeWriteInteger(processor, dest_reg, res);
  216|      1|    }
  217|       |
  218|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  219|       |                         phi::u32 rhs) noexcept
  220|      3|    {
  221|      3|        if (rhs == 0u)
  222|      2|        {
  223|      2|            processor.Raise(Exception::DivideByZero);
  224|      2|            return;
  225|      2|        }
  226|       |
  227|      1|        phi::u64 res = phi::u64(lhs) / rhs;
  228|       |
  229|      1|        SafeWriteInteger(processor, dest_reg, res);
  230|      1|    }
  231|       |
  232|       |    static void ShiftRightLogical(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  233|       |                                  phi::i32 shift) noexcept
  234|      4|    {
  235|       |        // Prevent undefined behavior by shifting by more than 31
  236|      4|        if (shift > 31)
  237|      1|        {
  238|      1|            processor.Raise(Exception::BadShift);
  239|       |
  240|       |            // Just set register to 0
  241|      1|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  242|      1|            return;
  243|      1|        }
  244|       |
  245|       |        // Do nothing when shifting by zero to prevent undefined behavior
  246|      3|        if (shift == 0)
  247|      1|        {
  248|      1|            processor.IntRegisterSetSignedValue(dest_reg, base);
  249|      1|            return;
  250|      1|        }
  251|       |
  252|       |        // Negative shifts are undefiend behaviour
  253|      2|        if (shift < 0)
  254|      1|        {
  255|      1|            processor.Raise(Exception::BadShift);
  256|      1|            return;
  257|      1|        }
  258|       |
  259|      1|        phi::i32 new_value = base.get() >> shift.get();
  260|       |
  261|      1|        new_value = clear_top_n_bits(new_value.get(), shift.get());
  262|       |
  263|      1|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  264|      1|    }
  265|       |
  266|       |    static void ShiftRightArithmetic(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  267|       |                                     phi::i32 shift) noexcept
  268|      5|    {
  269|       |        // Prevent undefined behavior by shifting by more than 31
  270|      5|        if (shift > 31)
  271|      1|        {
  272|      1|            processor.Raise(Exception::BadShift);
  273|       |
  274|       |            // Is negative ie. sign bit is set
  275|      1|            if (base < 0)
  276|      0|            {
  277|       |                // Set every byte to 1
  278|      0|                processor.IntRegisterSetSignedValue(dest_reg, ~0);
  279|      0|            }
  280|      1|            else
  281|      1|            {
  282|       |                // Set every byte to 0
  283|      1|                processor.IntRegisterSetSignedValue(dest_reg, 0);
  284|      1|            }
  285|      1|            return;
  286|      1|        }
  287|       |
  288|       |        // Negative shifts are undefined behaviour
  289|      4|        if (shift < 0)
  290|      1|        {
  291|      1|            processor.Raise(Exception::BadShift);
  292|      1|            return;
  293|      1|        }
  294|       |
  295|      3|        phi::i32 new_value = base.get() >> shift.get();
  296|       |
  297|      3|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  298|      3|    }
  299|       |
  300|       |    // Behavior is the same for logical and arithmetic shifts
  301|       |    static void ShiftLeft(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  302|       |                          phi::i32 shift) noexcept
  303|      8|    {
  304|      8|        if (shift > 31)
  305|      2|        {
  306|      2|            processor.Raise(Exception::BadShift);
  307|       |
  308|       |            // Just set register to 0
  309|      2|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  310|      2|            return;
  311|      2|        }
  312|       |
  313|       |        // Negative shifts are undefined behaviour
  314|      6|        if (shift < 0)
  315|      2|        {
  316|      2|            processor.Raise(Exception::BadShift);
  317|      2|            return;
  318|      2|        }
  319|       |
  320|      4|        phi::i32 new_value = base.get() << shift.get();
  321|       |
  322|      4|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  323|      4|    }
  324|       |
  325|       |    namespace impl
  326|       |    {
  327|       |        void ADD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  328|       |                 const InstructionArg& arg3) noexcept
  329|      3|        {
  330|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  331|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  332|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  333|       |
  334|      3|            const auto& dest_reg = arg1.AsRegisterInt();
  335|      3|            const auto& lhs_reg  = arg2.AsRegisterInt();
  336|      3|            const auto& rhs_reg  = arg3.AsRegisterInt();
  337|       |
  338|      3|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  339|      3|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  340|       |
  341|      3|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  342|      3|        }
  343|       |
  344|       |        void ADDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  345|       |                  const InstructionArg& arg3) noexcept
  346|      1|        {
  347|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  348|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  349|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  350|       |
  351|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  352|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  353|      1|            const auto& imm_value = arg3.AsImmediateValue();
  354|       |
  355|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  356|       |
  357|      1|            Addition(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  358|      1|        }
  359|       |
  360|       |        void ADDU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  361|       |                  const InstructionArg& arg3) noexcept
  362|      1|        {
  363|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  364|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  365|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  366|       |
  367|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  368|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  369|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  370|       |
  371|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  372|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  373|       |
  374|      1|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  375|      1|        }
  376|       |
  377|       |        void ADDUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  378|       |                   const InstructionArg& arg3) noexcept
  379|      2|        {
  380|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  381|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  382|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  383|       |
  384|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  385|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  386|      2|            const auto& imm_value = arg3.AsImmediateValue();
  387|       |
  388|      2|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  389|       |
  390|      2|            Addition(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  391|      2|        }
  392|       |
  393|       |        void ADDF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  394|       |                  const InstructionArg& arg3) noexcept
  395|      0|        {
  396|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  397|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  398|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  399|       |
  400|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  401|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  402|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  403|       |
  404|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  405|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  406|       |
  407|      0|            const phi::f32 new_value = lhs_value + rhs_value;
  408|       |
  409|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  410|      0|        }
  411|       |
  412|       |        void ADDD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  413|       |                  const InstructionArg& arg3) noexcept
  414|      0|        {
  415|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  416|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  417|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  418|       |
  419|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  420|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  421|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  422|       |
  423|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  424|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  425|       |
  426|      0|            const phi::f64 new_value = lhs_value + rhs_value;
  427|       |
  428|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  429|      0|        }
  430|       |
  431|       |        void SUB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  432|       |                 const InstructionArg& arg3) noexcept
  433|      1|        {
  434|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  435|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  436|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  437|       |
  438|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  439|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  440|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  441|       |
  442|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  443|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  444|       |
  445|      1|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  446|      1|        }
  447|       |
  448|       |        void SUBI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  449|       |                  const InstructionArg& arg3) noexcept
  450|      1|        {
  451|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  452|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  453|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  454|       |
  455|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  456|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  457|      1|            const auto& imm_value = arg3.AsImmediateValue();
  458|       |
  459|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  460|       |
  461|      1|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  462|      1|        }
  463|       |
  464|       |        void SUBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  465|       |                  const InstructionArg& arg3) noexcept
  466|      1|        {
  467|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  468|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  469|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  470|       |
  471|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  472|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  473|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  474|       |
  475|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  476|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  477|       |
  478|      1|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  479|      1|        }
  480|       |
  481|       |        void SUBUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  482|       |                   const InstructionArg& arg3) noexcept
  483|      2|        {
  484|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  485|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  486|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  487|       |
  488|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  489|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  490|      2|            const auto& imm_value = arg3.AsImmediateValue();
  491|       |
  492|      2|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  493|       |
  494|      2|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  495|      2|        }
  496|       |
  497|       |        void SUBF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  498|       |                  const InstructionArg& arg3) noexcept
  499|      0|        {
  500|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  501|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  502|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  503|       |
  504|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  505|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  506|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  507|       |
  508|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  509|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  510|       |
  511|      0|            const phi::f32 new_value = lhs_value - rhs_value;
  512|       |
  513|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  514|      0|        }
  515|       |
  516|       |        void SUBD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  517|       |                  const InstructionArg& arg3) noexcept
  518|      0|        {
  519|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  520|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  521|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  522|       |
  523|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  524|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  525|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  526|       |
  527|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  528|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  529|       |
  530|      0|            const phi::f64 new_value = lhs_value - rhs_value;
  531|       |
  532|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  533|      0|        }
  534|       |
  535|       |        void MULT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  536|       |                  const InstructionArg& arg3) noexcept
  537|      1|        {
  538|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  539|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  540|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  541|       |
  542|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  543|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  544|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  545|       |
  546|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  547|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  548|       |
  549|      1|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  550|      1|        }
  551|       |
  552|       |        void MULTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  553|       |                   const InstructionArg& arg3) noexcept
  554|      1|        {
  555|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  556|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  557|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  558|       |
  559|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  560|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  561|      1|            const auto& imm_value = arg3.AsImmediateValue();
  562|       |
  563|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  564|       |
  565|      1|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  566|      1|        }
  567|       |
  568|       |        void MULTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  569|       |                   const InstructionArg& arg3) noexcept
  570|      1|        {
  571|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  572|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  573|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  574|       |
  575|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  576|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  577|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  578|       |
  579|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  580|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  581|       |
  582|      1|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  583|      1|        }
  584|       |
  585|       |        void MULTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  586|       |                    const InstructionArg& arg3) noexcept
  587|      1|        {
  588|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  589|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  590|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  591|       |
  592|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  593|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  594|      1|            const auto& imm_value = arg3.AsImmediateValue();
  595|       |
  596|      1|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  597|       |
  598|      1|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  599|      1|        }
  600|       |
  601|       |        void MULTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  602|       |                   const InstructionArg& arg3) noexcept
  603|      0|        {
  604|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  605|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  606|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  607|       |
  608|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  609|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  610|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  611|       |
  612|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  613|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  614|       |
  615|      0|            const phi::f32 new_value = lhs_value * rhs_value;
  616|       |
  617|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  618|      0|        }
  619|       |
  620|       |        void MULTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  621|       |                   const InstructionArg& arg3) noexcept
  622|      0|        {
  623|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  624|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  625|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  626|       |
  627|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  628|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  629|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  630|       |
  631|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  632|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  633|       |
  634|      0|            const phi::f64 new_value = lhs_value * rhs_value;
  635|       |
  636|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  637|      0|        }
  638|       |
  639|       |        void DIV(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  640|       |                 const InstructionArg& arg3) noexcept
  641|      1|        {
  642|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  643|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  644|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  645|       |
  646|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  647|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  648|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  649|       |
  650|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  651|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  652|       |
  653|      1|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  654|      1|        }
  655|       |
  656|       |        void DIVI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  657|       |                  const InstructionArg& arg3) noexcept
  658|      2|        {
  659|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  660|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  661|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  662|       |
  663|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  664|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  665|      2|            const auto& imm_value = arg3.AsImmediateValue();
  666|       |
  667|      2|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  668|       |
  669|      2|            Division(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  670|      2|        }
  671|       |
  672|       |        void DIVU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  673|       |                  const InstructionArg& arg3) noexcept
  674|      1|        {
  675|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  676|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  677|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  678|       |
  679|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  680|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  681|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  682|       |
  683|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  684|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  685|       |
  686|      1|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  687|      1|        }
  688|       |
  689|       |        void DIVUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  690|       |                   const InstructionArg& arg3) noexcept
  691|      2|        {
  692|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  693|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  694|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  695|       |
  696|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  697|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  698|      2|            const auto& imm_value = arg3.AsImmediateValue();
  699|       |
  700|      2|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  701|       |
  702|      2|            Division(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  703|      2|        }
  704|       |
  705|       |        void DIVF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  706|       |                  const InstructionArg& arg3) noexcept
  707|      0|        {
  708|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  709|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  710|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  711|       |
  712|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  713|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  714|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  715|       |
  716|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  717|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  718|       |
  719|      0|            if (rhs_value.get() == 0.0f)
  720|      0|            {
  721|      0|                processor.Raise(Exception::DivideByZero);
  722|      0|                return;
  723|      0|            }
  724|       |
  725|      0|            const phi::f32 new_value = lhs_value / rhs_value;
  726|       |
  727|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  728|      0|        }
  729|       |
  730|       |        void DIVD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  731|       |                  const InstructionArg& arg3) noexcept
  732|      0|        {
  733|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  734|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  735|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  736|       |
  737|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  738|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  739|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  740|       |
  741|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  742|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  743|       |
  744|      0|            if (rhs_value.get() == 0.0)
  745|      0|            {
  746|      0|                processor.Raise(Exception::DivideByZero);
  747|      0|                return;
  748|      0|            }
  749|       |
  750|      0|            const phi::f64 new_value = lhs_value / rhs_value;
  751|       |
  752|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  753|      0|        }
  754|       |
  755|       |        void SLL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  756|       |                 const InstructionArg& arg3) noexcept
  757|      1|        {
  758|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  759|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  760|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  761|       |
  762|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  763|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  764|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  765|       |
  766|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  767|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  768|       |
  769|      1|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  770|      1|        }
  771|       |
  772|       |        void SLLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  773|       |                  const InstructionArg& arg3) noexcept
  774|      3|        {
  775|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  776|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  777|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  778|       |
  779|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
  780|      3|            const auto& src_reg   = arg2.AsRegisterInt();
  781|      3|            const auto& imm_value = arg3.AsImmediateValue();
  782|       |
  783|      3|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  784|      3|            phi::i32 shift_value = imm_value.signed_value;
  785|       |
  786|      3|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  787|      3|        }
  788|       |
  789|       |        void SRL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  790|       |                 const InstructionArg& arg3) noexcept
  791|      1|        {
  792|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  793|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  794|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  795|       |
  796|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  797|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  798|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  799|       |
  800|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  801|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  802|       |
  803|      1|            ShiftRightLogical(processor, dest_reg.register_id, lhs_value, rhs_value);
  804|      1|        }
  805|       |
  806|       |        void SRLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  807|       |                  const InstructionArg& arg3) noexcept
  808|      3|        {
  809|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  810|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  811|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  812|       |
  813|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
  814|      3|            const auto& src_reg   = arg2.AsRegisterInt();
  815|      3|            const auto& imm_value = arg3.AsImmediateValue();
  816|       |
  817|      3|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  818|      3|            phi::i32 shift_value = imm_value.signed_value;
  819|       |
  820|      3|            ShiftRightLogical(processor, dest_reg.register_id, src_value, shift_value);
  821|      3|        }
  822|       |
  823|       |        void SLA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  824|       |                 const InstructionArg& arg3) noexcept
  825|      1|        {
  826|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  827|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  828|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  829|       |
  830|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  831|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  832|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  833|       |
  834|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  835|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  836|       |
  837|      1|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  838|      1|        }
  839|       |
  840|       |        void SLAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  841|       |                  const InstructionArg& arg3) noexcept
  842|      3|        {
  843|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  844|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  845|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  846|       |
  847|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
  848|      3|            const auto& src_reg   = arg2.AsRegisterInt();
  849|      3|            const auto& imm_value = arg3.AsImmediateValue();
  850|       |
  851|      3|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  852|      3|            phi::i32 shift_value = imm_value.signed_value;
  853|       |
  854|      3|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  855|      3|        }
  856|       |
  857|       |        void SRA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  858|       |                 const InstructionArg& arg3) noexcept
  859|      2|        {
  860|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  861|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  862|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  863|       |
  864|      2|            const auto& dest_reg = arg1.AsRegisterInt();
  865|      2|            const auto& lhs_reg  = arg2.AsRegisterInt();
  866|      2|            const auto& rhs_reg  = arg3.AsRegisterInt();
  867|       |
  868|      2|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  869|      2|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  870|       |
  871|      2|            ShiftRightArithmetic(processor, dest_reg.register_id, lhs_value, rhs_value);
  872|      2|        }
  873|       |
  874|       |        void SRAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  875|       |                  const InstructionArg& arg3) noexcept
  876|      3|        {
  877|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  878|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  879|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  880|       |
  881|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
  882|      3|            const auto& src_reg   = arg2.AsRegisterInt();
  883|      3|            const auto& imm_value = arg3.AsImmediateValue();
  884|       |
  885|      3|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  886|      3|            phi::i32 shift_value = imm_value.signed_value;
  887|       |
  888|      3|            ShiftRightArithmetic(processor, dest_reg.register_id, src_value, shift_value);
  889|      3|        }
  890|       |
  891|       |        void AND(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  892|       |                 const InstructionArg& arg3) noexcept
  893|      1|        {
  894|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  895|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  896|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  897|       |
  898|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  899|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  900|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  901|       |
  902|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  903|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  904|      1|            phi::i32 new_value = lhs_value.get() & rhs_value.get();
  905|       |
  906|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  907|      1|        }
  908|       |
  909|       |        void ANDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  910|       |                  const InstructionArg& arg3) noexcept
  911|      1|        {
  912|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  913|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  914|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  915|       |
  916|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  917|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  918|      1|            const auto& imm_value = arg3.AsImmediateValue();
  919|       |
  920|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  921|      1|            phi::i32 new_value = src_value.get() & imm_value.signed_value.get();
  922|       |
  923|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  924|      1|        }
  925|       |
  926|       |        void OR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  927|       |                const InstructionArg& arg3) noexcept
  928|      1|        {
  929|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  930|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  931|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  932|       |
  933|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  934|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  935|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  936|       |
  937|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  938|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  939|      1|            phi::i32 new_value = lhs_value.get() | rhs_value.get();
  940|       |
  941|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  942|      1|        }
  943|       |
  944|       |        void ORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  945|       |                 const InstructionArg& arg3) noexcept
  946|      1|        {
  947|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  948|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  949|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  950|       |
  951|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  952|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  953|      1|            const auto& imm_value = arg3.AsImmediateValue();
  954|       |
  955|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  956|      1|            phi::i32 new_value = src_value.get() | imm_value.signed_value.get();
  957|       |
  958|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  959|      1|        }
  960|       |
  961|       |        void XOR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  962|       |                 const InstructionArg& arg3) noexcept
  963|      1|        {
  964|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  965|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  966|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  967|       |
  968|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  969|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  970|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  971|       |
  972|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  973|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  974|      1|            phi::i32 new_value = lhs_value.get() ^ rhs_value.get();
  975|       |
  976|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  977|      1|        }
  978|       |
  979|       |        void XORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  980|       |                  const InstructionArg& arg3) noexcept
  981|      1|        {
  982|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  983|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  984|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  985|       |
  986|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  987|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  988|      1|            const auto& imm_value = arg3.AsImmediateValue();
  989|       |
  990|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  991|      1|            phi::i32 new_value = src_value.get() ^ imm_value.signed_value.get();
  992|       |
  993|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  994|      1|        }
  995|       |
  996|       |        void SLT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  997|       |                 const InstructionArg& arg3) noexcept
  998|      1|        {
  999|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1000|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1001|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1002|       |
 1003|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1004|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1005|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1006|       |
 1007|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1008|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1009|       |
 1010|      1|            const phi::i32 new_value = (lhs_value < rhs_value ? 1 : 0);
 1011|       |
 1012|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1013|      1|        }
 1014|       |
 1015|       |        void SLTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1016|       |                  const InstructionArg& arg3) noexcept
 1017|      1|        {
 1018|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1019|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1020|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1021|       |
 1022|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1023|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1024|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1025|       |
 1026|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1027|       |
 1028|      1|            const phi::i32 new_value = (src_value < imm_value.signed_value ? 1 : 0);
 1029|       |
 1030|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1031|      1|        }
 1032|       |
 1033|       |        void SLTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1034|       |                  const InstructionArg& arg3) noexcept
 1035|      0|        {
 1036|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1037|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1038|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1039|       |
 1040|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1041|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1042|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1043|       |
 1044|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1045|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1046|       |
 1047|      0|            const phi::u32 new_value = (lhs_value < rhs_value ? 1u : 0u);
 1048|       |
 1049|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1050|      0|        }
 1051|       |
 1052|       |        void SLTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1053|       |                   const InstructionArg& arg3) noexcept
 1054|      0|        {
 1055|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1056|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1057|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1058|       |
 1059|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1060|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1061|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1062|       |
 1063|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1064|       |
 1065|      0|            const phi::u32 new_value = (src_value < imm_value.unsigned_value ? 1u : 0u);
 1066|       |
 1067|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1068|      0|        }
 1069|       |
 1070|       |        void LTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1071|       |                 const InstructionArg& arg3) noexcept
 1072|      0|        {
 1073|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1074|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1075|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1076|       |
 1077|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1078|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1079|       |
 1080|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1081|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1082|       |
 1083|      0|            const phi::Boolean new_value = (lhs_value < rhs_value);
 1084|       |
 1085|      0|            processor.SetFPSRValue(new_value);
 1086|      0|        }
 1087|       |
 1088|       |        void LTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1089|       |                 const InstructionArg& arg3) noexcept
 1090|      0|        {
 1091|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1092|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1093|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1094|       |
 1095|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1096|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1097|       |
 1098|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1099|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1100|       |
 1101|      0|            const phi::Boolean new_value = (lhs_value < rhs_value);
 1102|       |
 1103|      0|            processor.SetFPSRValue(new_value);
 1104|      0|        }
 1105|       |
 1106|       |        void SGT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1107|       |                 const InstructionArg& arg3) noexcept
 1108|      1|        {
 1109|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1110|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1111|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1112|       |
 1113|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1114|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1115|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1116|       |
 1117|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1118|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1119|       |
 1120|      1|            const phi::i32 new_value = (lhs_value > rhs_value ? 1 : 0);
 1121|       |
 1122|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1123|      1|        }
 1124|       |
 1125|       |        void SGTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1126|       |                  const InstructionArg& arg3) noexcept
 1127|      1|        {
 1128|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1129|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1130|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1131|       |
 1132|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1133|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1134|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1135|       |
 1136|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1137|       |
 1138|      1|            const phi::i32 new_value = (src_value > imm_value.signed_value ? 1 : 0);
 1139|       |
 1140|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1141|      1|        }
 1142|       |
 1143|       |        void SGTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1144|       |                  const InstructionArg& arg3) noexcept
 1145|      0|        {
 1146|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1147|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1148|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1149|       |
 1150|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1151|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1152|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1153|       |
 1154|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1155|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1156|       |
 1157|      0|            const phi::u32 new_value = (lhs_value > rhs_value ? 1u : 0u);
 1158|       |
 1159|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1160|      0|        }
 1161|       |
 1162|       |        void SGTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1163|       |                   const InstructionArg& arg3) noexcept
 1164|      0|        {
 1165|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1166|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1167|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1168|       |
 1169|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1170|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1171|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1172|       |
 1173|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1174|       |
 1175|      0|            const phi::u32 new_value = (src_value > imm_value.unsigned_value ? 1u : 0u);
 1176|       |
 1177|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1178|      0|        }
 1179|       |
 1180|       |        void GTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1181|       |                 const InstructionArg& arg3) noexcept
 1182|      0|        {
 1183|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1184|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1185|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1186|       |
 1187|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1188|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1189|       |
 1190|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1191|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1192|       |
 1193|      0|            const phi::Boolean new_value = (lhs_value > rhs_value);
 1194|       |
 1195|      0|            processor.SetFPSRValue(new_value);
 1196|      0|        }
 1197|       |
 1198|       |        void GTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1199|       |                 const InstructionArg& arg3) noexcept
 1200|      0|        {
 1201|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1202|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1203|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1204|       |
 1205|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1206|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1207|       |
 1208|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1209|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1210|       |
 1211|      0|            const phi::Boolean new_value = (lhs_value > rhs_value);
 1212|       |
 1213|      0|            processor.SetFPSRValue(new_value);
 1214|      0|        }
 1215|       |
 1216|       |        void SLE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1217|       |                 const InstructionArg& arg3) noexcept
 1218|      1|        {
 1219|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1220|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1221|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1222|       |
 1223|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1224|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1225|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1226|       |
 1227|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1228|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1229|       |
 1230|      1|            const phi::i32 new_value = (lhs_value <= rhs_value ? 1 : 0);
 1231|       |
 1232|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1233|      1|        }
 1234|       |
 1235|       |        void SLEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1236|       |                  const InstructionArg& arg3) noexcept
 1237|      1|        {
 1238|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1239|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1240|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1241|       |
 1242|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1243|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1244|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1245|       |
 1246|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1247|       |
 1248|      1|            const phi::i32 new_value = (src_value <= imm_value.signed_value ? 1 : 0);
 1249|       |
 1250|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1251|      1|        }
 1252|       |
 1253|       |        void SLEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1254|       |                  const InstructionArg& arg3) noexcept
 1255|      0|        {
 1256|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1257|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1258|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1259|       |
 1260|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1261|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1262|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1263|       |
 1264|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1265|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1266|       |
 1267|      0|            const phi::u32 new_value = (lhs_value <= rhs_value ? 1u : 0u);
 1268|       |
 1269|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1270|      0|        }
 1271|       |
 1272|       |        void SLEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1273|       |                   const InstructionArg& arg3) noexcept
 1274|      0|        {
 1275|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1276|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1277|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1278|       |
 1279|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1280|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1281|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1282|       |
 1283|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1284|       |
 1285|      0|            const phi::u32 new_value = (src_value <= imm_value.unsigned_value ? 1u : 0u);
 1286|       |
 1287|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1288|      0|        }
 1289|       |
 1290|       |        void LEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1291|       |                 const InstructionArg& arg3) noexcept
 1292|      0|        {
 1293|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1294|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1295|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1296|       |
 1297|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1298|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1299|       |
 1300|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1301|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1302|       |
 1303|      0|            const phi::Boolean new_value = (lhs_value <= rhs_value);
 1304|       |
 1305|      0|            processor.SetFPSRValue(new_value);
 1306|      0|        }
 1307|       |
 1308|       |        void LED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1309|       |                 const InstructionArg& arg3) noexcept
 1310|      0|        {
 1311|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1312|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1313|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1314|       |
 1315|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1316|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1317|       |
 1318|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1319|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1320|       |
 1321|      0|            const phi::Boolean new_value = (lhs_value <= rhs_value);
 1322|       |
 1323|      0|            processor.SetFPSRValue(new_value);
 1324|      0|        }
 1325|       |
 1326|       |        void SGE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1327|       |                 const InstructionArg& arg3) noexcept
 1328|      1|        {
 1329|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1330|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1331|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1332|       |
 1333|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1334|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1335|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1336|       |
 1337|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1338|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1339|       |
 1340|      1|            const phi::i32 new_value = (lhs_value >= rhs_value ? 1 : 0);
 1341|       |
 1342|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1343|      1|        }
 1344|       |
 1345|       |        void SGEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1346|       |                  const InstructionArg& arg3) noexcept
 1347|      1|        {
 1348|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1349|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1350|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1351|       |
 1352|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1353|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1354|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1355|       |
 1356|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1357|       |
 1358|      1|            const phi::i32 new_value = (src_value >= imm_value.signed_value ? 1 : 0);
 1359|       |
 1360|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1361|      1|        }
 1362|       |
 1363|       |        void SGEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1364|       |                  const InstructionArg& arg3) noexcept
 1365|      0|        {
 1366|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1367|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1368|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1369|       |
 1370|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1371|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1372|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1373|       |
 1374|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1375|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1376|       |
 1377|      0|            const phi::u32 new_value = (lhs_value >= rhs_value ? 1u : 0u);
 1378|       |
 1379|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1380|      0|        }
 1381|       |
 1382|       |        void SGEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1383|       |                   const InstructionArg& arg3) noexcept
 1384|      0|        {
 1385|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1386|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1387|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1388|       |
 1389|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1390|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1391|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1392|       |
 1393|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1394|       |
 1395|      0|            const phi::u32 new_value = (src_value >= imm_value.unsigned_value ? 1u : 0u);
 1396|       |
 1397|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1398|      0|        }
 1399|       |
 1400|       |        void GEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1401|       |                 const InstructionArg& arg3) noexcept
 1402|      0|        {
 1403|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1404|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1405|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1406|       |
 1407|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1408|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1409|       |
 1410|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1411|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1412|       |
 1413|      0|            const phi::Boolean new_value = (lhs_value >= rhs_value);
 1414|       |
 1415|      0|            processor.SetFPSRValue(new_value);
 1416|      0|        }
 1417|       |
 1418|       |        void GED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1419|       |                 const InstructionArg& arg3) noexcept
 1420|      0|        {
 1421|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1422|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1423|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1424|       |
 1425|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1426|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1427|       |
 1428|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1429|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1430|       |
 1431|      0|            const phi::Boolean new_value = (lhs_value >= rhs_value);
 1432|       |
 1433|      0|            processor.SetFPSRValue(new_value);
 1434|      0|        }
 1435|       |
 1436|       |        void SEQ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1437|       |                 const InstructionArg& arg3) noexcept
 1438|      2|        {
 1439|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1440|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1441|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1442|       |
 1443|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1444|      2|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1445|      2|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1446|       |
 1447|      2|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1448|      2|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1449|       |
 1450|      2|            const phi::i32 new_value = (lhs_value == rhs_value ? 1 : 0);
 1451|       |
 1452|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1453|      2|        }
 1454|       |
 1455|       |        void SEQI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1456|       |                  const InstructionArg& arg3) noexcept
 1457|      1|        {
 1458|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1459|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1460|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1461|       |
 1462|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1463|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1464|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1465|       |
 1466|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1467|       |
 1468|      1|            const phi::i32 new_value = (src_value == imm_value.signed_value ? 1 : 0);
 1469|       |
 1470|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1471|      1|        }
 1472|       |
 1473|       |        void SEQU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1474|       |                  const InstructionArg& arg3) noexcept
 1475|      0|        {
 1476|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1477|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1478|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1479|       |
 1480|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1481|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1482|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1483|       |
 1484|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1485|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1486|       |
 1487|      0|            const phi::u32 new_value = (lhs_value == rhs_value ? 1u : 0u);
 1488|       |
 1489|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1490|      0|        }
 1491|       |
 1492|       |        void SEQUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1493|       |                   const InstructionArg& arg3) noexcept
 1494|      0|        {
 1495|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1496|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1497|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1498|       |
 1499|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1500|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1501|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1502|       |
 1503|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1504|       |
 1505|      0|            const phi::u32 new_value = (src_value == imm_value.unsigned_value ? 1u : 0u);
 1506|       |
 1507|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1508|      0|        }
 1509|       |
 1510|       |        void EQF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1511|       |                 const InstructionArg& arg3) noexcept
 1512|      0|        {
 1513|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1514|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1515|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1516|       |
 1517|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1518|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1519|       |
 1520|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1521|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1522|       |
 1523|      0|            const phi::Boolean new_value = (lhs_value.get() == rhs_value.get());
 1524|       |
 1525|      0|            processor.SetFPSRValue(new_value);
 1526|      0|        }
 1527|       |
 1528|       |        void EQD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1529|       |                 const InstructionArg& arg3) noexcept
 1530|      0|        {
 1531|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1532|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1533|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1534|       |
 1535|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1536|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1537|       |
 1538|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1539|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1540|       |
 1541|      0|            const phi::Boolean new_value = (lhs_value.get() == rhs_value.get());
 1542|       |
 1543|      0|            processor.SetFPSRValue(new_value);
 1544|      0|        }
 1545|       |
 1546|       |        void SNE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1547|       |                 const InstructionArg& arg3) noexcept
 1548|      1|        {
 1549|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1550|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1551|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1552|       |
 1553|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1554|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1555|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1556|       |
 1557|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1558|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1559|       |
 1560|      1|            const phi::i32 new_value = (lhs_value != rhs_value ? 1 : 0);
 1561|       |
 1562|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1563|      1|        }
 1564|       |
 1565|       |        void SNEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1566|       |                  const InstructionArg& arg3) noexcept
 1567|      1|        {
 1568|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1569|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1570|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1571|       |
 1572|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1573|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1574|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1575|       |
 1576|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1577|       |
 1578|      1|            const phi::i32 new_value = (src_value != imm_value.signed_value ? 1 : 0);
 1579|       |
 1580|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1581|      1|        }
 1582|       |
 1583|       |        void SNEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1584|       |                  const InstructionArg& arg3) noexcept
 1585|      0|        {
 1586|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1587|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1588|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1589|       |
 1590|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1591|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1592|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1593|       |
 1594|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1595|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1596|       |
 1597|      0|            const phi::u32 new_value = (lhs_value != rhs_value ? 1u : 0u);
 1598|       |
 1599|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1600|      0|        }
 1601|       |
 1602|       |        void SNEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1603|       |                   const InstructionArg& arg3) noexcept
 1604|      0|        {
 1605|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1606|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1607|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1608|       |
 1609|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1610|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1611|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1612|       |
 1613|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1614|       |
 1615|      0|            const phi::u32 new_value = (src_value != imm_value.unsigned_value ? 1u : 0u);
 1616|       |
 1617|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1618|      0|        }
 1619|       |
 1620|       |        void NEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1621|       |                 const InstructionArg& arg3) noexcept
 1622|      0|        {
 1623|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1624|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1625|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1626|       |
 1627|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1628|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1629|       |
 1630|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1631|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1632|       |
 1633|      0|            const phi::Boolean new_value = (lhs_value.get() != rhs_value.get());
 1634|       |
 1635|      0|            processor.SetFPSRValue(new_value);
 1636|      0|        }
 1637|       |
 1638|       |        void NED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1639|       |                 const InstructionArg& arg3) noexcept
 1640|      0|        {
 1641|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1642|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1643|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1644|       |
 1645|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1646|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1647|       |
 1648|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1649|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1650|       |
 1651|      0|            const phi::Boolean new_value = (lhs_value.get() != rhs_value.get());
 1652|       |
 1653|      0|            processor.SetFPSRValue(new_value);
 1654|      0|        }
 1655|       |
 1656|       |        void BEQZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1657|       |                  const InstructionArg& arg3) noexcept
 1658|      1|        {
 1659|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1660|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1661|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1662|       |
 1663|      1|            const auto& test_reg   = arg1.AsRegisterInt();
 1664|      1|            const auto& jump_label = arg2.AsLabel();
 1665|       |
 1666|      1|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1667|       |
 1668|      1|            if (test_value == 0)
 1669|      1|            {
 1670|      1|                JumpToLabel(processor, jump_label.label_name);
 1671|      1|            }
 1672|      1|        }
 1673|       |
 1674|       |        void BNEZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1675|       |                  const InstructionArg& arg3) noexcept
 1676|      2|        {
 1677|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1678|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1679|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1680|       |
 1681|      2|            const auto& test_reg   = arg1.AsRegisterInt();
 1682|      2|            const auto& jump_label = arg2.AsLabel();
 1683|       |
 1684|      2|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1685|       |
 1686|      2|            if (test_value != 0)
 1687|      1|            {
 1688|      1|                JumpToLabel(processor, jump_label.label_name);
 1689|      1|            }
 1690|      2|        }
 1691|       |
 1692|       |        void BFPT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1693|       |                  const InstructionArg& arg3) noexcept
 1694|      0|        {
 1695|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1696|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1697|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1698|       |
 1699|      0|            const auto& jump_label = arg1.AsLabel();
 1700|       |
 1701|      0|            phi::Boolean test_value = processor.GetFPSRValue();
 1702|       |
 1703|      0|            if (test_value)
 1704|      0|            {
 1705|      0|                JumpToLabel(processor, jump_label.label_name);
 1706|      0|            }
 1707|      0|        }
 1708|       |
 1709|       |        void BFPF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1710|       |                  const InstructionArg& arg3) noexcept
 1711|      0|        {
 1712|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1713|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1714|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1715|       |
 1716|      0|            const auto& jump_label = arg1.AsLabel();
 1717|       |
 1718|      0|            phi::Boolean test_value = processor.GetFPSRValue();
 1719|       |
 1720|      0|            if (!test_value)
 1721|      0|            {
 1722|      0|                JumpToLabel(processor, jump_label.label_name);
 1723|      0|            }
 1724|      0|        }
 1725|       |
 1726|       |        void J(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1727|       |               const InstructionArg& arg3) noexcept
 1728|  10.0k|        {
 1729|  10.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1730|  10.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1731|  10.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1732|       |
 1733|  10.0k|            const auto& jump_label = arg1.AsLabel();
 1734|       |
 1735|  10.0k|            JumpToLabel(processor, jump_label.label_name);
 1736|  10.0k|        }
 1737|       |
 1738|       |        void JR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1739|       |                const InstructionArg& arg3) noexcept
 1740|  30.0k|        {
 1741|  30.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1742|  30.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1743|  30.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1744|       |
 1745|  30.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1746|       |
 1747|  30.0k|            JumpToRegister(processor, jump_register.register_id);
 1748|  30.0k|        }
 1749|       |
 1750|       |        void JAL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1751|       |                 const InstructionArg& arg3) noexcept
 1752|      1|        {
 1753|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1754|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1755|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1756|       |
 1757|      1|            const auto& jump_label = arg1.AsLabel();
 1758|       |
 1759|      1|            processor.IntRegisterSetUnsignedValue(IntRegisterID::R31,
 1760|      1|                                                  processor.GetNextProgramCounter());
 1761|       |
 1762|      1|            JumpToLabel(processor, jump_label.label_name);
 1763|      1|        }
 1764|       |
 1765|       |        void JALR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1766|       |                  const InstructionArg& arg3) noexcept
 1767|  10.0k|        {
 1768|  10.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1769|  10.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1770|  10.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1771|       |
 1772|  10.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1773|       |
 1774|  10.0k|            processor.IntRegisterSetUnsignedValue(IntRegisterID::R31,
 1775|  10.0k|                                                  processor.GetNextProgramCounter());
 1776|       |
 1777|  10.0k|            JumpToRegister(processor, jump_register.register_id);
 1778|  10.0k|        }
 1779|       |
 1780|       |        void LHI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1781|       |                 const InstructionArg& arg3) noexcept
 1782|      0|        {
 1783|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1784|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::ImmediateInteger);
 1785|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1786|       |
 1787|      0|            const IntRegisterID dest_reg  = arg1.AsRegisterInt().register_id;
 1788|      0|            std::int32_t        imm_value = arg2.AsImmediateValue().signed_value.get();
 1789|       |
 1790|      0|            imm_value = (imm_value << 16) & 0xFFFF0000;
 1791|       |
 1792|      0|            processor.IntRegisterSetSignedValue(dest_reg, imm_value);
 1793|      0|        }
 1794|       |
 1795|       |        void LB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1796|       |                const InstructionArg& arg3) noexcept
 1797|      1|        {
 1798|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1799|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1800|      1|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1801|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1802|       |
 1803|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1804|       |
 1805|      1|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1806|       |
 1807|      1|            if (!optional_address.has_value())
 1808|      0|            {
 1809|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1810|      0|                return;
 1811|      0|            }
 1812|       |
 1813|      1|            phi::i32 address = optional_address.value();
 1814|       |
 1815|      1|            auto optional_value =
 1816|      1|                    processor.GetMemory().LoadByte(static_cast<std::size_t>(address.get()));
 1817|       |
 1818|      1|            if (!optional_value.has_value())
 1819|      0|            {
 1820|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1821|      0|                PHI_LOG_ERROR("Failed to load byte at address {}", address.get());
 1822|      0|                return;
 1823|      0|            }
 1824|       |
 1825|      1|            phi::i32 value = optional_value.value();
 1826|       |
 1827|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, value);
 1828|      1|        }
 1829|       |
 1830|       |        void LBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1831|       |                 const InstructionArg& arg3) noexcept
 1832|      2|        {
 1833|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1834|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1835|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1836|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1837|       |
 1838|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1839|       |
 1840|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1841|       |
 1842|      2|            if (!optional_address.has_value())
 1843|      0|            {
 1844|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1845|      0|                return;
 1846|      0|            }
 1847|       |
 1848|      2|            phi::i32 address = optional_address.value();
 1849|       |
 1850|      2|            auto optional_value =
 1851|      2|                    processor.GetMemory().LoadUnsignedByte(static_cast<std::size_t>(address.get()));
 1852|       |
 1853|      2|            if (!optional_value.has_value())
 1854|      0|            {
 1855|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1856|      0|                PHI_LOG_ERROR("Failed to load unsigned byte at address {}", address.get());
 1857|      0|                return;
 1858|      0|            }
 1859|       |
 1860|      2|            phi::i32 value = optional_value.value();
 1861|       |
 1862|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1863|      2|        }
 1864|       |
 1865|       |        void LH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1866|       |                const InstructionArg& arg3) noexcept
 1867|      4|        {
 1868|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1869|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1870|      4|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1871|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1872|       |
 1873|      4|            const auto& dest_reg = arg1.AsRegisterInt();
 1874|       |
 1875|      4|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1876|       |
 1877|      4|            if (!optional_address.has_value())
 1878|      0|            {
 1879|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1880|      0|                return;
 1881|      0|            }
 1882|       |
 1883|      4|            phi::i32 address = optional_address.value();
 1884|       |
 1885|      4|            auto optional_value =
 1886|      4|                    processor.GetMemory().LoadHalfWord(static_cast<std::size_t>(address.get()));
 1887|       |
 1888|      4|            if (!optional_value.has_value())
 1889|      2|            {
 1890|      2|                processor.Raise(Exception::AddressOutOfBounds);
 1891|      2|                PHI_LOG_ERROR("Failed to load half byte at address {}", address.get());
 1892|      2|                return;
 1893|      2|            }
 1894|       |
 1895|      2|            phi::i32 value = optional_value.value();
 1896|       |
 1897|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1898|      2|        }
 1899|       |
 1900|       |        void LHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1901|       |                 const InstructionArg& arg3) noexcept
 1902|      2|        {
 1903|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1904|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1905|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1906|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1907|       |
 1908|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1909|       |
 1910|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1911|       |
 1912|      2|            if (!optional_address.has_value())
 1913|      0|            {
 1914|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1915|      0|                return;
 1916|      0|            }
 1917|       |
 1918|      2|            phi::i32 address = optional_address.value();
 1919|       |
 1920|      2|            auto optional_value = processor.GetMemory().LoadUnsignedHalfWord(
 1921|      2|                    static_cast<std::size_t>(address.get()));
 1922|       |
 1923|      2|            if (!optional_value.has_value())
 1924|      0|            {
 1925|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1926|      0|                PHI_LOG_ERROR("Failed to load unsigned half byte at address {}", address.get());
 1927|      0|                return;
 1928|      0|            }
 1929|       |
 1930|      2|            phi::i32 value = optional_value.value();
 1931|       |
 1932|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1933|      2|        }
 1934|       |
 1935|       |        void LW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1936|       |                const InstructionArg& arg3) noexcept
 1937|      6|        {
 1938|      6|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1939|      6|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1940|      6|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1941|      6|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1942|       |
 1943|      6|            const auto& dest_reg = arg1.AsRegisterInt();
 1944|       |
 1945|      6|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1946|       |
 1947|      6|            if (!optional_address.has_value())
 1948|      1|            {
 1949|      1|                processor.Raise(Exception::AddressOutOfBounds);
 1950|      1|                return;
 1951|      1|            }
 1952|       |
 1953|      5|            phi::i32 address = optional_address.value();
 1954|       |
 1955|      5|            auto optional_value =
 1956|      5|                    processor.GetMemory().LoadWord(static_cast<std::size_t>(address.get()));
 1957|       |
 1958|      5|            if (!optional_value.has_value())
 1959|      1|            {
 1960|      1|                processor.Raise(Exception::AddressOutOfBounds);
 1961|      1|                PHI_LOG_ERROR("Failed to load word at address {}", address.get());
 1962|      1|                return;
 1963|      1|            }
 1964|       |
 1965|      4|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1966|      4|        }
 1967|       |
 1968|       |        void LWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1969|       |                 const InstructionArg& arg3) noexcept
 1970|      2|        {
 1971|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1972|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1973|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1974|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1975|       |
 1976|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1977|       |
 1978|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1979|       |
 1980|      2|            if (!optional_address.has_value())
 1981|      0|            {
 1982|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1983|      0|                return;
 1984|      0|            }
 1985|       |
 1986|      2|            phi::i32 address = optional_address.value();
 1987|       |
 1988|      2|            auto optional_value =
 1989|      2|                    processor.GetMemory().LoadUnsignedWord(static_cast<std::size_t>(address.get()));
 1990|       |
 1991|      2|            if (!optional_value.has_value())
 1992|      0|            {
 1993|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1994|      0|                PHI_LOG_ERROR("Failed to load unsigned word at address {}", address.get());
 1995|      0|                return;
 1996|      0|            }
 1997|       |
 1998|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1999|      2|        }
 2000|       |
 2001|       |        void LF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2002|       |                const InstructionArg& arg3) noexcept
 2003|      0|        {
 2004|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2005|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 2006|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 2007|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2008|       |
 2009|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 2010|       |
 2011|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 2012|       |
 2013|      0|            if (!optional_address.has_value())
 2014|      0|            {
 2015|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2016|      0|                return;
 2017|      0|            }
 2018|       |
 2019|      0|            phi::i32 address = optional_address.value();
 2020|       |
 2021|      0|            auto optional_value =
 2022|      0|                    processor.GetMemory().LoadFloat(static_cast<std::size_t>(address.get()));
 2023|       |
 2024|      0|            if (!optional_value.has_value())
 2025|      0|            {
 2026|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2027|      0|                PHI_LOG_ERROR("Failed to load float at address {}", address.get());
 2028|      0|                return;
 2029|      0|            }
 2030|       |
 2031|      0|            processor.FloatRegisterSetFloatValue(dest_reg.register_id, optional_value.value());
 2032|      0|        }
 2033|       |
 2034|       |        void LD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2035|       |                const InstructionArg& arg3) noexcept
 2036|      0|        {
 2037|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2038|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 2039|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 2040|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2041|       |
 2042|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 2043|       |
 2044|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 2045|       |
 2046|      0|            if (!optional_address.has_value())
 2047|      0|            {
 2048|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2049|      0|                return;
 2050|      0|            }
 2051|       |
 2052|      0|            phi::i32 address = optional_address.value();
 2053|       |
 2054|      0|            auto optional_value =
 2055|      0|                    processor.GetMemory().LoadDouble(static_cast<std::size_t>(address.get()));
 2056|       |
 2057|      0|            if (!optional_value.has_value())
 2058|      0|            {
 2059|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2060|      0|                PHI_LOG_ERROR("Failed to load double at address {}", address.get());
 2061|      0|                return;
 2062|      0|            }
 2063|       |
 2064|      0|            processor.FloatRegisterSetDoubleValue(dest_reg.register_id, optional_value.value());
 2065|      0|        }
 2066|       |
 2067|       |        void SB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2068|       |                const InstructionArg& arg3) noexcept
 2069|      2|        {
 2070|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2071|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2072|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2073|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2074|       |
 2075|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2076|       |
 2077|      2|            if (!optional_address.has_value())
 2078|      0|            {
 2079|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2080|      0|                return;
 2081|      0|            }
 2082|       |
 2083|      2|            phi::i32 address = optional_address.value();
 2084|       |
 2085|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2086|       |
 2087|      2|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2088|       |
 2089|      2|            phi::Boolean success = processor.GetMemory().StoreByte(
 2090|      2|                    static_cast<std::size_t>(address.get()), static_cast<std::int8_t>(value.get()));
 2091|       |
 2092|      2|            if (!success)
 2093|      0|            {
 2094|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2095|      0|                PHI_LOG_ERROR("Failed to store byte at address {}", address.get());
 2096|      0|            }
 2097|      2|        }
 2098|       |
 2099|       |        void SBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2100|       |                 const InstructionArg& arg3) noexcept
 2101|      2|        {
 2102|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2103|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2104|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2105|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2106|       |
 2107|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2108|       |
 2109|      2|            if (!optional_address.has_value())
 2110|      0|            {
 2111|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2112|      0|                return;
 2113|      0|            }
 2114|       |
 2115|      2|            phi::i32 address = optional_address.value();
 2116|       |
 2117|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2118|       |
 2119|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2120|       |
 2121|      2|            phi::Boolean success =
 2122|      2|                    processor.GetMemory().StoreUnsignedByte(static_cast<std::size_t>(address.get()),
 2123|      2|                                                            static_cast<std::uint8_t>(value.get()));
 2124|       |
 2125|      2|            if (!success)
 2126|      0|            {
 2127|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2128|      0|                PHI_LOG_ERROR("Failed to store unsigned byte at address {}", address.get());
 2129|      0|            }
 2130|      2|        }
 2131|       |
 2132|       |        void SH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2133|       |                const InstructionArg& arg3) noexcept
 2134|      2|        {
 2135|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2136|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2137|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2138|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2139|       |
 2140|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2141|       |
 2142|      2|            if (!optional_address.has_value())
 2143|      0|            {
 2144|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2145|      0|                return;
 2146|      0|            }
 2147|       |
 2148|      2|            phi::i32 address = optional_address.value();
 2149|       |
 2150|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2151|       |
 2152|      2|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2153|       |
 2154|      2|            phi::Boolean success =
 2155|      2|                    processor.GetMemory().StoreHalfWord(static_cast<std::size_t>(address.get()),
 2156|      2|                                                        static_cast<std::int16_t>(value.get()));
 2157|       |
 2158|      2|            if (!success)
 2159|      0|            {
 2160|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2161|      0|                PHI_LOG_ERROR("Failed to store half word at address {}", address.get());
 2162|      0|            }
 2163|      2|        }
 2164|       |
 2165|       |        void SHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2166|       |                 const InstructionArg& arg3) noexcept
 2167|      2|        {
 2168|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2169|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2170|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2171|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2172|       |
 2173|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2174|       |
 2175|      2|            if (!optional_address.has_value())
 2176|      0|            {
 2177|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2178|      0|                return;
 2179|      0|            }
 2180|       |
 2181|      2|            phi::i32 address = optional_address.value();
 2182|       |
 2183|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2184|       |
 2185|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2186|       |
 2187|      2|            phi::Boolean success = processor.GetMemory().StoreUnsignedHalfWord(
 2188|      2|                    static_cast<std::size_t>(address.get()),
 2189|      2|                    static_cast<std::uint16_t>(value.get()));
 2190|       |
 2191|      2|            if (!success)
 2192|      0|            {
 2193|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2194|      0|                PHI_LOG_ERROR("Failed to store unsigned half word at address {}", address.get());
 2195|      0|            }
 2196|      2|        }
 2197|       |
 2198|       |        void SW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2199|       |                const InstructionArg& arg3) noexcept
 2200|      5|        {
 2201|      5|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2202|      5|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2203|      5|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2204|      5|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2205|       |
 2206|      5|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2207|       |
 2208|      5|            if (!optional_address.has_value())
 2209|      1|            {
 2210|      1|                processor.Raise(Exception::AddressOutOfBounds);
 2211|      1|                return;
 2212|      1|            }
 2213|       |
 2214|      4|            phi::i32 address = optional_address.value();
 2215|       |
 2216|      4|            const auto& src_reg = arg2.AsRegisterInt();
 2217|       |
 2218|      4|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2219|       |
 2220|      4|            phi::Boolean success =
 2221|      4|                    processor.GetMemory().StoreWord(static_cast<std::size_t>(address.get()), value);
 2222|       |
 2223|      4|            if (!success)
 2224|      1|            {
 2225|      1|                processor.Raise(Exception::AddressOutOfBounds);
 2226|      1|                PHI_LOG_ERROR("Failed to store word at address {}", address.get());
 2227|      1|            }
 2228|      4|        }
 2229|       |
 2230|       |        void SWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2231|       |                 const InstructionArg& arg3) noexcept
 2232|      3|        {
 2233|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2234|      3|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2235|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2236|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2237|       |
 2238|      3|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2239|       |
 2240|      3|            if (!optional_address.has_value())
 2241|      0|            {
 2242|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2243|      0|                return;
 2244|      0|            }
 2245|       |
 2246|      3|            phi::i32 address = optional_address.value();
 2247|       |
 2248|      3|            const auto& src_reg = arg2.AsRegisterInt();
 2249|       |
 2250|      3|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2251|       |
 2252|      3|            phi::Boolean success = processor.GetMemory().StoreUnsignedWord(
 2253|      3|                    static_cast<std::size_t>(address.get()), value);
 2254|       |
 2255|      3|            if (!success)
 2256|      0|            {
 2257|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2258|      0|                PHI_LOG_ERROR("Failed to store unsigned word at address {}", address.get());
 2259|      0|            }
 2260|      3|        }
 2261|       |
 2262|       |        void SF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2263|       |                const InstructionArg& arg3) noexcept
 2264|      0|        {
 2265|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2266|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2267|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2268|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2269|       |
 2270|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2271|       |
 2272|      0|            if (!optional_address.has_value())
 2273|      0|            {
 2274|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2275|      0|                return;
 2276|      0|            }
 2277|       |
 2278|      0|            phi::i32 address = optional_address.value();
 2279|       |
 2280|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2281|       |
 2282|      0|            phi::f32 value = processor.FloatRegisterGetFloatValue(src_reg.register_id);
 2283|       |
 2284|      0|            phi::Boolean success = processor.GetMemory().StoreFloat(
 2285|      0|                    static_cast<std::size_t>(address.get()), value);
 2286|       |
 2287|      0|            if (!success)
 2288|      0|            {
 2289|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2290|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2291|      0|            }
 2292|      0|        }
 2293|       |
 2294|       |        void SD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2295|       |                const InstructionArg& arg3) noexcept
 2296|      0|        {
 2297|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2298|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2299|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2300|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2301|       |
 2302|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2303|       |
 2304|      0|            if (!optional_address.has_value())
 2305|      0|            {
 2306|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2307|      0|                return;
 2308|      0|            }
 2309|       |
 2310|      0|            phi::i32 address = optional_address.value();
 2311|       |
 2312|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2313|       |
 2314|      0|            phi::f64 value = processor.FloatRegisterGetDoubleValue(src_reg.register_id);
 2315|       |
 2316|      0|            phi::Boolean success = processor.GetMemory().StoreDouble(
 2317|      0|                    static_cast<std::size_t>(address.get()), value);
 2318|       |
 2319|      0|            if (!success)
 2320|      0|            {
 2321|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2322|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2323|      0|            }
 2324|      0|        }
 2325|       |
 2326|       |        void MOVF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2327|       |                  const InstructionArg& arg3) noexcept
 2328|      0|        {
 2329|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2330|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2331|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2332|       |
 2333|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2334|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2335|       |
 2336|      0|            const phi::f32 source_value = processor.FloatRegisterGetFloatValue(source_reg);
 2337|       |
 2338|      0|            processor.FloatRegisterSetFloatValue(dest_reg, source_value);
 2339|      0|        }
 2340|       |
 2341|       |        void MOVD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2342|       |                  const InstructionArg& arg3) noexcept
 2343|      0|        {
 2344|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2345|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2346|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2347|       |
 2348|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2349|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2350|       |
 2351|      0|            const phi::f64 source_value = processor.FloatRegisterGetDoubleValue(source_reg);
 2352|       |
 2353|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, source_value);
 2354|      0|        }
 2355|       |
 2356|       |        void MOVFP2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2357|       |                     const InstructionArg& arg3) noexcept
 2358|      0|        {
 2359|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 2360|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2361|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2362|       |
 2363|      0|            const IntRegisterID   dest_reg   = arg1.AsRegisterInt().register_id;
 2364|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2365|       |
 2366|      0|            const float source_value = processor.FloatRegisterGetFloatValue(source_reg).get();
 2367|       |
 2368|      0|            const std::uint32_t moved_value =
 2369|      0|                    *reinterpret_cast<const std::uint32_t*>(&source_value);
 2370|       |
 2371|      0|            processor.IntRegisterSetUnsignedValue(dest_reg, moved_value);
 2372|      0|        }
 2373|       |
 2374|       |        void MOVI2FP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2375|       |                     const InstructionArg& arg3) noexcept
 2376|      0|        {
 2377|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2378|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2379|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2380|       |
 2381|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2382|      0|            const IntRegisterID   source_reg = arg2.AsRegisterInt().register_id;
 2383|       |
 2384|      0|            const std::uint32_t source_value =
 2385|      0|                    processor.IntRegisterGetUnsignedValue(source_reg).get();
 2386|       |
 2387|      0|            const float moved_value = *reinterpret_cast<const float*>(&source_value);
 2388|       |
 2389|      0|            processor.FloatRegisterSetFloatValue(dest_reg, moved_value);
 2390|      0|        }
 2391|       |
 2392|       |        void CVTF2D(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2393|       |                    const InstructionArg& arg3) noexcept
 2394|      0|        {
 2395|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2396|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2397|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2398|       |
 2399|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2400|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2401|       |
 2402|      0|            const phi::f32 src_value = processor.FloatRegisterGetFloatValue(src_reg);
 2403|       |
 2404|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, src_value);
 2405|      0|        }
 2406|       |
 2407|       |        void CVTF2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2408|       |                    const InstructionArg& arg3) noexcept
 2409|      0|        {
 2410|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2411|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2412|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2413|       |
 2414|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2415|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2416|       |
 2417|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2418|      0|            const std::int32_t converted_value_int = static_cast<std::int32_t>(src_value);
 2419|      0|            const float        converted_value_float =
 2420|      0|                    *reinterpret_cast<const float*>(&converted_value_int);
 2421|       |
 2422|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2423|      0|        }
 2424|       |
 2425|       |        void CVTD2F(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2426|       |                    const InstructionArg& arg3) noexcept
 2427|      0|        {
 2428|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2429|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2430|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2431|       |
 2432|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2433|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2434|       |
 2435|      0|            const double src_value       = processor.FloatRegisterGetDoubleValue(src_reg).get();
 2436|      0|            const float  converted_value = static_cast<float>(src_value);
 2437|       |
 2438|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value);
 2439|      0|        }
 2440|       |
 2441|       |        void CVTD2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2442|       |                    const InstructionArg& arg3) noexcept
 2443|      0|        {
 2444|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2445|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2446|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2447|       |
 2448|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2449|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2450|       |
 2451|      0|            const double       src_value = processor.FloatRegisterGetDoubleValue(src_reg).get();
 2452|      0|            const std::int32_t converted_value_int = static_cast<std::int32_t>(src_value);
 2453|      0|            const float        converted_value_float =
 2454|      0|                    *reinterpret_cast<const float*>(&converted_value_int);
 2455|       |
 2456|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2457|      0|        }
 2458|       |
 2459|       |        void CVTI2F(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2460|       |                    const InstructionArg& arg3) noexcept
 2461|      0|        {
 2462|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2463|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2464|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2465|       |
 2466|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2467|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2468|       |
 2469|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2470|      0|            const std::int32_t converted_value_int =
 2471|      0|                    *reinterpret_cast<const std::int32_t*>(&src_value);
 2472|      0|            const float converted_value_float = static_cast<float>(converted_value_int);
 2473|       |
 2474|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2475|      0|        }
 2476|       |
 2477|       |        void CVTI2D(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2478|       |                    const InstructionArg& arg3) noexcept
 2479|      0|        {
 2480|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2481|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2482|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2483|       |
 2484|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2485|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2486|       |
 2487|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2488|      0|            const std::int32_t converted_value_int =
 2489|      0|                    *reinterpret_cast<const std::int32_t*>(&src_value);
 2490|      0|            const double converted_value_double = static_cast<double>(converted_value_int);
 2491|       |
 2492|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, converted_value_double);
 2493|      0|        }
 2494|       |
 2495|       |        void TRAP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2496|       |                  const InstructionArg& arg3) noexcept
 2497|      1|        {
 2498|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::ImmediateInteger);
 2499|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2500|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2501|       |
 2502|      1|            processor.Raise(Exception::Trap);
 2503|      1|        }
 2504|       |
 2505|       |        void HALT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2506|       |                  const InstructionArg& arg3) noexcept
 2507|      1|        {
 2508|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2509|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2510|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2511|       |
 2512|      1|            processor.Raise(Exception::Halt);
 2513|      1|        }
 2514|       |
 2515|       |        void NOP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2516|       |                 const InstructionArg& arg3) noexcept
 2517|     12|        {
 2518|     12|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2519|     12|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2520|     12|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2521|       |
 2522|       |            /* Do nothing */
 2523|     12|        }
 2524|       |    } // namespace impl
 2525|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/FloatRegister.cpp:
    1|       |#include "DLX/FloatRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void FloatRegister::SetValue(const phi::f32 val) noexcept
    6|  32.1k|    {
    7|  32.1k|        m_Value = val;
    8|  32.1k|    }
    9|       |
   10|       |    phi::f32 FloatRegister::GetValue() const noexcept
   11|      0|    {
   12|      0|        return m_Value;
   13|      0|    }
   14|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/ParsedProgram.cpp:
    1|       |#include "DLX/ParsedProgram.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    std::string ParsedProgram::GetDump() const noexcept
    6|      0|    {
    7|      0|        std::string text;
    8|       |
    9|      0|        bool valid = !m_Instructions.empty() && m_ParseErrors.empty();
   10|       |
   11|      0|        text.append(fmt::format("Valid: {:s}\n\n", valid ? "True" : "False"));
   12|       |
   13|       |        // Parser errors
   14|      0|        text.append("Parser errors:\n");
   15|       |
   16|      0|        if (m_ParseErrors.empty())
   17|      0|        {
   18|      0|            text.append("None\n");
   19|      0|        }
   20|      0|        else
   21|      0|        {
   22|      0|            for (const ParseError& err : m_ParseErrors)
   23|      0|            {
   24|      0|                text.append(err.message + '\n');
   25|      0|            }
   26|      0|        }
   27|       |
   28|       |        // Jump data
   29|      0|        text.append("\nJump data:\n");
   30|       |
   31|      0|        if (m_JumpData.empty())
   32|      0|        {
   33|      0|            text.append("None\n");
   34|      0|        }
   35|      0|        else
   36|      0|        {
   37|      0|            for (auto it = m_JumpData.begin(); it != m_JumpData.end(); ++it)
   38|      0|            {
   39|      0|                text.append(fmt::format("L: {:s}, dst: {:d}\n", it->first, it->second));
   40|      0|            }
   41|      0|        }
   42|       |
   43|       |        // Instructions
   44|      0|        text.append("\nInstructions:\n");
   45|       |
   46|      0|        if (m_Instructions.empty())
   47|      0|        {
   48|      0|            text.append("None\n");
   49|      0|        }
   50|      0|        else
   51|      0|        {
   52|      0|            for (phi::usize i{0u}; i < m_Instructions.size(); ++i)
   53|      0|            {
   54|      0|                const Instruction& instr = m_Instructions.at(i.get());
   55|      0|                text.append(fmt::format("#{:03d}:  {:s}\n", i.get(), instr.DebugInfo()));
   56|      0|            }
   57|      0|        }
   58|       |
   59|       |        // Tokens
   60|      0|        text.append("\nTokens:\n");
   61|       |
   62|      0|        if (m_Tokens.empty())
   63|      0|        {
   64|      0|            text.append("None\n");
   65|      0|        }
   66|      0|        else
   67|      0|        {
   68|      0|            for (const Token& token : m_Tokens)
   69|      0|            {
   70|      0|                text.append(token.DebugInfo() + '\n');
   71|      0|            }
   72|      0|        }
   73|       |
   74|      0|        return text;
   75|      0|    }
   76|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionArg.cpp:
    1|       |#include "DLX/InstructionArg.hpp"
    2|       |
    3|       |#include "DLX/InstructionInfo.hpp"
    4|       |#include <Phi/Core/Assert.hpp>
    5|       |#include <magic_enum.hpp>
    6|       |
    7|       |namespace dlx
    8|       |{
    9|       |    InstructionArg::InstructionArg() noexcept
   10|       |        : m_Type(ArgumentType::None)
   11|       |        , address_displacement()
   12|  8.58k|    {}
   13|       |
   14|       |    ArgumentType InstructionArg::GetType() const noexcept
   15|   150k|    {
   16|   150k|        return m_Type;
   17|   150k|    }
   18|       |
   19|       |    std::string InstructionArg::DebugInfo() const noexcept
   20|      0|    {
   21|      0|        switch (m_Type)
   22|      0|        {
   23|      0|            case ArgumentType::None:
   24|      0|                return "None";
   25|       |
   26|      0|            case ArgumentType::AddressDisplacement: {
   27|      0|                AddressDisplacement adr = AsAddressDisplacement();
   28|      0|                return fmt::format("{:d}({:s})", adr.displacement.get(),
   29|      0|                                   magic_enum::enum_name(adr.register_id));
   30|      0|            }
   31|       |
   32|      0|            case ArgumentType::FloatRegister:
   33|      0|                return fmt::format("{:s}", magic_enum::enum_name(AsRegisterFloat().register_id));
   34|       |
   35|      0|            case ArgumentType::IntRegister:
   36|      0|                return fmt::format("{:s}", magic_enum::enum_name(AsRegisterInt().register_id));
   37|       |
   38|      0|            case ArgumentType::ImmediateInteger:
   39|      0|                return fmt::format("#{:d}", AsImmediateValue().signed_value.get());
   40|       |
   41|      0|            case ArgumentType::Label:
   42|      0|                return fmt::format("{:s}", AsLabel().label_name);
   43|       |
   44|      0|            default:
   45|      0|                PHI_ASSERT_NOT_REACHED();
   46|      0|                break;
   47|      0|        }
   48|       |
   49|      0|        PHI_ASSERT_NOT_REACHED();
   50|      0|        return "Unknown";
   51|      0|    }
   52|       |
   53|       |    const InstructionArg::RegisterInt& InstructionArg::AsRegisterInt() const noexcept
   54|  40.1k|    {
   55|  40.1k|        PHI_ASSERT(m_Type == ArgumentType::IntRegister);
   56|       |
   57|  40.1k|        return register_int;
   58|  40.1k|    }
   59|       |
   60|       |    const InstructionArg::RegisterFloat& InstructionArg::AsRegisterFloat() const noexcept
   61|      0|    {
   62|      0|        PHI_ASSERT(m_Type == ArgumentType::FloatRegister);
   63|       |
   64|      0|        return register_float;
   65|      0|    }
   66|       |
   67|       |    const InstructionArg::ImmediateValue& InstructionArg::AsImmediateValue() const noexcept
   68|     51|    {
   69|     51|        PHI_ASSERT(m_Type == ArgumentType::ImmediateInteger);
   70|       |
   71|     51|        return immediate_value;
   72|     51|    }
   73|       |
   74|       |    const InstructionArg::AddressDisplacement& InstructionArg::AsAddressDisplacement()
   75|       |            const noexcept
   76|     15|    {
   77|     15|        PHI_ASSERT(m_Type == ArgumentType::AddressDisplacement);
   78|       |
   79|     15|        return address_displacement;
   80|     15|    }
   81|       |
   82|       |    const InstructionArg::Label& InstructionArg::AsLabel() const noexcept
   83|  10.0k|    {
   84|  10.0k|        PHI_ASSERT(m_Type == ArgumentType::Label);
   85|       |
   86|  10.0k|        return label;
   87|  10.0k|    }
   88|       |
   89|       |    phi::Boolean operator==(const InstructionArg& lhs, const InstructionArg& rhs) noexcept
   90|      0|    {
   91|      0|        if (lhs.GetType() != rhs.GetType())
   92|      0|        {
   93|      0|            return false;
   94|      0|        }
   95|       |
   96|      0|        switch (lhs.GetType())
   97|      0|        {
   98|      0|            case ArgumentType::AddressDisplacement:
   99|      0|                return (lhs.AsAddressDisplacement().displacement ==
  100|      0|                        rhs.AsAddressDisplacement().displacement) &&
  101|      0|                       (lhs.AsAddressDisplacement().register_id ==
  102|      0|                        rhs.AsAddressDisplacement().register_id);
  103|      0|            case ArgumentType::ImmediateInteger:
  104|      0|                return lhs.AsImmediateValue().signed_value == rhs.AsImmediateValue().signed_value;
  105|      0|            case ArgumentType::IntRegister:
  106|      0|                return lhs.AsRegisterInt().register_id == rhs.AsRegisterInt().register_id;
  107|      0|            case ArgumentType::FloatRegister:
  108|      0|                return lhs.AsRegisterFloat().register_id == rhs.AsRegisterFloat().register_id;
  109|      0|            case ArgumentType::Label:
  110|      0|                return lhs.AsLabel().label_name == rhs.AsLabel().label_name;
  111|      0|            case ArgumentType::None:
  112|      0|                return true;
  113|      0|            default:
  114|      0|                PHI_ASSERT_NOT_REACHED();
  115|      0|                break;
  116|      0|        }
  117|       |
  118|      0|        PHI_ASSERT_NOT_REACHED();
  119|      0|        return false;
  120|      0|    }
  121|       |
  122|       |    phi::Boolean operator!=(const InstructionArg& lhs, const InstructionArg& rhs) noexcept
  123|      0|    {
  124|      0|        return !(lhs == rhs);
  125|      0|    }
  126|       |
  127|       |    InstructionArg ConstructInstructionArgRegisterInt(IntRegisterID id) noexcept
  128|    608|    {
  129|    608|        InstructionArg arg;
  130|    608|        arg.m_Type                   = ArgumentType::IntRegister;
  131|    608|        arg.register_int.register_id = id;
  132|    608|        return arg;
  133|    608|    }
  134|       |
  135|       |    InstructionArg ConstructInstructionArgRegisterFloat(FloatRegisterID id) noexcept
  136|      0|    {
  137|      0|        InstructionArg arg;
  138|      0|        arg.m_Type                     = ArgumentType::FloatRegister;
  139|      0|        arg.register_float.register_id = id;
  140|      0|        return arg;
  141|      0|    }
  142|       |
  143|       |    InstructionArg ConstructInstructionArgImmediateValue(std::int16_t value) noexcept
  144|     59|    {
  145|     59|        InstructionArg arg;
  146|     59|        arg.m_Type                       = ArgumentType::ImmediateInteger;
  147|     59|        arg.immediate_value.signed_value = value;
  148|     59|        return arg;
  149|     59|    }
  150|       |
  151|       |    InstructionArg ConstructInstructionArgAddressDisplacement(IntRegisterID id,
  152|       |                                                              phi::i32      displacement) noexcept
  153|     15|    {
  154|     15|        InstructionArg arg;
  155|     15|        arg.m_Type                            = ArgumentType::AddressDisplacement;
  156|     15|        arg.address_displacement.register_id  = id;
  157|     15|        arg.address_displacement.displacement = displacement;
  158|     15|        return arg;
  159|     15|    }
  160|       |
  161|       |    InstructionArg ConstructInstructionArgLabel(std::string_view label_name) noexcept
  162|     26|    {
  163|     26|        InstructionArg arg;
  164|     26|        arg.m_Type           = ArgumentType::Label;
  165|     26|        arg.label.label_name = label_name;
  166|     26|        return arg;
  167|     26|    }
  168|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/MemoryBlock.cpp:
    1|       |#include "DLX/MemoryBlock.hpp"
    2|       |#include "Phi/Core/Boolean.hpp"
    3|       |#include "Phi/Core/Log.hpp"
    4|       |#include <cstdint>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    MemoryBlock::MemoryBlock(phi::usize start_address, phi::usize starting_size) noexcept
    9|       |        : m_StartingAddress(start_address)
   10|  1.00k|    {
   11|  1.00k|        m_Values.resize(starting_size.get());
   12|  1.00k|    }
   13|       |
   14|       |    std::optional<phi::i8> MemoryBlock::LoadByte(phi::usize address) const noexcept
   15|      1|    {
   16|      1|        if (!IsAddressValid(address, 1u))
   17|      0|        {
   18|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   19|      0|            return {};
   20|      0|        }
   21|       |
   22|      1|        std::size_t index = (address - m_StartingAddress).get();
   23|      1|        return m_Values[index].signed_value;
   24|      1|    }
   25|       |
   26|       |    std::optional<phi::u8> MemoryBlock::LoadUnsignedByte(phi::usize address) const noexcept
   27|      2|    {
   28|      2|        if (!IsAddressValid(address, 1u))
   29|      0|        {
   30|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   31|      0|            return {};
   32|      0|        }
   33|       |
   34|      2|        std::size_t index = (address - m_StartingAddress).get();
   35|      2|        return m_Values[index].unsigned_value;
   36|      2|    }
   37|       |
   38|       |    std::optional<phi::i16> MemoryBlock::LoadHalfWord(phi::usize address) const noexcept
   39|      4|    {
   40|      4|        if (!IsAddressValid(address, 2u))
   41|      0|        {
   42|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   43|      0|            return {};
   44|      0|        }
   45|      4|        if (!IsAddressAlignedCorrectly(address, 2u))
   46|      2|        {
   47|      2|            PHI_LOG_ERROR("Address {} is misaligned", address.get());
   48|      2|            return {};
   49|      2|        }
   50|       |
   51|      2|        std::size_t index = (address - m_StartingAddress).get();
   52|      2|        return *reinterpret_cast<const std::int16_t*>(&m_Values[index].signed_value);
   53|      4|    }
   54|       |
   55|       |    std::optional<phi::u16> MemoryBlock::LoadUnsignedHalfWord(phi::usize address) const noexcept
   56|      2|    {
   57|      2|        if (!IsAddressValid(address, 2u))
   58|      0|        {
   59|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   60|      0|            return {};
   61|      0|        }
   62|      2|        if (!IsAddressAlignedCorrectly(address, 2u))
   63|      0|        {
   64|      0|            PHI_LOG_ERROR("Address {} is misaligned", address.get());
   65|      0|            return {};
   66|      0|        }
   67|       |
   68|      2|        std::size_t index = (address - m_StartingAddress).get();
   69|      2|        return *reinterpret_cast<const std::uint16_t*>(&m_Values[index].unsigned_value);
   70|      2|    }
   71|       |
   72|       |    std::optional<phi::i32> MemoryBlock::LoadWord(phi::usize address) const noexcept
   73|      5|    {
   74|      5|        if (!IsAddressValid(address, 4u))
   75|      1|        {
   76|      1|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   77|      1|            return {};
   78|      1|        }
   79|      4|        if (!IsAddressAlignedCorrectly(address, 4u))
   80|      0|        {
   81|      0|            PHI_LOG_ERROR("Address {} is misaligned", address.get());
   82|      0|            return {};
   83|      0|        }
   84|       |
   85|      4|        std::size_t index = (address - m_StartingAddress).get();
   86|      4|        return *reinterpret_cast<const std::int32_t*>(&m_Values[index].signed_value);
   87|      4|    }
   88|       |
   89|       |    std::optional<phi::u32> MemoryBlock::LoadUnsignedWord(phi::usize address) const noexcept
   90|      2|    {
   91|      2|        if (!IsAddressValid(address, 4u))
   92|      0|        {
   93|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   94|      0|            return {};
   95|      0|        }
   96|      2|        if (!IsAddressAlignedCorrectly(address, 4u))
   97|      0|        {
   98|      0|            PHI_LOG_ERROR("Address {} is misaligned", address.get());
   99|      0|            return {};
  100|      0|        }
  101|       |
  102|      2|        std::size_t index = (address - m_StartingAddress).get();
  103|      2|        return *reinterpret_cast<const std::uint32_t*>(&m_Values[index].unsigned_value);
  104|      2|    }
  105|       |
  106|       |    std::optional<phi::f32> MemoryBlock::LoadFloat(phi::usize address) const noexcept
  107|      0|    {
  108|      0|        if (!IsAddressValid(address, 4u))
  109|      0|        {
  110|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  111|      0|            return {};
  112|      0|        }
  113|       |
  114|      0|        std::size_t index = (address - m_StartingAddress).get();
  115|      0|        return *reinterpret_cast<const float*>(&m_Values[index].signed_value);
  116|      0|    }
  117|       |
  118|       |    std::optional<phi::f64> MemoryBlock::LoadDouble(phi::usize address) const noexcept
  119|      0|    {
  120|      0|        if (!IsAddressValid(address, 8u))
  121|      0|        {
  122|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  123|      0|            return {};
  124|      0|        }
  125|       |
  126|      0|        std::size_t index = (address - m_StartingAddress).get();
  127|      0|        return *reinterpret_cast<const double*>(&m_Values[(index)].signed_value);
  128|      0|    }
  129|       |
  130|       |    phi::Boolean MemoryBlock::StoreByte(phi::usize address, phi::i8 value) noexcept
  131|      2|    {
  132|      2|        if (!IsAddressValid(address, 1u))
  133|      0|        {
  134|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  135|      0|            return false;
  136|      0|        }
  137|       |
  138|      2|        m_Values[(address - m_StartingAddress).get()].signed_value = value.get();
  139|      2|        return true;
  140|      2|    }
  141|       |
  142|       |    phi::Boolean MemoryBlock::StoreUnsignedByte(phi::usize address, phi::u8 value) noexcept
  143|      2|    {
  144|      2|        if (!IsAddressValid(address, 1u))
  145|      0|        {
  146|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  147|      0|            return false;
  148|      0|        }
  149|       |
  150|      2|        m_Values[(address - m_StartingAddress).get()].unsigned_value = value.get();
  151|      2|        return true;
  152|      2|    }
  153|       |
  154|       |    phi::Boolean MemoryBlock::StoreHalfWord(phi::usize address, phi::i16 value) noexcept
  155|      2|    {
  156|      2|        if (!IsAddressValid(address, 2u))
  157|      0|        {
  158|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  159|      0|            return false;
  160|      0|        }
  161|       |
  162|      2|        std::size_t index = (address - m_StartingAddress).get();
  163|      2|        *reinterpret_cast<std::int16_t*>(&m_Values[index].signed_value) = value.get();
  164|       |
  165|      2|        return true;
  166|      2|    }
  167|       |
  168|       |    phi::Boolean MemoryBlock::StoreUnsignedHalfWord(phi::usize address, phi::u16 value) noexcept
  169|      2|    {
  170|      2|        if (!IsAddressValid(address, 2u))
  171|      0|        {
  172|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  173|      0|            return false;
  174|      0|        }
  175|       |
  176|      2|        std::size_t index = (address - m_StartingAddress).get();
  177|      2|        *reinterpret_cast<std::uint16_t*>(&m_Values[index].unsigned_value) = value.get();
  178|       |
  179|      2|        return true;
  180|      2|    }
  181|       |
  182|       |    phi::Boolean MemoryBlock::StoreWord(phi::usize address, phi::i32 value) noexcept
  183|      4|    {
  184|      4|        if (!IsAddressValid(address, 4u))
  185|      1|        {
  186|      1|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  187|      1|            return false;
  188|      1|        }
  189|       |
  190|      3|        std::size_t index = (address - m_StartingAddress).get();
  191|      3|        *reinterpret_cast<std::int32_t*>(&m_Values[index].signed_value) = value.get();
  192|       |
  193|      3|        return true;
  194|      4|    }
  195|       |
  196|       |    phi::Boolean MemoryBlock::StoreUnsignedWord(phi::usize address, phi::u32 value) noexcept
  197|      3|    {
  198|      3|        if (!IsAddressValid(address, 4u))
  199|      0|        {
  200|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  201|      0|            return false;
  202|      0|        }
  203|       |
  204|      3|        std::size_t index = (address - m_StartingAddress).get();
  205|      3|        *reinterpret_cast<std::uint32_t*>(&m_Values[index].unsigned_value) = value.get();
  206|       |
  207|      3|        return true;
  208|      3|    }
  209|       |
  210|       |    phi::Boolean MemoryBlock::StoreFloat(phi::usize address, phi::f32 value) noexcept
  211|      0|    {
  212|      0|        if (!IsAddressValid(address, 4u))
  213|      0|        {
  214|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  215|      0|            return false;
  216|      0|        }
  217|       |
  218|      0|        std::size_t index = (address - m_StartingAddress).get();
  219|      0|        *reinterpret_cast<float*>(&m_Values[index].signed_value) = value.get();
  220|       |
  221|      0|        return true;
  222|      0|    }
  223|       |
  224|       |    phi::Boolean MemoryBlock::StoreDouble(phi::usize address, phi::f64 value) noexcept
  225|      0|    {
  226|      0|        if (!IsAddressValid(address, 8u))
  227|      0|        {
  228|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  229|      0|            return false;
  230|      0|        }
  231|       |
  232|      0|        std::size_t index = (address - m_StartingAddress).get();
  233|      0|        *reinterpret_cast<double*>(&m_Values[index].signed_value) = value.get();
  234|       |
  235|      0|        return true;
  236|      0|    }
  237|       |
  238|       |    phi::Boolean MemoryBlock::IsAddressValid(phi::usize address, phi::usize size) const noexcept
  239|     31|    {
  240|     31|        return address >= m_StartingAddress &&
  241|     31|               (address + size) <= (m_StartingAddress + m_Values.size());
  242|     31|    }
  243|       |
  244|       |    phi::Boolean MemoryBlock::IsAddressAlignedCorrectly(phi::usize address,
  245|       |                                                        phi::usize size) noexcept
  246|     12|    {
  247|     12|        return (address % size) == 0u;
  248|     12|    }
  249|       |
  250|       |    void MemoryBlock::Clear() noexcept
  251|  1.00k|    {
  252|  1.00k|        for (auto& val : m_Values)
  253|  1.00M|        {
  254|  1.00M|            val.signed_value = 0;
  255|  1.00M|        }
  256|  1.00k|    }
  257|       |
  258|       |    phi::usize MemoryBlock::GetStartingAddress() const noexcept
  259|      0|    {
  260|      0|        return m_StartingAddress;
  261|      0|    }
  262|       |
  263|       |    void MemoryBlock::SetStartingAddress(phi::usize new_starting_address) noexcept
  264|      0|    {
  265|      0|        m_StartingAddress = new_starting_address;
  266|      0|    }
  267|       |
  268|       |    std::vector<MemoryBlock::MemoryByte>& MemoryBlock::GetRawMemory() noexcept
  269|      0|    {
  270|      0|        return m_Values;
  271|      0|    }
  272|       |
  273|       |    const std::vector<MemoryBlock::MemoryByte>& MemoryBlock::GetRawMemory() const noexcept
  274|      0|    {
  275|      0|        return m_Values;
  276|      0|    }
  277|       |} // namespace dlx

