/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Processor.cpp:
    1|       |#include "DLX/Processor.hpp"
    2|       |
    3|       |#include "DLX/FloatRegister.hpp"
    4|       |#include "DLX/InstructionInfo.hpp"
    5|       |#include "DLX/Parser.hpp"
    6|       |#include "DLX/RegisterNames.hpp"
    7|       |#include "DLX/StatusRegister.hpp"
    8|       |#include "Phi/Core/Log.hpp"
    9|       |#include "Phi/Core/Types.hpp"
   10|       |
   11|       |namespace dlx
   12|       |{
   13|       |    static phi::Boolean RegisterAccessTypeMatches(RegisterAccessType expected_access,
   14|       |                                                  RegisterAccessType access)
   15|   112k|    {
   16|   112k|        PHI_ASSERT(access == RegisterAccessType::Signed || access == RegisterAccessType::Unsigned ||
   17|   112k|                   access == RegisterAccessType::Float || access == RegisterAccessType::Double);
   18|   112k|
   19|   112k|        switch (expected_access)
   20|   112k|        {
   21|    436|            case RegisterAccessType::Ignored:
   22|    436|                return true;
   23|      0|            case RegisterAccessType::None:
   24|      0|                return false;
   25|      0|            case RegisterAccessType::MixedFloatDouble:
   26|      0|                return access == RegisterAccessType::Float || access == RegisterAccessType::Double;
   27|   111k|            default:
   28|   111k|                return expected_access == access;
   29|   112k|        }
   30|   112k|    }
   31|       |
   32|       |    Processor::Processor()
   33|       |        : m_MemoryBlock(1000u, 1000u)
   34|  16.5k|    {
   35|  16.5k|        // Mark R0 as ready only
   36|  16.5k|        m_IntRegisters.at(0).SetReadOnly(true);
   37|  16.5k|    }
   38|       |
   39|       |    IntRegister& Processor::GetIntRegister(IntRegisterID id)
   40|  35.7k|    {
   41|  35.7k|        PHI_ASSERT(id != IntRegisterID::None);
   42|  35.7k|        std::underlying_type_t<IntRegisterID> id_value =
   43|  35.7k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   44|  35.7k|
   45|  35.7k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   46|  35.7k|
   47|  35.7k|        return m_IntRegisters.at(id_value);
   48|  35.7k|    }
   49|       |
   50|       |    const IntRegister& Processor::GetIntRegister(IntRegisterID id) const
   51|  76.3k|    {
   52|  76.3k|        PHI_ASSERT(id != IntRegisterID::None);
   53|  76.3k|        std::underlying_type_t<IntRegisterID> id_value =
   54|  76.3k|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   55|  76.3k|
   56|  76.3k|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   57|  76.3k|
   58|  76.3k|        return m_IntRegisters.at(id_value);
   59|  76.3k|    }
   60|       |
   61|       |    phi::i32 Processor::IntRegisterGetSignedValue(IntRegisterID id) const
   62|  46.0k|    {
   63|  46.0k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   64|      6|        {
   65|      6|            PHI_LOG_WARN("Mismatch for instruction access type");
   66|      6|        }
   67|  46.0k|
   68|  46.0k|        return GetIntRegister(id).GetSignedValue();
   69|  46.0k|    }
   70|       |
   71|       |    phi::u32 Processor::IntRegisterGetUnsignedValue(IntRegisterID id) const
   72|  30.2k|    {
   73|  30.2k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
   74|  30.2k|                                       RegisterAccessType::Unsigned))
   75|      0|        {
   76|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   77|      0|        }
   78|  30.2k|
   79|  30.2k|        return GetIntRegister(id).GetUnsignedValue();
   80|  30.2k|    }
   81|       |
   82|       |    void Processor::IntRegisterSetSignedValue(IntRegisterID id, phi::i32 value)
   83|  25.5k|    {
   84|  25.5k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   85|      0|        {
   86|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   87|      0|        }
   88|  25.5k|
   89|  25.5k|        IntRegister& reg = GetIntRegister(id);
   90|  25.5k|
   91|  25.5k|        if (reg.IsReadOnly())
   92|  5.23k|        {
   93|  5.23k|            return;
   94|  5.23k|        }
   95|  20.3k|
   96|  20.3k|        reg.SetSignedValue(value);
   97|  20.3k|    }
   98|       |
   99|       |    void Processor::IntRegisterSetUnsignedValue(IntRegisterID id, phi::u32 value)
  100|  10.1k|    {
  101|  10.1k|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
  102|  10.1k|                                       RegisterAccessType::Unsigned))
  103|      0|        {
  104|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  105|      0|        }
  106|  10.1k|
  107|  10.1k|        IntRegister& reg = GetIntRegister(id);
  108|  10.1k|
  109|  10.1k|        if (reg.IsReadOnly())
  110|    137|        {
  111|    137|            return;
  112|    137|        }
  113|  10.0k|
  114|  10.0k|        reg.SetUnsignedValue(value);
  115|  10.0k|    }
  116|       |
  117|       |    FloatRegister& Processor::GetFloatRegister(FloatRegisterID id)
  118|      0|    {
  119|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  120|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  121|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  122|      0|
  123|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  124|      0|
  125|      0|        return m_FloatRegisters.at(id_value);
  126|      0|    }
  127|       |
  128|       |    const FloatRegister& Processor::GetFloatRegister(FloatRegisterID id) const
  129|      0|    {
  130|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  131|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  132|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  133|      0|
  134|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  135|      0|
  136|      0|        return m_FloatRegisters.at(id_value);
  137|      0|    }
  138|       |
  139|       |    [[nodiscard]] phi::f32 Processor::FloatRegisterGetFloatValue(FloatRegisterID id) const
  140|      0|    {
  141|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  142|      0|        {
  143|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  144|      0|        }
  145|      0|
  146|      0|        const FloatRegister& reg = GetFloatRegister(id);
  147|      0|
  148|      0|        return reg.GetValue();
  149|      0|    }
  150|       |
  151|       |    [[nodiscard]] phi::f64 Processor::FloatRegisterGetDoubleValue(FloatRegisterID id)
  152|      0|    {
  153|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  154|      0|        {
  155|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  156|      0|        }
  157|      0|
  158|      0|        if (id == FloatRegisterID::F31)
  159|      0|        {
  160|      0|            Raise(Exception::RegisterOutOfBounds);
  161|      0|            return phi::f64(0.0);
  162|      0|        }
  163|      0|
  164|      0|        const FloatRegister& first_reg = GetFloatRegister(id);
  165|      0|        const FloatRegister& second_reg =
  166|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  167|      0|
  168|      0|        const float first_value  = first_reg.GetValue().get();
  169|      0|        const float second_value = second_reg.GetValue().get();
  170|      0|
  171|      0|        const std::uint32_t first_value_bits =
  172|      0|                *reinterpret_cast<const std::uint32_t*>(&first_value);
  173|      0|        const std::uint32_t second_value_bits =
  174|      0|                *reinterpret_cast<const std::uint32_t*>(&second_value);
  175|      0|
  176|      0|        std::uint64_t final_value_bits =
  177|      0|                static_cast<std::uint64_t>(second_value_bits) << 32u | first_value_bits;
  178|      0|
  179|      0|        return *reinterpret_cast<double*>(&final_value_bits);
  180|      0|    }
  181|       |
  182|       |    void Processor::FloatRegisterSetFloatValue(FloatRegisterID id, phi::f32 value)
  183|      0|    {
  184|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  185|      0|        {
  186|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  187|      0|        }
  188|      0|
  189|      0|        FloatRegister& reg = GetFloatRegister(id);
  190|      0|
  191|      0|        reg.SetValue(value);
  192|      0|    }
  193|       |
  194|       |    void Processor::FloatRegisterSetDoubleValue(FloatRegisterID id, phi::f64 value)
  195|      0|    {
  196|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  197|      0|        {
  198|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  199|      0|        }
  200|      0|
  201|      0|        if (id == FloatRegisterID::F31)
  202|      0|        {
  203|      0|            Raise(Exception::RegisterOutOfBounds);
  204|      0|            return;
  205|      0|        }
  206|      0|
  207|      0|        const constexpr std::uint64_t first_32_bits  = 0b11111111'11111111'11111111'11111111;
  208|      0|        const constexpr std::uint64_t second_32_bits = first_32_bits << 32u;
  209|      0|
  210|      0|        double              value_raw  = value.get();
  211|      0|        const std::uint64_t value_bits = *reinterpret_cast<std::uint64_t*>(&value_raw);
  212|      0|
  213|      0|        const std::uint32_t first_bits  = value_bits & first_32_bits;
  214|      0|        const std::uint32_t second_bits = (value_bits & second_32_bits) >> 32u;
  215|      0|
  216|      0|        const float first_value  = *reinterpret_cast<const float*>(&first_bits);
  217|      0|        const float second_value = *reinterpret_cast<const float*>(&second_bits);
  218|      0|
  219|      0|        FloatRegister& first_reg = GetFloatRegister(id);
  220|      0|        FloatRegister& second_reg =
  221|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  222|      0|
  223|      0|        first_reg.SetValue(first_value);
  224|      0|        second_reg.SetValue(second_value);
  225|      0|    }
  226|       |
  227|       |    StatusRegister& Processor::GetFPSR()
  228|      0|    {
  229|      0|        return m_FPSR;
  230|      0|    }
  231|       |
  232|       |    const StatusRegister& Processor::GetFPSR() const
  233|      0|    {
  234|      0|        return m_FPSR;
  235|      0|    }
  236|       |
  237|       |    phi::Boolean Processor::GetFPSRValue() const
  238|      0|    {
  239|      0|        const StatusRegister& status_reg = GetFPSR();
  240|      0|
  241|      0|        return status_reg.Get();
  242|      0|    }
  243|       |
  244|       |    void Processor::SetFPSRValue(phi::Boolean value)
  245|      0|    {
  246|      0|        StatusRegister& status_reg = GetFPSR();
  247|      0|
  248|      0|        status_reg.SetStatus(value);
  249|      0|    }
  250|       |
  251|       |    void Processor::ExecuteInstruction(const Instruction& inst)
  252|   140k|    {
  253|   140k|        m_CurrentInstructionAccessType = inst.GetInfo().GetRegisterAccessType();
  254|   140k|
  255|   140k|        inst.Execute(*this);
  256|   140k|    }
  257|       |
  258|       |    void Processor::LoadProgram(ParsedProgram& programm)
  259|  16.5k|    {
  260|  16.5k|        m_CurrentProgram = &programm;
  261|  16.5k|
  262|  16.5k|        m_ProgramCounter               = 0u;
  263|  16.5k|        m_Halted                       = false;
  264|  16.5k|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  265|  16.5k|    }
  266|       |
  267|       |    phi::ObserverPtr<ParsedProgram> Processor::GetCurrentProgramm() const noexcept
  268|   110k|    {
  269|   110k|        return m_CurrentProgram;
  270|   110k|    }
  271|       |
  272|       |    void Processor::ExecuteCurrentProgram()
  273|  16.5k|    {
  274|  16.5k|        PHI_ASSERT(m_CurrentProgram);
  275|  16.5k|
  276|  16.5k|        // Don't execute a program with parsing errors
  277|  16.5k|        if (!m_CurrentProgram->m_ParseErrors.empty())
  278|  15.4k|        {
  279|  15.4k|            return;
  280|  15.4k|        }
  281|  1.04k|
  282|  1.04k|        m_ProgramCounter      = 0u;
  283|  1.04k|        m_Halted              = false;
  284|  1.04k|        m_LastRaisedException = Exception::None;
  285|  1.04k|
  286|  1.04k|        phi::usize StepCount{0u};
  287|  1.04k|
  288|   141k|        while (m_ProgramCounter < m_CurrentProgram->m_Instructions.size() && !m_Halted &&
  289|   141k|               (m_MaxNumberOfSteps != 0u && StepCount < m_MaxNumberOfSteps))
  290|   140k|        {
  291|   140k|            m_NextProgramCounter = m_ProgramCounter + 1u;
  292|   140k|
  293|   140k|            const auto& current_instruction =
  294|   140k|                    m_CurrentProgram->m_Instructions.at(m_ProgramCounter.get());
  295|   140k|            ExecuteInstruction(current_instruction);
  296|   140k|
  297|   140k|            m_ProgramCounter = m_NextProgramCounter;
  298|   140k|
  299|   140k|            ++StepCount;
  300|   140k|        }
  301|  1.04k|    }
  302|       |
  303|       |    void Processor::ClearRegisters()
  304|  16.5k|    {
  305|  16.5k|        for (auto& reg : m_IntRegisters)
  306|   528k|        {
  307|   528k|            reg.SetSignedValue(0);
  308|   528k|        }
  309|  16.5k|
  310|  16.5k|        for (auto& reg : m_FloatRegisters)
  311|   528k|        {
  312|   528k|            reg.SetValue(0.0f);
  313|   528k|        }
  314|  16.5k|
  315|  16.5k|        m_FPSR.SetStatus(false);
  316|  16.5k|    }
  317|       |
  318|       |    void Processor::ClearMemory()
  319|  16.5k|    {
  320|  16.5k|        m_MemoryBlock.Clear();
  321|  16.5k|    }
  322|       |
  323|       |    void Processor::Raise(Exception exception)
  324|    111|    {
  325|    111|        PHI_ASSERT(exception != Exception::None, "Cannot raise None exception");
  326|    111|
  327|    111|        m_LastRaisedException = exception;
  328|    111|
  329|    111|        switch (exception)
  330|    111|        {
  331|      0|            case Exception::None:
  332|      0|                PHI_ASSERT_NOT_REACHED();
  333|      0|                return;
  334|     68|            case Exception::DivideByZero:
  335|     68|                m_Halted = true;
  336|     68|                PHI_LOG_ERROR("Division through zero");
  337|     68|                return;
  338|      0|            case Exception::Overflow:
  339|      0|                PHI_LOG_WARN("Overflow");
  340|      0|                return;
  341|      1|            case Exception::Underflow:
  342|      1|                PHI_LOG_WARN("Underflow");
  343|      1|                return;
  344|      1|            case Exception::Trap:
  345|      1|                m_Halted = true;
  346|      1|                PHI_LOG_ERROR("Trapped");
  347|      1|                return;
  348|      1|            case Exception::Halt:
  349|      1|                m_Halted = true;
  350|      1|                return;
  351|     24|            case Exception::UnknownLabel:
  352|     24|                m_Halted = true;
  353|     24|                PHI_LOG_ERROR("Unknown label");
  354|     24|                return;
  355|      8|            case Exception::BadShift:
  356|      8|                PHI_LOG_ERROR("Bad shift");
  357|      8|                return;
  358|      8|            case Exception::AddressOutOfBounds:
  359|      8|                PHI_LOG_ERROR("Address out of bounds");
  360|      8|                m_Halted = true;
  361|      8|                return;
  362|      0|            case Exception::RegisterOutOfBounds:
  363|      0|                PHI_LOG_ERROR("Register out of bounds");
  364|      0|                m_Halted = true;
  365|      0|                return;
  366|      0|        }
  367|      0|
  368|      0|        PHI_ASSERT_NOT_REACHED();
  369|      0|    }
  370|       |
  371|       |    Exception Processor::GetLastRaisedException() const noexcept
  372|      0|    {
  373|      0|        return m_LastRaisedException;
  374|      0|    }
  375|       |
  376|       |    [[nodiscard]] phi::Boolean Processor::IsHalted() const noexcept
  377|      0|    {
  378|      0|        return m_Halted;
  379|      0|    }
  380|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/RegisterNames.cpp:
    1|       |#include "DLX/RegisterNames.hpp"
    2|       |
    3|       |#include "DLX/Containers/LookUpMap.hpp"
    4|       |#include <algorithm>
    5|       |#include <cctype>
    6|       |#include <string_view>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    static constexpr std::array<std::pair<std::string_view, IntRegisterID>, 32> IntRegisterValues{
   11|       |            {{"R0", IntRegisterID::R0},   {"R1", IntRegisterID::R1},   {"R2", IntRegisterID::R2},
   12|       |             {"R3", IntRegisterID::R3},   {"R4", IntRegisterID::R4},   {"R5", IntRegisterID::R5},
   13|       |             {"R6", IntRegisterID::R6},   {"R7", IntRegisterID::R7},   {"R8", IntRegisterID::R8},
   14|       |             {"R9", IntRegisterID::R9},   {"R10", IntRegisterID::R10}, {"R11", IntRegisterID::R11},
   15|       |             {"R12", IntRegisterID::R12}, {"R13", IntRegisterID::R13}, {"R14", IntRegisterID::R14},
   16|       |             {"R15", IntRegisterID::R15}, {"R16", IntRegisterID::R16}, {"R17", IntRegisterID::R17},
   17|       |             {"R18", IntRegisterID::R18}, {"R19", IntRegisterID::R19}, {"R20", IntRegisterID::R20},
   18|       |             {"R21", IntRegisterID::R21}, {"R22", IntRegisterID::R22}, {"R23", IntRegisterID::R23},
   19|       |             {"R24", IntRegisterID::R24}, {"R25", IntRegisterID::R25}, {"R26", IntRegisterID::R26},
   20|       |             {"R27", IntRegisterID::R27}, {"R28", IntRegisterID::R28}, {"R29", IntRegisterID::R29},
   21|       |             {"R30", IntRegisterID::R30}, {"R31", IntRegisterID::R31}}};
   22|       |
   23|       |    static constexpr std::array<std::pair<std::string_view, FloatRegisterID>, 32>
   24|       |            FloatRegisterValues{{{"F0", FloatRegisterID::F0},   {"F1", FloatRegisterID::F1},
   25|       |                                 {"F2", FloatRegisterID::F2},   {"F3", FloatRegisterID::F3},
   26|       |                                 {"F4", FloatRegisterID::F4},   {"F5", FloatRegisterID::F5},
   27|       |                                 {"F6", FloatRegisterID::F6},   {"F7", FloatRegisterID::F7},
   28|       |                                 {"F8", FloatRegisterID::F8},   {"F9", FloatRegisterID::F9},
   29|       |                                 {"F10", FloatRegisterID::F10}, {"F11", FloatRegisterID::F11},
   30|       |                                 {"F12", FloatRegisterID::F12}, {"F13", FloatRegisterID::F13},
   31|       |                                 {"F14", FloatRegisterID::F14}, {"F15", FloatRegisterID::F15},
   32|       |                                 {"F16", FloatRegisterID::F16}, {"F17", FloatRegisterID::F17},
   33|       |                                 {"F18", FloatRegisterID::F18}, {"F19", FloatRegisterID::F19},
   34|       |                                 {"F20", FloatRegisterID::F20}, {"F21", FloatRegisterID::F21},
   35|       |                                 {"F22", FloatRegisterID::F22}, {"F23", FloatRegisterID::F23},
   36|       |                                 {"F24", FloatRegisterID::F24}, {"F25", FloatRegisterID::F25},
   37|       |                                 {"F26", FloatRegisterID::F26}, {"F27", FloatRegisterID::F27},
   38|       |                                 {"F28", FloatRegisterID::F28}, {"F29", FloatRegisterID::F29},
   39|       |                                 {"F30", FloatRegisterID::F30}, {"F31", FloatRegisterID::F31}}};
   40|       |
   41|       |    IntRegisterID StringToIntRegister(std::string_view token)
   42|  1.26M|    {
   43|  1.26M|        static constexpr auto map =
   44|  1.26M|                LookUpMap<std::string_view, IntRegisterID, IntRegisterValues.size()>(
   45|  1.26M|                        IntRegisterValues, IntRegisterID::None);
   46|  1.26M|
   47|  1.26M|        return map.at(token);
   48|  1.26M|    }
   49|       |
   50|       |    FloatRegisterID StringToFloatRegister(std::string_view token)
   51|  1.08M|    {
   52|  1.08M|        static constexpr auto map =
   53|  1.08M|                LookUpMap<std::string_view, FloatRegisterID, FloatRegisterValues.size()>(
   54|  1.08M|                        FloatRegisterValues, FloatRegisterID::None);
   55|  1.08M|
   56|  1.08M|        return map.at(token);
   57|  1.08M|    }
   58|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionLibrary.cpp:
    1|       |#include "DLX/InstructionLibrary.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionImplementation.hpp"
    5|       |#include "DLX/InstructionInfo.hpp"
    6|       |#include <magic_enum.hpp>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    InstructionLibrary::InstructionLibrary()
   11|       |        : m_Instructions()
   12|  16.5k|    {
   13|  16.5k|        PHI_ASSERT(Initialize());
   14|  16.5k|    }
   15|       |
   16|       |    phi::Boolean InstructionLibrary::Initialize()
   17|  16.5k|    {
   18|  16.5k|        /* Arithmetic */
   19|  16.5k|
   20|  16.5k|        // Addition
   21|  16.5k|        InitInstruction(OpCode::ADD, ArgumentType::IntRegister, ArgumentType::IntRegister,
   22|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::ADD);
   23|  16.5k|        InitInstruction(OpCode::ADDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   24|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::ADDI);
   25|  16.5k|        InitInstruction(OpCode::ADDU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   26|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::ADDU);
   27|  16.5k|        InitInstruction(OpCode::ADDUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   28|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::ADDUI);
   29|  16.5k|        InitInstruction(OpCode::ADDF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   30|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::ADDF);
   31|  16.5k|        InitInstruction(OpCode::ADDD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   32|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::ADDD);
   33|  16.5k|
   34|  16.5k|        // Subtraction
   35|  16.5k|        InitInstruction(OpCode::SUB, ArgumentType::IntRegister, ArgumentType::IntRegister,
   36|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SUB);
   37|  16.5k|        InitInstruction(OpCode::SUBI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   38|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SUBI);
   39|  16.5k|        InitInstruction(OpCode::SUBU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   40|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SUBU);
   41|  16.5k|        InitInstruction(OpCode::SUBUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   42|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SUBUI);
   43|  16.5k|        InitInstruction(OpCode::SUBF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   44|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::SUBF);
   45|  16.5k|        InitInstruction(OpCode::SUBD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   46|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::SUBD);
   47|  16.5k|
   48|  16.5k|        // Multiplikation
   49|  16.5k|        InitInstruction(OpCode::MULT, ArgumentType::IntRegister, ArgumentType::IntRegister,
   50|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::MULT);
   51|  16.5k|        InitInstruction(OpCode::MULTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   52|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::MULTI);
   53|  16.5k|        InitInstruction(OpCode::MULTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   54|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::MULTU);
   55|  16.5k|        InitInstruction(OpCode::MULTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   56|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::MULTUI);
   57|  16.5k|        InitInstruction(OpCode::MULTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   58|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::MULTF);
   59|  16.5k|        InitInstruction(OpCode::MULTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   60|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::MULTD);
   61|  16.5k|
   62|  16.5k|        // Division
   63|  16.5k|        InitInstruction(OpCode::DIV, ArgumentType::IntRegister, ArgumentType::IntRegister,
   64|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::DIV);
   65|  16.5k|        InitInstruction(OpCode::DIVI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   66|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::DIVI);
   67|  16.5k|        InitInstruction(OpCode::DIVU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   68|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::DIVU);
   69|  16.5k|        InitInstruction(OpCode::DIVUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   70|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::DIVUI);
   71|  16.5k|        InitInstruction(OpCode::DIVF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   72|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::DIVF);
   73|  16.5k|        InitInstruction(OpCode::DIVD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   74|  16.5k|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::DIVD);
   75|  16.5k|
   76|  16.5k|        // Shift left logical
   77|  16.5k|        InitInstruction(OpCode::SLL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   78|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLL);
   79|  16.5k|        InitInstruction(OpCode::SLLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   80|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLLI);
   81|  16.5k|
   82|  16.5k|        // Shift right logical
   83|  16.5k|        InitInstruction(OpCode::SRL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   84|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRL);
   85|  16.5k|        InitInstruction(OpCode::SRLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   86|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRLI);
   87|  16.5k|
   88|  16.5k|        // Shift left arithmetic
   89|  16.5k|        InitInstruction(OpCode::SLA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   90|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLA);
   91|  16.5k|        InitInstruction(OpCode::SLAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   92|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLAI);
   93|  16.5k|
   94|  16.5k|        // Shift right arithmetic
   95|  16.5k|        InitInstruction(OpCode::SRA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   96|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRA);
   97|  16.5k|        InitInstruction(OpCode::SRAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   98|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRAI);
   99|  16.5k|
  100|  16.5k|        /* Logical */
  101|  16.5k|
  102|  16.5k|        // And
  103|  16.5k|        InitInstruction(OpCode::AND, ArgumentType::IntRegister, ArgumentType::IntRegister,
  104|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::AND);
  105|  16.5k|        InitInstruction(OpCode::ANDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  106|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ANDI);
  107|  16.5k|
  108|  16.5k|        // Or
  109|  16.5k|        InitInstruction(OpCode::OR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  110|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::OR);
  111|  16.5k|        InitInstruction(OpCode::ORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  112|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ORI);
  113|  16.5k|
  114|  16.5k|        // Xor
  115|  16.5k|        InitInstruction(OpCode::XOR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  116|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::XOR);
  117|  16.5k|        InitInstruction(OpCode::XORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  118|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::XORI);
  119|  16.5k|
  120|  16.5k|        /* Conditionals */
  121|  16.5k|
  122|  16.5k|        // Set less than
  123|  16.5k|        InitInstruction(OpCode::SLT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  124|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SLT);
  125|  16.5k|        InitInstruction(OpCode::SLTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  126|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SLTI);
  127|  16.5k|        InitInstruction(OpCode::SLTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  128|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SLTU);
  129|  16.5k|        InitInstruction(OpCode::SLTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  130|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SLTUI);
  131|  16.5k|        InitInstruction(OpCode::LTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  132|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::LTF);
  133|  16.5k|        InitInstruction(OpCode::LTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  134|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::LTD);
  135|  16.5k|
  136|  16.5k|        // Set greater than
  137|  16.5k|        InitInstruction(OpCode::SGT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  138|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SGT);
  139|  16.5k|        InitInstruction(OpCode::SGTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  140|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SGTI);
  141|  16.5k|        InitInstruction(OpCode::SGTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  142|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SGTU);
  143|  16.5k|        InitInstruction(OpCode::SGTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  144|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SGTUI);
  145|  16.5k|        InitInstruction(OpCode::GTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  146|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::GTF);
  147|  16.5k|        InitInstruction(OpCode::GTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  148|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::GTD);
  149|  16.5k|
  150|  16.5k|        // Set less than or equal
  151|  16.5k|        InitInstruction(OpCode::SLE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  152|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SLE);
  153|  16.5k|        InitInstruction(OpCode::SLEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  154|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SLEI);
  155|  16.5k|        InitInstruction(OpCode::SLEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  156|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SLEU);
  157|  16.5k|        InitInstruction(OpCode::SLEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  158|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SLEUI);
  159|  16.5k|        InitInstruction(OpCode::LEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  160|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::LEF);
  161|  16.5k|        InitInstruction(OpCode::LED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  162|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::LED);
  163|  16.5k|
  164|  16.5k|        // Set greater than or equal
  165|  16.5k|        InitInstruction(OpCode::SGE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  166|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SGE);
  167|  16.5k|        InitInstruction(OpCode::SGEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  168|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SGEI);
  169|  16.5k|        InitInstruction(OpCode::SGEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  170|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SGEU);
  171|  16.5k|        InitInstruction(OpCode::SGEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  172|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SGEUI);
  173|  16.5k|        InitInstruction(OpCode::GEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  174|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::GEF);
  175|  16.5k|        InitInstruction(OpCode::GED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  176|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::GED);
  177|  16.5k|
  178|  16.5k|        // Set equal
  179|  16.5k|        InitInstruction(OpCode::SEQ, ArgumentType::IntRegister, ArgumentType::IntRegister,
  180|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SEQ);
  181|  16.5k|        InitInstruction(OpCode::SEQI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  182|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SEQI);
  183|  16.5k|        InitInstruction(OpCode::SEQU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  184|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SEQU);
  185|  16.5k|        InitInstruction(OpCode::SEQUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  186|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SEQUI);
  187|  16.5k|        InitInstruction(OpCode::EQF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  188|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::EQF);
  189|  16.5k|        InitInstruction(OpCode::EQD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  190|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::EQD);
  191|  16.5k|
  192|  16.5k|        // Set not equal
  193|  16.5k|        InitInstruction(OpCode::SNE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  194|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SNE);
  195|  16.5k|        InitInstruction(OpCode::SNEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  196|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SNEI);
  197|  16.5k|        InitInstruction(OpCode::SNEU, ArgumentType::IntRegister, ArgumentType::IntRegister,
  198|  16.5k|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SNEU);
  199|  16.5k|        InitInstruction(OpCode::SNEUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  200|  16.5k|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SNEUI);
  201|  16.5k|        InitInstruction(OpCode::NEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  202|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::NEF);
  203|  16.5k|        InitInstruction(OpCode::NED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  204|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::NED);
  205|  16.5k|
  206|  16.5k|        /* Conditional branching */
  207|  16.5k|
  208|  16.5k|        // Branch equal zero
  209|  16.5k|        InitInstruction(OpCode::BEQZ, ArgumentType::IntRegister, ArgumentType::Label,
  210|  16.5k|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BEQZ);
  211|  16.5k|
  212|  16.5k|        // Branch not equal zero
  213|  16.5k|        InitInstruction(OpCode::BNEZ, ArgumentType::IntRegister, ArgumentType::Label,
  214|  16.5k|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BNEZ);
  215|  16.5k|
  216|  16.5k|        // Branch floating point true
  217|  16.5k|        InitInstruction(OpCode::BFPT, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  218|  16.5k|                        RegisterAccessType::Ignored, impl::BFPT);
  219|  16.5k|
  220|  16.5k|        // Branch floating point false
  221|  16.5k|        InitInstruction(OpCode::BFPF, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  222|  16.5k|                        RegisterAccessType::Ignored, impl::BFPF);
  223|  16.5k|
  224|  16.5k|        /* Unconditional branching */
  225|  16.5k|
  226|  16.5k|        // Jump
  227|  16.5k|        InitInstruction(OpCode::J, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  228|  16.5k|                        RegisterAccessType::None, impl::J);
  229|  16.5k|
  230|  16.5k|        // Jump to register
  231|  16.5k|        InitInstruction(OpCode::JR, ArgumentType::IntRegister, ArgumentType::None,
  232|  16.5k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JR);
  233|  16.5k|
  234|  16.5k|        // Jump and link
  235|  16.5k|        InitInstruction(OpCode::JAL, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  236|  16.5k|                        RegisterAccessType::Unsigned, impl::JAL);
  237|  16.5k|
  238|  16.5k|        // Jump and link to register
  239|  16.5k|        InitInstruction(OpCode::JALR, ArgumentType::IntRegister, ArgumentType::None,
  240|  16.5k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JALR);
  241|  16.5k|
  242|  16.5k|        /* Loading data */
  243|  16.5k|
  244|  16.5k|        // Load high immediate
  245|  16.5k|        InitInstruction(OpCode::LHI, ArgumentType::IntRegister, ArgumentType::ImmediateInteger,
  246|  16.5k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LHI);
  247|  16.5k|
  248|  16.5k|        // Load byte
  249|  16.5k|        InitInstruction(OpCode::LB, ArgumentType::IntRegister,
  250|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  251|  16.5k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LB);
  252|  16.5k|
  253|  16.5k|        // Load byte unsigned
  254|  16.5k|        InitInstruction(OpCode::LBU, ArgumentType::IntRegister,
  255|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  256|  16.5k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LBU);
  257|  16.5k|
  258|  16.5k|        // Load half word
  259|  16.5k|        InitInstruction(OpCode::LH, ArgumentType::IntRegister,
  260|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  261|  16.5k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LH);
  262|  16.5k|
  263|  16.5k|        // Load half word unsigned
  264|  16.5k|        InitInstruction(OpCode::LHU, ArgumentType::IntRegister,
  265|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  266|  16.5k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LHU);
  267|  16.5k|
  268|  16.5k|        // Load word
  269|  16.5k|        InitInstruction(OpCode::LW, ArgumentType::IntRegister,
  270|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  271|  16.5k|                        ArgumentType::None, RegisterAccessType::Signed, impl::LW);
  272|  16.5k|
  273|  16.5k|        // Load word unsigned
  274|  16.5k|        InitInstruction(OpCode::LWU, ArgumentType::IntRegister,
  275|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  276|  16.5k|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LWU);
  277|  16.5k|
  278|  16.5k|        // Load float
  279|  16.5k|        InitInstruction(OpCode::LF, ArgumentType::FloatRegister,
  280|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  281|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::LF);
  282|  16.5k|
  283|  16.5k|        // Load double
  284|  16.5k|        InitInstruction(OpCode::LD, ArgumentType::FloatRegister,
  285|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  286|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::LD);
  287|  16.5k|
  288|  16.5k|        /* Storing data */
  289|  16.5k|
  290|  16.5k|        // Store byte
  291|  16.5k|        InitInstruction(OpCode::SB,
  292|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  293|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  294|  16.5k|                        impl::SB);
  295|  16.5k|
  296|  16.5k|        // Store byte unsigned
  297|  16.5k|        InitInstruction(OpCode::SBU,
  298|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  299|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  300|  16.5k|                        impl::SBU);
  301|  16.5k|
  302|  16.5k|        // Store half word
  303|  16.5k|        InitInstruction(OpCode::SH,
  304|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  305|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  306|  16.5k|                        impl::SH);
  307|  16.5k|
  308|  16.5k|        // Store half word unsigned
  309|  16.5k|        InitInstruction(OpCode::SHU,
  310|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  311|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  312|  16.5k|                        impl::SHU);
  313|  16.5k|
  314|  16.5k|        // Store word
  315|  16.5k|        InitInstruction(OpCode::SW,
  316|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  317|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  318|  16.5k|                        impl::SW);
  319|  16.5k|
  320|  16.5k|        // Store word unsigned
  321|  16.5k|        InitInstruction(OpCode::SWU,
  322|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  323|  16.5k|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  324|  16.5k|                        impl::SWU);
  325|  16.5k|
  326|  16.5k|        // Store float
  327|  16.5k|        InitInstruction(OpCode::SF,
  328|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  329|  16.5k|                        ArgumentType::FloatRegister, ArgumentType::None, RegisterAccessType::Float,
  330|  16.5k|                        impl::SF);
  331|  16.5k|
  332|  16.5k|        // Store double
  333|  16.5k|        InitInstruction(OpCode::SD,
  334|  16.5k|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  335|  16.5k|                        ArgumentType::FloatRegister, ArgumentType::None, RegisterAccessType::Double,
  336|  16.5k|                        impl::SD);
  337|  16.5k|
  338|  16.5k|        /* Moving data */
  339|  16.5k|
  340|  16.5k|        // Move float
  341|  16.5k|        InitInstruction(OpCode::MOVF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  342|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVF);
  343|  16.5k|
  344|  16.5k|        // Move double
  345|  16.5k|        InitInstruction(OpCode::MOVD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  346|  16.5k|                        ArgumentType::None, RegisterAccessType::Double, impl::MOVD);
  347|  16.5k|
  348|  16.5k|        // Move float to int
  349|  16.5k|        InitInstruction(OpCode::MOVFP2I, ArgumentType::IntRegister, ArgumentType::FloatRegister,
  350|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVFP2I);
  351|  16.5k|
  352|  16.5k|        // Move int to float
  353|  16.5k|        InitInstruction(OpCode::MOVI2FP, ArgumentType::FloatRegister, ArgumentType::IntRegister,
  354|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::MOVI2FP);
  355|  16.5k|
  356|  16.5k|        /* Converting data */
  357|  16.5k|
  358|  16.5k|        // Convert float to double
  359|  16.5k|        InitInstruction(OpCode::CVTF2D, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  360|  16.5k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTF2D);
  361|  16.5k|
  362|  16.5k|        // Convert float to int
  363|  16.5k|        InitInstruction(OpCode::CVTF2I, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  364|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::CVTF2I);
  365|  16.5k|
  366|  16.5k|        // Convert double to float
  367|  16.5k|        InitInstruction(OpCode::CVTD2F, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  368|  16.5k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTD2F);
  369|  16.5k|
  370|  16.5k|        // Convert double to int
  371|  16.5k|        InitInstruction(OpCode::CVTD2I, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  372|  16.5k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTD2I);
  373|  16.5k|
  374|  16.5k|        // Convert int to float
  375|  16.5k|        InitInstruction(OpCode::CVTI2F, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  376|  16.5k|                        ArgumentType::None, RegisterAccessType::Float, impl::CVTI2F);
  377|  16.5k|
  378|  16.5k|        // Convert int to double
  379|  16.5k|        InitInstruction(OpCode::CVTI2D, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  380|  16.5k|                        ArgumentType::None, RegisterAccessType::MixedFloatDouble, impl::CVTI2D);
  381|  16.5k|
  382|  16.5k|        /* Special */
  383|  16.5k|
  384|  16.5k|        // Trap
  385|  16.5k|        InitInstruction(OpCode::TRAP, ArgumentType::ImmediateInteger, ArgumentType::None,
  386|  16.5k|                        ArgumentType::None, RegisterAccessType::None, impl::TRAP);
  387|  16.5k|
  388|  16.5k|        // Halt
  389|  16.5k|        InitInstruction(OpCode::HALT, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  390|  16.5k|                        RegisterAccessType::None, impl::HALT);
  391|  16.5k|
  392|  16.5k|        // No operation
  393|  16.5k|        InitInstruction(OpCode::NOP, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  394|  16.5k|                        RegisterAccessType::None, impl::NOP);
  395|  16.5k|
  396|  16.5k|        return true;
  397|  16.5k|    }
  398|       |
  399|       |    const InstructionInfo& InstructionLibrary::LookUp(OpCode instruction) const noexcept
  400|  1.92M|    {
  401|  1.92M|        return m_Instructions.at(static_cast<std::size_t>(instruction));
  402|  1.92M|    }
  403|       |
  404|       |    void InstructionLibrary::InitInstruction(OpCode opcode, ArgumentType arg1, ArgumentType arg2,
  405|       |                                             ArgumentType        arg3,
  406|       |                                             RegisterAccessType  register_access_type,
  407|       |                                             InstructionExecutor executor)
  408|  1.85M|    {
  409|  1.85M|        PHI_ASSERT(LookUp(opcode).GetExecutor() == nullptr, "Already registered instruction {}",
  410|  1.85M|                   magic_enum::enum_name(opcode));
  411|  1.85M|
  412|  1.85M|        m_Instructions.at(static_cast<std::size_t>(opcode)) =
  413|  1.85M|                InstructionInfo(opcode, arg1, arg2, arg3, register_access_type, executor);
  414|  1.85M|    }
  415|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/StatusRegister.cpp:
    1|       |#include "DLX/StatusRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void StatusRegister::SetStatus(phi::Boolean value)
    6|  16.5k|    {
    7|  16.5k|        m_Value = value;
    8|  16.5k|    }
    9|       |
   10|       |    phi::Boolean StatusRegister::Get() const
   11|      0|    {
   12|      0|        return m_Value;
   13|      0|    }
   14|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/IntRegister.cpp:
    1|       |#include "DLX/IntRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    IntRegister::IntRegister()
    6|       |        : m_ValueSigned{0}
    7|       |        , m_IsReadOnly{false}
    8|   528k|    {}
    9|       |
   10|       |    void IntRegister::SetSignedValue(phi::i32 val)
   11|   549k|    {
   12|   549k|        m_ValueSigned = val;
   13|   549k|    }
   14|       |
   15|       |    void IntRegister::SetUnsignedValue(phi::u32 val)
   16|  10.0k|    {
   17|  10.0k|        m_ValueUnsigned = val;
   18|  10.0k|    }
   19|       |
   20|       |    phi::i32 IntRegister::GetSignedValue() const
   21|  46.0k|    {
   22|  46.0k|        return m_ValueSigned;
   23|  46.0k|    }
   24|       |
   25|       |    phi::u32 IntRegister::GetUnsignedValue() const
   26|  30.2k|    {
   27|  30.2k|        return m_ValueUnsigned;
   28|  30.2k|    }
   29|       |
   30|       |    phi::Boolean IntRegister::IsReadOnly() const
   31|  35.7k|    {
   32|  35.7k|        return m_IsReadOnly;
   33|  35.7k|    }
   34|       |
   35|       |    void IntRegister::SetReadOnly(phi::Boolean read_only)
   36|  16.5k|    {
   37|  16.5k|        m_IsReadOnly = read_only;
   38|  16.5k|    }
   39|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionInfo.cpp:
    1|       |#include "DLX/InstructionInfo.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void InstructionInfo::Execute(Processor& processor, const InstructionArg& arg1,
    6|       |                                  const InstructionArg& arg2,
    7|       |                                  const InstructionArg& arg3) const noexcept
    8|   140k|    {
    9|   140k|        PHI_ASSERT(m_Executor, "No execution function defined");
   10|   140k|
   11|   140k|        m_Executor(processor, arg1, arg2, arg3);
   12|   140k|    }
   13|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionImplementation.cpp:
    1|       |#include "DLX/InstructionImplementation.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionInfo.hpp"
    5|       |#include "DLX/Parser.hpp"
    6|       |#include "DLX/Processor.hpp"
    7|       |#include "DLX/RegisterNames.hpp"
    8|       |#include "Phi/Core/Assert.hpp"
    9|       |#include "Phi/Core/Boolean.hpp"
   10|       |#include "Phi/Core/Types.hpp"
   11|       |#include <string_view>
   12|       |
   13|       |namespace dlx
   14|       |{
   15|       |    static std::int32_t clear_top_n_bits(std::int32_t value, std::int32_t n)
   16|     20|    {
   17|     20|        PHI_ASSERT(n > 0 && n < 32, "Would invoke undefined behaviour");
   18|     20|
   19|     20|        return value & ~(-1 << (32 - n));
   20|     20|    }
   21|       |
   22|       |    static void JumpToLabel(Processor& processor, std::string_view label_name)
   23|  80.0k|    {
   24|  80.0k|        // Lookup the label
   25|  80.0k|        const phi::ObserverPtr<ParsedProgram> program = processor.GetCurrentProgramm();
   26|  80.0k|        PHI_ASSERT(program);
   27|  80.0k|
   28|  80.0k|        std::string label(label_name.data(), label_name.size());
   29|  80.0k|        if (program->m_JumpData.find(label) == program->m_JumpData.end())
   30|     24|        {
   31|     24|            PHI_LOG_ERROR("Unable to find jump label {}", label_name);
   32|     24|            processor.Raise(Exception::UnknownLabel);
   33|     24|            return;
   34|     24|        }
   35|  80.0k|
   36|  80.0k|        // Set program counter
   37|  80.0k|        processor.m_NextProgramCounter = program->m_JumpData.at(label);
   38|  80.0k|    }
   39|       |
   40|       |    static void JumpToRegister(Processor& processor, IntRegisterID reg_id)
   41|  30.0k|    {
   42|  30.0k|        phi::u32 address = processor.IntRegisterGetUnsignedValue(reg_id);
   43|  30.0k|
   44|  30.0k|        phi::u32 max_address =
   45|  30.0k|                static_cast<std::uint32_t>(processor.GetCurrentProgramm()->m_Instructions.size());
   46|  30.0k|        if (address >= max_address)
   47|      0|        {
   48|      0|            processor.Raise(Exception::AddressOutOfBounds);
   49|      0|            return;
   50|      0|        }
   51|  30.0k|
   52|  30.0k|        processor.m_NextProgramCounter = address.get();
   53|  30.0k|    }
   54|       |
   55|       |    static std::optional<phi::i32> CalculateDisplacementAddress(
   56|       |            Processor& processor, const InstructionArg::AddressDisplacement& adr_displacement)
   57|  5.04k|    {
   58|  5.04k|        phi::i32 register_value = processor.IntRegisterGetSignedValue(adr_displacement.register_id);
   59|  5.04k|
   60|  5.04k|        phi::i32 address = adr_displacement.displacement + register_value;
   61|  5.04k|
   62|  5.04k|        if (address < 0)
   63|      0|        {
   64|      0|            processor.Raise(Exception::AddressOutOfBounds);
   65|      0|            return {};
   66|      0|        }
   67|  5.04k|
   68|  5.04k|        return address;
   69|  5.04k|    }
   70|       |
   71|       |    static std::optional<phi::i32> GetLoadStoreAddress(Processor&           processor,
   72|       |                                                       const InstructionArg argument)
   73|  5.06k|    {
   74|  5.06k|        if (argument.GetType() == ArgumentType::ImmediateInteger)
   75|     20|        {
   76|     20|            const auto& imm_value = argument.AsImmediateValue();
   77|     20|
   78|     20|            if (imm_value.signed_value < 0)
   79|      2|            {
   80|      2|                return {};
   81|      2|            }
   82|     18|
   83|     18|            return imm_value.signed_value;
   84|     18|        }
   85|  5.04k|
   86|  5.04k|        if (argument.GetType() == ArgumentType::AddressDisplacement)
   87|  5.04k|        {
   88|  5.04k|            const auto& adr_displacement = argument.AsAddressDisplacement();
   89|  5.04k|            return CalculateDisplacementAddress(processor, adr_displacement);
   90|  5.04k|        }
   91|      0|
   92|      0|        PHI_ASSERT_NOT_REACHED();
   93|      0|    }
   94|       |
   95|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::i64 value)
   96|  5.33k|    {
   97|  5.33k|        constexpr phi::i64 min = phi::i32::limits_type::min();
   98|  5.33k|        constexpr phi::i64 max = phi::i32::limits_type::max();
   99|  5.33k|
  100|  5.33k|        // Check for underflow
  101|  5.33k|        if (value < min)
  102|      0|        {
  103|      0|            processor.Raise(Exception::Underflow);
  104|      0|
  105|      0|            value = max + (value % (min - 1));
  106|      0|        }
  107|  5.33k|        // Check for overflow
  108|  5.33k|        else if (value > max)
  109|      0|        {
  110|      0|            processor.Raise(Exception::Overflow);
  111|      0|
  112|      0|            value = min + (value % (max + 1));
  113|      0|        }
  114|  5.33k|
  115|  5.33k|        PHI_ASSERT(value >= min);
  116|  5.33k|        PHI_ASSERT(value <= max);
  117|  5.33k|
  118|  5.33k|        processor.IntRegisterSetSignedValue(dest_reg, static_cast<std::int32_t>(value.get()));
  119|  5.33k|    }
  120|       |
  121|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::u64 value)
  122|    179|    {
  123|    179|        constexpr phi::u64 min = phi::u32::limits_type::min();
  124|    179|        constexpr phi::u64 max = phi::u32::limits_type::max();
  125|    179|
  126|    179|        // Check for overflow
  127|    179|        if (value > max)
  128|      0|        {
  129|      0|            processor.Raise(Exception::Overflow);
  130|      0|
  131|      0|            value %= max + 1u;
  132|      0|        }
  133|    179|
  134|    179|        PHI_ASSERT(value <= max);
  135|    179|
  136|    179|        processor.IntRegisterSetUnsignedValue(dest_reg, static_cast<std::uint32_t>(value.get()));
  137|    179|    }
  138|       |
  139|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  140|  5.16k|    {
  141|  5.16k|        phi::i64 res = phi::i64(lhs) + rhs;
  142|  5.16k|
  143|  5.16k|        SafeWriteInteger(processor, dest_reg, res);
  144|  5.16k|    }
  145|       |
  146|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  147|    116|    {
  148|    116|        phi::u64 res = phi::u64(lhs) + rhs;
  149|    116|
  150|    116|        SafeWriteInteger(processor, dest_reg, res);
  151|    116|    }
  152|       |
  153|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  154|       |                            phi::i32 rhs)
  155|    122|    {
  156|    122|        phi::i64 res = phi::i64(lhs) - rhs;
  157|    122|
  158|    122|        SafeWriteInteger(processor, dest_reg, res);
  159|    122|    }
  160|       |
  161|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  162|       |                            phi::u32 rhs)
  163|     37|    {
  164|     37|        constexpr phi::u32 max = phi::u32::limits_type::max();
  165|     37|
  166|     37|        if (lhs < rhs)
  167|      1|        {
  168|      1|            processor.Raise(Exception::Underflow);
  169|      1|
  170|      1|            phi::u64 res = max - rhs + lhs + 1u;
  171|      1|            SafeWriteInteger(processor, dest_reg, res);
  172|      1|            return;
  173|      1|        }
  174|     36|
  175|     36|        phi::u64 res = phi::u64(lhs) - rhs;
  176|     36|
  177|     36|        SafeWriteInteger(processor, dest_reg, res);
  178|     36|    }
  179|       |
  180|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  181|       |                               phi::i32 rhs)
  182|     48|    {
  183|     48|        phi::i64 res = phi::i64(lhs) * rhs;
  184|     48|
  185|     48|        SafeWriteInteger(processor, dest_reg, res);
  186|     48|    }
  187|       |
  188|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  189|       |                               phi::u32 rhs)
  190|     25|    {
  191|     25|        phi::u64 res = phi::u64(lhs) * rhs;
  192|     25|
  193|     25|        SafeWriteInteger(processor, dest_reg, res);
  194|     25|    }
  195|       |
  196|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  197|     67|    {
  198|     67|        if (rhs == 0)
  199|     66|        {
  200|     66|            processor.Raise(Exception::DivideByZero);
  201|     66|            return;
  202|     66|        }
  203|      1|
  204|      1|        phi::i64 res = phi::i64(lhs) / rhs;
  205|      1|
  206|      1|        SafeWriteInteger(processor, dest_reg, res);
  207|      1|    }
  208|       |
  209|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  210|      3|    {
  211|      3|        if (rhs == 0u)
  212|      2|        {
  213|      2|            processor.Raise(Exception::DivideByZero);
  214|      2|            return;
  215|      2|        }
  216|      1|
  217|      1|        phi::u64 res = phi::u64(lhs) / rhs;
  218|      1|
  219|      1|        SafeWriteInteger(processor, dest_reg, res);
  220|      1|    }
  221|       |
  222|       |    static void ShiftRightLogical(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  223|       |                                  phi::i32 shift)
  224|     42|    {
  225|     42|        // Prevent undefined behavior by shifting by more than 31
  226|     42|        if (shift > 31)
  227|      1|        {
  228|      1|            processor.Raise(Exception::BadShift);
  229|      1|
  230|      1|            // Just set register to 0
  231|      1|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  232|      1|            return;
  233|      1|        }
  234|     41|
  235|     41|        // Do nothing when shifting by zero to prevent undefined behavior
  236|     41|        if (shift == 0)
  237|     20|        {
  238|     20|            return;
  239|     20|        }
  240|     21|
  241|     21|        // Negative shifts are undefiend behaviour
  242|     21|        if (shift < 0)
  243|      1|        {
  244|      1|            processor.Raise(Exception::BadShift);
  245|      1|            return;
  246|      1|        }
  247|     20|
  248|     20|        phi::i32 new_value = base.get() >> shift.get();
  249|     20|
  250|     20|        new_value = clear_top_n_bits(new_value.get(), shift.get());
  251|     20|
  252|     20|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  253|     20|    }
  254|       |
  255|       |    static void ShiftRightArithmetic(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  256|       |                                     phi::i32 shift)
  257|      6|    {
  258|      6|        // Prevent undefined behavior by shifting by more than 31
  259|      6|        if (shift > 31)
  260|      1|        {
  261|      1|            processor.Raise(Exception::BadShift);
  262|      1|
  263|      1|            // Is negative ie. sign bit is set
  264|      1|            if (base < 0)
  265|      0|            {
  266|      0|                // Set every byte to 1
  267|      0|                processor.IntRegisterSetSignedValue(dest_reg, ~0);
  268|      0|            }
  269|      1|            else
  270|      1|            {
  271|      1|                // Set every byte to 0
  272|      1|                processor.IntRegisterSetSignedValue(dest_reg, 0);
  273|      1|            }
  274|      1|            return;
  275|      1|        }
  276|      5|
  277|      5|        // Negative shifts are undefined behaviour
  278|      5|        if (shift < 0)
  279|      1|        {
  280|      1|            processor.Raise(Exception::BadShift);
  281|      1|            return;
  282|      1|        }
  283|      4|
  284|      4|        phi::i32 new_value = base.get() >> shift.get();
  285|      4|
  286|      4|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  287|      4|    }
  288|       |
  289|       |    // Behavior is the same for logical and arithmetic shifts
  290|       |    static void ShiftLeft(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  291|       |                          phi::i32 shift)
  292|     47|    {
  293|     47|        if (shift > 31)
  294|      2|        {
  295|      2|            processor.Raise(Exception::BadShift);
  296|      2|
  297|      2|            // Just set register to 0
  298|      2|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  299|      2|            return;
  300|      2|        }
  301|     45|
  302|     45|        // Negative shifts are undefined behaviour
  303|     45|        if (shift < 0)
  304|      2|        {
  305|      2|            processor.Raise(Exception::BadShift);
  306|      2|            return;
  307|      2|        }
  308|     43|
  309|     43|        phi::i32 new_value = base.get() << shift.get();
  310|     43|
  311|     43|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  312|     43|    }
  313|       |
  314|       |    namespace impl
  315|       |    {
  316|       |        void ADD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  317|       |                 const InstructionArg& arg3)
  318|  5.09k|        {
  319|  5.09k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  320|  5.09k|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  321|  5.09k|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  322|  5.09k|
  323|  5.09k|            const auto& dest_reg = arg1.AsRegisterInt();
  324|  5.09k|            const auto& lhs_reg  = arg2.AsRegisterInt();
  325|  5.09k|            const auto& rhs_reg  = arg3.AsRegisterInt();
  326|  5.09k|
  327|  5.09k|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  328|  5.09k|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  329|  5.09k|
  330|  5.09k|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  331|  5.09k|        }
  332|       |
  333|       |        void ADDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  334|       |                  const InstructionArg& arg3)
  335|     71|        {
  336|     71|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  337|     71|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  338|     71|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  339|     71|
  340|     71|            const auto& dest_reg  = arg1.AsRegisterInt();
  341|     71|            const auto& src_reg   = arg2.AsRegisterInt();
  342|     71|            const auto& imm_value = arg3.AsImmediateValue();
  343|     71|
  344|     71|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  345|     71|
  346|     71|            Addition(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  347|     71|        }
  348|       |
  349|       |        void ADDU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  350|       |                  const InstructionArg& arg3)
  351|     56|        {
  352|     56|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  353|     56|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  354|     56|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  355|     56|
  356|     56|            const auto& dest_reg = arg1.AsRegisterInt();
  357|     56|            const auto& lhs_reg  = arg2.AsRegisterInt();
  358|     56|            const auto& rhs_reg  = arg3.AsRegisterInt();
  359|     56|
  360|     56|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  361|     56|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  362|     56|
  363|     56|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  364|     56|        }
  365|       |
  366|       |        void ADDUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  367|       |                   const InstructionArg& arg3)
  368|     60|        {
  369|     60|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  370|     60|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  371|     60|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  372|     60|
  373|     60|            const auto& dest_reg  = arg1.AsRegisterInt();
  374|     60|            const auto& src_reg   = arg2.AsRegisterInt();
  375|     60|            const auto& imm_value = arg3.AsImmediateValue();
  376|     60|
  377|     60|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  378|     60|
  379|     60|            Addition(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  380|     60|        }
  381|       |
  382|       |        void ADDF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  383|       |                  const InstructionArg& arg3)
  384|      0|        {
  385|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  386|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  387|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  388|      0|
  389|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  390|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  391|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  392|      0|
  393|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  394|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  395|      0|
  396|      0|            const phi::f32 new_value = lhs_value + rhs_value;
  397|      0|
  398|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  399|      0|        }
  400|       |
  401|       |        void ADDD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  402|       |                  const InstructionArg& arg3)
  403|      0|        {
  404|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  405|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  406|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  407|      0|
  408|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  409|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  410|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  411|      0|
  412|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  413|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  414|      0|
  415|      0|            const phi::f64 new_value = lhs_value + rhs_value;
  416|      0|
  417|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  418|      0|        }
  419|       |
  420|       |        void SUB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  421|       |                 const InstructionArg& arg3)
  422|     65|        {
  423|     65|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  424|     65|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  425|     65|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  426|     65|
  427|     65|            const auto& dest_reg = arg1.AsRegisterInt();
  428|     65|            const auto& lhs_reg  = arg2.AsRegisterInt();
  429|     65|            const auto& rhs_reg  = arg3.AsRegisterInt();
  430|     65|
  431|     65|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  432|     65|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  433|     65|
  434|     65|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  435|     65|        }
  436|       |
  437|       |        void SUBI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  438|       |                  const InstructionArg& arg3)
  439|     57|        {
  440|     57|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  441|     57|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  442|     57|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  443|     57|
  444|     57|            const auto& dest_reg  = arg1.AsRegisterInt();
  445|     57|            const auto& src_reg   = arg2.AsRegisterInt();
  446|     57|            const auto& imm_value = arg3.AsImmediateValue();
  447|     57|
  448|     57|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  449|     57|
  450|     57|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  451|     57|        }
  452|       |
  453|       |        void SUBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  454|       |                  const InstructionArg& arg3)
  455|     24|        {
  456|     24|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  457|     24|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  458|     24|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  459|     24|
  460|     24|            const auto& dest_reg = arg1.AsRegisterInt();
  461|     24|            const auto& lhs_reg  = arg2.AsRegisterInt();
  462|     24|            const auto& rhs_reg  = arg3.AsRegisterInt();
  463|     24|
  464|     24|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  465|     24|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  466|     24|
  467|     24|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  468|     24|        }
  469|       |
  470|       |        void SUBUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  471|       |                   const InstructionArg& arg3)
  472|     13|        {
  473|     13|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  474|     13|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  475|     13|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  476|     13|
  477|     13|            const auto& dest_reg  = arg1.AsRegisterInt();
  478|     13|            const auto& src_reg   = arg2.AsRegisterInt();
  479|     13|            const auto& imm_value = arg3.AsImmediateValue();
  480|     13|
  481|     13|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  482|     13|
  483|     13|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  484|     13|        }
  485|       |
  486|       |        void SUBF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  487|       |                  const InstructionArg& arg3)
  488|      0|        {
  489|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  490|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  491|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  492|      0|
  493|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  494|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  495|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  496|      0|
  497|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  498|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  499|      0|
  500|      0|            const phi::f32 new_value = lhs_value - rhs_value;
  501|      0|
  502|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  503|      0|        }
  504|       |
  505|       |        void SUBD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  506|       |                  const InstructionArg& arg3)
  507|      0|        {
  508|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  509|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  510|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  511|      0|
  512|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  513|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  514|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  515|      0|
  516|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  517|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  518|      0|
  519|      0|            const phi::f64 new_value = lhs_value - rhs_value;
  520|      0|
  521|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  522|      0|        }
  523|       |
  524|       |        void MULT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  525|       |                  const InstructionArg& arg3)
  526|     24|        {
  527|     24|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  528|     24|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  529|     24|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  530|     24|
  531|     24|            const auto& dest_reg = arg1.AsRegisterInt();
  532|     24|            const auto& lhs_reg  = arg2.AsRegisterInt();
  533|     24|            const auto& rhs_reg  = arg3.AsRegisterInt();
  534|     24|
  535|     24|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  536|     24|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  537|     24|
  538|     24|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  539|     24|        }
  540|       |
  541|       |        void MULTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  542|       |                   const InstructionArg& arg3)
  543|     24|        {
  544|     24|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  545|     24|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  546|     24|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  547|     24|
  548|     24|            const auto& dest_reg  = arg1.AsRegisterInt();
  549|     24|            const auto& src_reg   = arg2.AsRegisterInt();
  550|     24|            const auto& imm_value = arg3.AsImmediateValue();
  551|     24|
  552|     24|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  553|     24|
  554|     24|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  555|     24|        }
  556|       |
  557|       |        void MULTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  558|       |                   const InstructionArg& arg3)
  559|     24|        {
  560|     24|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  561|     24|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  562|     24|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  563|     24|
  564|     24|            const auto& dest_reg = arg1.AsRegisterInt();
  565|     24|            const auto& lhs_reg  = arg2.AsRegisterInt();
  566|     24|            const auto& rhs_reg  = arg3.AsRegisterInt();
  567|     24|
  568|     24|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  569|     24|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  570|     24|
  571|     24|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  572|     24|        }
  573|       |
  574|       |        void MULTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  575|       |                    const InstructionArg& arg3)
  576|      1|        {
  577|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  578|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  579|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  580|      1|
  581|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  582|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  583|      1|            const auto& imm_value = arg3.AsImmediateValue();
  584|      1|
  585|      1|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  586|      1|
  587|      1|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  588|      1|        }
  589|       |
  590|       |        void MULTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  591|       |                   const InstructionArg& arg3)
  592|      0|        {
  593|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  594|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  595|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  596|      0|
  597|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  598|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  599|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  600|      0|
  601|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  602|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  603|      0|
  604|      0|            const phi::f32 new_value = lhs_value * rhs_value;
  605|      0|
  606|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  607|      0|        }
  608|       |
  609|       |        void MULTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  610|       |                   const InstructionArg& arg3)
  611|      0|        {
  612|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  613|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  614|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  615|      0|
  616|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  617|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  618|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  619|      0|
  620|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  621|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  622|      0|
  623|      0|            const phi::f64 new_value = lhs_value * rhs_value;
  624|      0|
  625|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  626|      0|        }
  627|       |
  628|       |        void DIV(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  629|       |                 const InstructionArg& arg3)
  630|     65|        {
  631|     65|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  632|     65|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  633|     65|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  634|     65|
  635|     65|            const auto& dest_reg = arg1.AsRegisterInt();
  636|     65|            const auto& lhs_reg  = arg2.AsRegisterInt();
  637|     65|            const auto& rhs_reg  = arg3.AsRegisterInt();
  638|     65|
  639|     65|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  640|     65|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  641|     65|
  642|     65|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  643|     65|        }
  644|       |
  645|       |        void DIVI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  646|       |                  const InstructionArg& arg3)
  647|      2|        {
  648|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  649|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  650|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  651|      2|
  652|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  653|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  654|      2|            const auto& imm_value = arg3.AsImmediateValue();
  655|      2|
  656|      2|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  657|      2|
  658|      2|            Division(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  659|      2|        }
  660|       |
  661|       |        void DIVU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  662|       |                  const InstructionArg& arg3)
  663|      1|        {
  664|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  665|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  666|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  667|      1|
  668|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  669|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  670|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  671|      1|
  672|      1|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  673|      1|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  674|      1|
  675|      1|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  676|      1|        }
  677|       |
  678|       |        void DIVUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  679|       |                   const InstructionArg& arg3)
  680|      2|        {
  681|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  682|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  683|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  684|      2|
  685|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
  686|      2|            const auto& src_reg   = arg2.AsRegisterInt();
  687|      2|            const auto& imm_value = arg3.AsImmediateValue();
  688|      2|
  689|      2|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  690|      2|
  691|      2|            Division(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  692|      2|        }
  693|       |
  694|       |        void DIVF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  695|       |                  const InstructionArg& arg3)
  696|      0|        {
  697|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  698|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  699|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  700|      0|
  701|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  702|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  703|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  704|      0|
  705|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  706|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  707|      0|
  708|      0|            if (rhs_value.get() == 0.0f)
  709|      0|            {
  710|      0|                processor.Raise(Exception::DivideByZero);
  711|      0|                return;
  712|      0|            }
  713|      0|
  714|      0|            const phi::f32 new_value = lhs_value / rhs_value;
  715|      0|
  716|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  717|      0|        }
  718|       |
  719|       |        void DIVD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  720|       |                  const InstructionArg& arg3)
  721|      0|        {
  722|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  723|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  724|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  725|      0|
  726|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  727|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  728|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  729|      0|
  730|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  731|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  732|      0|
  733|      0|            if (rhs_value.get() == 0.0)
  734|      0|            {
  735|      0|                processor.Raise(Exception::DivideByZero);
  736|      0|                return;
  737|      0|            }
  738|      0|
  739|      0|            const phi::f64 new_value = lhs_value / rhs_value;
  740|      0|
  741|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  742|      0|        }
  743|       |
  744|       |        void SLL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  745|       |                 const InstructionArg& arg3)
  746|      1|        {
  747|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  748|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  749|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  750|      1|
  751|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  752|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  753|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  754|      1|
  755|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  756|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  757|      1|
  758|      1|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  759|      1|        }
  760|       |
  761|       |        void SLLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  762|       |                  const InstructionArg& arg3)
  763|     22|        {
  764|     22|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  765|     22|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  766|     22|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  767|     22|
  768|     22|            const auto& dest_reg  = arg1.AsRegisterInt();
  769|     22|            const auto& src_reg   = arg2.AsRegisterInt();
  770|     22|            const auto& imm_value = arg3.AsImmediateValue();
  771|     22|
  772|     22|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  773|     22|            phi::i32 shift_value = imm_value.signed_value;
  774|     22|
  775|     22|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  776|     22|        }
  777|       |
  778|       |        void SRL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  779|       |                 const InstructionArg& arg3)
  780|     20|        {
  781|     20|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  782|     20|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  783|     20|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  784|     20|
  785|     20|            const auto& dest_reg = arg1.AsRegisterInt();
  786|     20|            const auto& lhs_reg  = arg2.AsRegisterInt();
  787|     20|            const auto& rhs_reg  = arg3.AsRegisterInt();
  788|     20|
  789|     20|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  790|     20|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  791|     20|
  792|     20|            ShiftRightLogical(processor, dest_reg.register_id, lhs_value, rhs_value);
  793|     20|        }
  794|       |
  795|       |        void SRLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  796|       |                  const InstructionArg& arg3)
  797|     22|        {
  798|     22|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  799|     22|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  800|     22|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  801|     22|
  802|     22|            const auto& dest_reg  = arg1.AsRegisterInt();
  803|     22|            const auto& src_reg   = arg2.AsRegisterInt();
  804|     22|            const auto& imm_value = arg3.AsImmediateValue();
  805|     22|
  806|     22|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  807|     22|            phi::i32 shift_value = imm_value.signed_value;
  808|     22|
  809|     22|            ShiftRightLogical(processor, dest_reg.register_id, src_value, shift_value);
  810|     22|        }
  811|       |
  812|       |        void SLA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  813|       |                 const InstructionArg& arg3)
  814|     20|        {
  815|     20|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  816|     20|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  817|     20|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  818|     20|
  819|     20|            const auto& dest_reg = arg1.AsRegisterInt();
  820|     20|            const auto& lhs_reg  = arg2.AsRegisterInt();
  821|     20|            const auto& rhs_reg  = arg3.AsRegisterInt();
  822|     20|
  823|     20|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  824|     20|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  825|     20|
  826|     20|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  827|     20|        }
  828|       |
  829|       |        void SLAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  830|       |                  const InstructionArg& arg3)
  831|      4|        {
  832|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  833|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  834|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  835|      4|
  836|      4|            const auto& dest_reg  = arg1.AsRegisterInt();
  837|      4|            const auto& src_reg   = arg2.AsRegisterInt();
  838|      4|            const auto& imm_value = arg3.AsImmediateValue();
  839|      4|
  840|      4|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  841|      4|            phi::i32 shift_value = imm_value.signed_value;
  842|      4|
  843|      4|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  844|      4|        }
  845|       |
  846|       |        void SRA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  847|       |                 const InstructionArg& arg3)
  848|      2|        {
  849|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  850|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  851|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  852|      2|
  853|      2|            const auto& dest_reg = arg1.AsRegisterInt();
  854|      2|            const auto& lhs_reg  = arg2.AsRegisterInt();
  855|      2|            const auto& rhs_reg  = arg3.AsRegisterInt();
  856|      2|
  857|      2|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  858|      2|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  859|      2|
  860|      2|            ShiftRightArithmetic(processor, dest_reg.register_id, lhs_value, rhs_value);
  861|      2|        }
  862|       |
  863|       |        void SRAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  864|       |                  const InstructionArg& arg3)
  865|      4|        {
  866|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  867|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  868|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  869|      4|
  870|      4|            const auto& dest_reg  = arg1.AsRegisterInt();
  871|      4|            const auto& src_reg   = arg2.AsRegisterInt();
  872|      4|            const auto& imm_value = arg3.AsImmediateValue();
  873|      4|
  874|      4|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  875|      4|            phi::i32 shift_value = imm_value.signed_value;
  876|      4|
  877|      4|            ShiftRightArithmetic(processor, dest_reg.register_id, src_value, shift_value);
  878|      4|        }
  879|       |
  880|       |        void AND(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  881|       |                 const InstructionArg& arg3)
  882|     25|        {
  883|     25|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  884|     25|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  885|     25|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  886|     25|
  887|     25|            const auto& dest_reg = arg1.AsRegisterInt();
  888|     25|            const auto& lhs_reg  = arg2.AsRegisterInt();
  889|     25|            const auto& rhs_reg  = arg3.AsRegisterInt();
  890|     25|
  891|     25|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  892|     25|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  893|     25|            phi::i32 new_value = lhs_value.get() & rhs_value.get();
  894|     25|
  895|     25|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  896|     25|        }
  897|       |
  898|       |        void ANDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  899|       |                  const InstructionArg& arg3)
  900|     25|        {
  901|     25|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  902|     25|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  903|     25|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  904|     25|
  905|     25|            const auto& dest_reg  = arg1.AsRegisterInt();
  906|     25|            const auto& src_reg   = arg2.AsRegisterInt();
  907|     25|            const auto& imm_value = arg3.AsImmediateValue();
  908|     25|
  909|     25|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  910|     25|            phi::i32 new_value = src_value.get() & imm_value.signed_value.get();
  911|     25|
  912|     25|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  913|     25|        }
  914|       |
  915|       |        void OR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  916|       |                const InstructionArg& arg3)
  917|     25|        {
  918|     25|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  919|     25|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  920|     25|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  921|     25|
  922|     25|            const auto& dest_reg = arg1.AsRegisterInt();
  923|     25|            const auto& lhs_reg  = arg2.AsRegisterInt();
  924|     25|            const auto& rhs_reg  = arg3.AsRegisterInt();
  925|     25|
  926|     25|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  927|     25|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  928|     25|            phi::i32 new_value = lhs_value.get() | rhs_value.get();
  929|     25|
  930|     25|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  931|     25|        }
  932|       |
  933|       |        void ORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  934|       |                 const InstructionArg& arg3)
  935|      3|        {
  936|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  937|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  938|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  939|      3|
  940|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
  941|      3|            const auto& src_reg   = arg2.AsRegisterInt();
  942|      3|            const auto& imm_value = arg3.AsImmediateValue();
  943|      3|
  944|      3|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  945|      3|            phi::i32 new_value = src_value.get() | imm_value.signed_value.get();
  946|      3|
  947|      3|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  948|      3|        }
  949|       |
  950|       |        void XOR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  951|       |                 const InstructionArg& arg3)
  952|      1|        {
  953|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  954|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  955|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  956|      1|
  957|      1|            const auto& dest_reg = arg1.AsRegisterInt();
  958|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
  959|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
  960|      1|
  961|      1|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  962|      1|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  963|      1|            phi::i32 new_value = lhs_value.get() ^ rhs_value.get();
  964|      1|
  965|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  966|      1|        }
  967|       |
  968|       |        void XORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  969|       |                  const InstructionArg& arg3)
  970|      1|        {
  971|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  972|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  973|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  974|      1|
  975|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
  976|      1|            const auto& src_reg   = arg2.AsRegisterInt();
  977|      1|            const auto& imm_value = arg3.AsImmediateValue();
  978|      1|
  979|      1|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  980|      1|            phi::i32 new_value = src_value.get() ^ imm_value.signed_value.get();
  981|      1|
  982|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  983|      1|        }
  984|       |
  985|       |        void SLT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  986|       |                 const InstructionArg& arg3)
  987|      2|        {
  988|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  989|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  990|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  991|      2|
  992|      2|            const auto& dest_reg = arg1.AsRegisterInt();
  993|      2|            const auto& lhs_reg  = arg2.AsRegisterInt();
  994|      2|            const auto& rhs_reg  = arg3.AsRegisterInt();
  995|      2|
  996|      2|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  997|      2|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  998|      2|
  999|      2|            const phi::i32 new_value = (lhs_value < rhs_value ? 1 : 0);
 1000|      2|
 1001|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1002|      2|        }
 1003|       |
 1004|       |        void SLTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1005|       |                  const InstructionArg& arg3)
 1006|      3|        {
 1007|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1008|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1009|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1010|      3|
 1011|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
 1012|      3|            const auto& src_reg   = arg2.AsRegisterInt();
 1013|      3|            const auto& imm_value = arg3.AsImmediateValue();
 1014|      3|
 1015|      3|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1016|      3|
 1017|      3|            const phi::i32 new_value = (src_value < imm_value.signed_value ? 1 : 0);
 1018|      3|
 1019|      3|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1020|      3|        }
 1021|       |
 1022|       |        void SLTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1023|       |                  const InstructionArg& arg3)
 1024|      0|        {
 1025|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1026|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1027|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1028|      0|
 1029|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1030|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1031|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1032|      0|
 1033|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1034|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1035|      0|
 1036|      0|            const phi::u32 new_value = (lhs_value < rhs_value ? 1u : 0u);
 1037|      0|
 1038|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1039|      0|        }
 1040|       |
 1041|       |        void SLTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1042|       |                   const InstructionArg& arg3)
 1043|      0|        {
 1044|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1045|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1046|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1047|      0|
 1048|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1049|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1050|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1051|      0|
 1052|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1053|      0|
 1054|      0|            const phi::u32 new_value = (src_value < imm_value.unsigned_value ? 1u : 0u);
 1055|      0|
 1056|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1057|      0|        }
 1058|       |
 1059|       |        void LTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1060|       |                 const InstructionArg& arg3)
 1061|      0|        {
 1062|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1063|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1064|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1065|      0|
 1066|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1067|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1068|      0|
 1069|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1070|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1071|      0|
 1072|      0|            const phi::Boolean new_value = (lhs_value < rhs_value);
 1073|      0|
 1074|      0|            processor.SetFPSRValue(new_value);
 1075|      0|        }
 1076|       |
 1077|       |        void LTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1078|       |                 const InstructionArg& arg3)
 1079|      0|        {
 1080|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1081|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1082|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1083|      0|
 1084|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1085|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1086|      0|
 1087|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1088|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1089|      0|
 1090|      0|            const phi::Boolean new_value = (lhs_value < rhs_value);
 1091|      0|
 1092|      0|            processor.SetFPSRValue(new_value);
 1093|      0|        }
 1094|       |
 1095|       |        void SGT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1096|       |                 const InstructionArg& arg3)
 1097|      3|        {
 1098|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1099|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1100|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1101|      3|
 1102|      3|            const auto& dest_reg = arg1.AsRegisterInt();
 1103|      3|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1104|      3|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1105|      3|
 1106|      3|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1107|      3|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1108|      3|
 1109|      3|            const phi::i32 new_value = (lhs_value > rhs_value ? 1 : 0);
 1110|      3|
 1111|      3|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1112|      3|        }
 1113|       |
 1114|       |        void SGTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1115|       |                  const InstructionArg& arg3)
 1116|      2|        {
 1117|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1118|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1119|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1120|      2|
 1121|      2|            const auto& dest_reg  = arg1.AsRegisterInt();
 1122|      2|            const auto& src_reg   = arg2.AsRegisterInt();
 1123|      2|            const auto& imm_value = arg3.AsImmediateValue();
 1124|      2|
 1125|      2|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1126|      2|
 1127|      2|            const phi::i32 new_value = (src_value > imm_value.signed_value ? 1 : 0);
 1128|      2|
 1129|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1130|      2|        }
 1131|       |
 1132|       |        void SGTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1133|       |                  const InstructionArg& arg3)
 1134|      0|        {
 1135|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1136|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1137|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1138|      0|
 1139|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1140|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1141|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1142|      0|
 1143|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1144|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1145|      0|
 1146|      0|            const phi::u32 new_value = (lhs_value > rhs_value ? 1u : 0u);
 1147|      0|
 1148|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1149|      0|        }
 1150|       |
 1151|       |        void SGTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1152|       |                   const InstructionArg& arg3)
 1153|      0|        {
 1154|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1155|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1156|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1157|      0|
 1158|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1159|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1160|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1161|      0|
 1162|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1163|      0|
 1164|      0|            const phi::u32 new_value = (src_value > imm_value.unsigned_value ? 1u : 0u);
 1165|      0|
 1166|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1167|      0|        }
 1168|       |
 1169|       |        void GTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1170|       |                 const InstructionArg& arg3)
 1171|      0|        {
 1172|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1173|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1174|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1175|      0|
 1176|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1177|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1178|      0|
 1179|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1180|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1181|      0|
 1182|      0|            const phi::Boolean new_value = (lhs_value > rhs_value);
 1183|      0|
 1184|      0|            processor.SetFPSRValue(new_value);
 1185|      0|        }
 1186|       |
 1187|       |        void GTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1188|       |                 const InstructionArg& arg3)
 1189|      0|        {
 1190|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1191|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1192|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1193|      0|
 1194|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1195|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1196|      0|
 1197|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1198|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1199|      0|
 1200|      0|            const phi::Boolean new_value = (lhs_value > rhs_value);
 1201|      0|
 1202|      0|            processor.SetFPSRValue(new_value);
 1203|      0|        }
 1204|       |
 1205|       |        void SLE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1206|       |                 const InstructionArg& arg3)
 1207|      1|        {
 1208|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1209|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1210|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1211|      1|
 1212|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1213|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1214|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1215|      1|
 1216|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1217|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1218|      1|
 1219|      1|            const phi::i32 new_value = (lhs_value <= rhs_value ? 1 : 0);
 1220|      1|
 1221|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1222|      1|        }
 1223|       |
 1224|       |        void SLEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1225|       |                  const InstructionArg& arg3)
 1226|      3|        {
 1227|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1228|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1229|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1230|      3|
 1231|      3|            const auto& dest_reg  = arg1.AsRegisterInt();
 1232|      3|            const auto& src_reg   = arg2.AsRegisterInt();
 1233|      3|            const auto& imm_value = arg3.AsImmediateValue();
 1234|      3|
 1235|      3|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1236|      3|
 1237|      3|            const phi::i32 new_value = (src_value <= imm_value.signed_value ? 1 : 0);
 1238|      3|
 1239|      3|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1240|      3|        }
 1241|       |
 1242|       |        void SLEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1243|       |                  const InstructionArg& arg3)
 1244|      0|        {
 1245|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1246|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1247|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1248|      0|
 1249|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1250|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1251|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1252|      0|
 1253|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1254|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1255|      0|
 1256|      0|            const phi::u32 new_value = (lhs_value <= rhs_value ? 1u : 0u);
 1257|      0|
 1258|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1259|      0|        }
 1260|       |
 1261|       |        void SLEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1262|       |                   const InstructionArg& arg3)
 1263|      0|        {
 1264|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1265|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1266|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1267|      0|
 1268|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1269|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1270|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1271|      0|
 1272|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1273|      0|
 1274|      0|            const phi::u32 new_value = (src_value <= imm_value.unsigned_value ? 1u : 0u);
 1275|      0|
 1276|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1277|      0|        }
 1278|       |
 1279|       |        void LEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1280|       |                 const InstructionArg& arg3)
 1281|      0|        {
 1282|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1283|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1284|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1285|      0|
 1286|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1287|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1288|      0|
 1289|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1290|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1291|      0|
 1292|      0|            const phi::Boolean new_value = (lhs_value <= rhs_value);
 1293|      0|
 1294|      0|            processor.SetFPSRValue(new_value);
 1295|      0|        }
 1296|       |
 1297|       |        void LED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1298|       |                 const InstructionArg& arg3)
 1299|      0|        {
 1300|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1301|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1302|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1303|      0|
 1304|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1305|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1306|      0|
 1307|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1308|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1309|      0|
 1310|      0|            const phi::Boolean new_value = (lhs_value <= rhs_value);
 1311|      0|
 1312|      0|            processor.SetFPSRValue(new_value);
 1313|      0|        }
 1314|       |
 1315|       |        void SGE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1316|       |                 const InstructionArg& arg3)
 1317|      3|        {
 1318|      3|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1319|      3|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1320|      3|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1321|      3|
 1322|      3|            const auto& dest_reg = arg1.AsRegisterInt();
 1323|      3|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1324|      3|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1325|      3|
 1326|      3|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1327|      3|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1328|      3|
 1329|      3|            const phi::i32 new_value = (lhs_value >= rhs_value ? 1 : 0);
 1330|      3|
 1331|      3|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1332|      3|        }
 1333|       |
 1334|       |        void SGEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1335|       |                  const InstructionArg& arg3)
 1336|     24|        {
 1337|     24|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1338|     24|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1339|     24|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1340|     24|
 1341|     24|            const auto& dest_reg  = arg1.AsRegisterInt();
 1342|     24|            const auto& src_reg   = arg2.AsRegisterInt();
 1343|     24|            const auto& imm_value = arg3.AsImmediateValue();
 1344|     24|
 1345|     24|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1346|     24|
 1347|     24|            const phi::i32 new_value = (src_value >= imm_value.signed_value ? 1 : 0);
 1348|     24|
 1349|     24|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1350|     24|        }
 1351|       |
 1352|       |        void SGEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1353|       |                  const InstructionArg& arg3)
 1354|      0|        {
 1355|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1356|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1357|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1358|      0|
 1359|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1360|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1361|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1362|      0|
 1363|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1364|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1365|      0|
 1366|      0|            const phi::u32 new_value = (lhs_value >= rhs_value ? 1u : 0u);
 1367|      0|
 1368|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1369|      0|        }
 1370|       |
 1371|       |        void SGEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1372|       |                   const InstructionArg& arg3)
 1373|      0|        {
 1374|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1375|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1376|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1377|      0|
 1378|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1379|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1380|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1381|      0|
 1382|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1383|      0|
 1384|      0|            const phi::u32 new_value = (src_value >= imm_value.unsigned_value ? 1u : 0u);
 1385|      0|
 1386|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1387|      0|        }
 1388|       |
 1389|       |        void GEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1390|       |                 const InstructionArg& arg3)
 1391|      0|        {
 1392|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1393|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1394|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1395|      0|
 1396|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1397|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1398|      0|
 1399|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1400|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1401|      0|
 1402|      0|            const phi::Boolean new_value = (lhs_value >= rhs_value);
 1403|      0|
 1404|      0|            processor.SetFPSRValue(new_value);
 1405|      0|        }
 1406|       |
 1407|       |        void GED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1408|       |                 const InstructionArg& arg3)
 1409|      0|        {
 1410|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1411|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1412|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1413|      0|
 1414|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1415|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1416|      0|
 1417|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1418|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1419|      0|
 1420|      0|            const phi::Boolean new_value = (lhs_value >= rhs_value);
 1421|      0|
 1422|      0|            processor.SetFPSRValue(new_value);
 1423|      0|        }
 1424|       |
 1425|       |        void SEQ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1426|       |                 const InstructionArg& arg3)
 1427|  15.0k|        {
 1428|  15.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1429|  15.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1430|  15.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1431|  15.0k|
 1432|  15.0k|            const auto& dest_reg = arg1.AsRegisterInt();
 1433|  15.0k|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1434|  15.0k|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1435|  15.0k|
 1436|  15.0k|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1437|  15.0k|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1438|  15.0k|
 1439|  15.0k|            const phi::i32 new_value = (lhs_value == rhs_value ? 1 : 0);
 1440|  15.0k|
 1441|  15.0k|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1442|  15.0k|        }
 1443|       |
 1444|       |        void SEQI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1445|       |                  const InstructionArg& arg3)
 1446|      1|        {
 1447|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1448|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1449|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1450|      1|
 1451|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1452|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1453|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1454|      1|
 1455|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1456|      1|
 1457|      1|            const phi::i32 new_value = (src_value == imm_value.signed_value ? 1 : 0);
 1458|      1|
 1459|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1460|      1|        }
 1461|       |
 1462|       |        void SEQU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1463|       |                  const InstructionArg& arg3)
 1464|      0|        {
 1465|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1466|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1467|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1468|      0|
 1469|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1470|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1471|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1472|      0|
 1473|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1474|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1475|      0|
 1476|      0|            const phi::u32 new_value = (lhs_value == rhs_value ? 1u : 0u);
 1477|      0|
 1478|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1479|      0|        }
 1480|       |
 1481|       |        void SEQUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1482|       |                   const InstructionArg& arg3)
 1483|      0|        {
 1484|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1485|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1486|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1487|      0|
 1488|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1489|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1490|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1491|      0|
 1492|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1493|      0|
 1494|      0|            const phi::u32 new_value = (src_value == imm_value.unsigned_value ? 1u : 0u);
 1495|      0|
 1496|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1497|      0|        }
 1498|       |
 1499|       |        void EQF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1500|       |                 const InstructionArg& arg3)
 1501|      0|        {
 1502|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1503|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1504|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1505|      0|
 1506|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1507|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1508|      0|
 1509|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1510|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1511|      0|
 1512|      0|            const phi::Boolean new_value = (lhs_value.get() == rhs_value.get());
 1513|      0|
 1514|      0|            processor.SetFPSRValue(new_value);
 1515|      0|        }
 1516|       |
 1517|       |        void EQD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1518|       |                 const InstructionArg& arg3)
 1519|      0|        {
 1520|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1521|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1522|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1523|      0|
 1524|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1525|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1526|      0|
 1527|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1528|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1529|      0|
 1530|      0|            const phi::Boolean new_value = (lhs_value.get() == rhs_value.get());
 1531|      0|
 1532|      0|            processor.SetFPSRValue(new_value);
 1533|      0|        }
 1534|       |
 1535|       |        void SNE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1536|       |                 const InstructionArg& arg3)
 1537|      1|        {
 1538|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1539|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1540|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1541|      1|
 1542|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1543|      1|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1544|      1|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1545|      1|
 1546|      1|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1547|      1|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1548|      1|
 1549|      1|            const phi::i32 new_value = (lhs_value != rhs_value ? 1 : 0);
 1550|      1|
 1551|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1552|      1|        }
 1553|       |
 1554|       |        void SNEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1555|       |                  const InstructionArg& arg3)
 1556|      1|        {
 1557|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1558|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1559|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1560|      1|
 1561|      1|            const auto& dest_reg  = arg1.AsRegisterInt();
 1562|      1|            const auto& src_reg   = arg2.AsRegisterInt();
 1563|      1|            const auto& imm_value = arg3.AsImmediateValue();
 1564|      1|
 1565|      1|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1566|      1|
 1567|      1|            const phi::i32 new_value = (src_value != imm_value.signed_value ? 1 : 0);
 1568|      1|
 1569|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1570|      1|        }
 1571|       |
 1572|       |        void SNEU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1573|       |                  const InstructionArg& arg3)
 1574|      0|        {
 1575|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1576|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1577|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1578|      0|
 1579|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1580|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1581|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1582|      0|
 1583|      0|            const phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
 1584|      0|            const phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
 1585|      0|
 1586|      0|            const phi::u32 new_value = (lhs_value != rhs_value ? 1u : 0u);
 1587|      0|
 1588|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1589|      0|        }
 1590|       |
 1591|       |        void SNEUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1592|       |                   const InstructionArg& arg3)
 1593|      0|        {
 1594|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1595|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1596|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1597|      0|
 1598|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1599|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1600|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1601|      0|
 1602|      0|            const phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1603|      0|
 1604|      0|            const phi::u32 new_value = (src_value != imm_value.unsigned_value ? 1u : 0u);
 1605|      0|
 1606|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, new_value);
 1607|      0|        }
 1608|       |
 1609|       |        void NEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1610|       |                 const InstructionArg& arg3)
 1611|      0|        {
 1612|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1613|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1614|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1615|      0|
 1616|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1617|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1618|      0|
 1619|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1620|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1621|      0|
 1622|      0|            const phi::Boolean new_value = (lhs_value.get() != rhs_value.get());
 1623|      0|
 1624|      0|            processor.SetFPSRValue(new_value);
 1625|      0|        }
 1626|       |
 1627|       |        void NED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1628|       |                 const InstructionArg& arg3)
 1629|      0|        {
 1630|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1631|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1632|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1633|      0|
 1634|      0|            const FloatRegisterID lhs_reg = arg1.AsRegisterFloat().register_id;
 1635|      0|            const FloatRegisterID rhs_reg = arg2.AsRegisterFloat().register_id;
 1636|      0|
 1637|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1638|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1639|      0|
 1640|      0|            const phi::Boolean new_value = (lhs_value.get() != rhs_value.get());
 1641|      0|
 1642|      0|            processor.SetFPSRValue(new_value);
 1643|      0|        }
 1644|       |
 1645|       |        void BEQZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1646|       |                  const InstructionArg& arg3)
 1647|      9|        {
 1648|      9|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1649|      9|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1650|      9|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1651|      9|
 1652|      9|            const auto& test_reg   = arg1.AsRegisterInt();
 1653|      9|            const auto& jump_label = arg2.AsLabel();
 1654|      9|
 1655|      9|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1656|      9|
 1657|      9|            if (test_value == 0)
 1658|      9|            {
 1659|      9|                JumpToLabel(processor, jump_label.label_name);
 1660|      9|            }
 1661|      9|        }
 1662|       |
 1663|       |        void BNEZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1664|       |                  const InstructionArg& arg3)
 1665|      7|        {
 1666|      7|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1667|      7|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1668|      7|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1669|      7|
 1670|      7|            const auto& test_reg   = arg1.AsRegisterInt();
 1671|      7|            const auto& jump_label = arg2.AsLabel();
 1672|      7|
 1673|      7|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1674|      7|
 1675|      7|            if (test_value != 0)
 1676|      6|            {
 1677|      6|                JumpToLabel(processor, jump_label.label_name);
 1678|      6|            }
 1679|      7|        }
 1680|       |
 1681|       |        void BFPT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1682|       |                  const InstructionArg& arg3)
 1683|      0|        {
 1684|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1685|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1686|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1687|      0|
 1688|      0|            const auto& jump_label = arg1.AsLabel();
 1689|      0|
 1690|      0|            phi::Boolean test_value = processor.GetFPSRValue();
 1691|      0|
 1692|      0|            if (test_value)
 1693|      0|            {
 1694|      0|                JumpToLabel(processor, jump_label.label_name);
 1695|      0|            }
 1696|      0|        }
 1697|       |
 1698|       |        void BFPF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1699|       |                  const InstructionArg& arg3)
 1700|      0|        {
 1701|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1702|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1703|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1704|      0|
 1705|      0|            const auto& jump_label = arg1.AsLabel();
 1706|      0|
 1707|      0|            phi::Boolean test_value = processor.GetFPSRValue();
 1708|      0|
 1709|      0|            if (!test_value)
 1710|      0|            {
 1711|      0|                JumpToLabel(processor, jump_label.label_name);
 1712|      0|            }
 1713|      0|        }
 1714|       |
 1715|       |        void J(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1716|       |               const InstructionArg& arg3)
 1717|  80.0k|        {
 1718|  80.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1719|  80.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1720|  80.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1721|  80.0k|
 1722|  80.0k|            const auto& jump_label = arg1.AsLabel();
 1723|  80.0k|
 1724|  80.0k|            JumpToLabel(processor, jump_label.label_name);
 1725|  80.0k|        }
 1726|       |
 1727|       |        void JR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1728|       |                const InstructionArg& arg3)
 1729|  20.0k|        {
 1730|  20.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1731|  20.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1732|  20.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1733|  20.0k|
 1734|  20.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1735|  20.0k|
 1736|  20.0k|            JumpToRegister(processor, jump_register.register_id);
 1737|  20.0k|        }
 1738|       |
 1739|       |        void JAL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1740|       |                 const InstructionArg& arg3)
 1741|      1|        {
 1742|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1743|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1744|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1745|      1|
 1746|      1|            const auto& jump_label = arg1.AsLabel();
 1747|      1|
 1748|      1|            processor.IntRegisterSetUnsignedValue(
 1749|      1|                    IntRegisterID::R31,
 1750|      1|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1751|      1|
 1752|      1|            JumpToLabel(processor, jump_label.label_name);
 1753|      1|        }
 1754|       |
 1755|       |        void JALR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1756|       |                  const InstructionArg& arg3)
 1757|  10.0k|        {
 1758|  10.0k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1759|  10.0k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1760|  10.0k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1761|  10.0k|
 1762|  10.0k|            const auto& jump_register = arg1.AsRegisterInt();
 1763|  10.0k|
 1764|  10.0k|            processor.IntRegisterSetUnsignedValue(
 1765|  10.0k|                    IntRegisterID::R31,
 1766|  10.0k|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1767|  10.0k|
 1768|  10.0k|            JumpToRegister(processor, jump_register.register_id);
 1769|  10.0k|        }
 1770|       |
 1771|       |        void LHI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1772|       |                 const InstructionArg& arg3)
 1773|      0|        {
 1774|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1775|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::ImmediateInteger);
 1776|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1777|      0|
 1778|      0|            const IntRegisterID dest_reg  = arg1.AsRegisterInt().register_id;
 1779|      0|            std::int32_t        imm_value = arg2.AsImmediateValue().signed_value.get();
 1780|      0|
 1781|      0|            imm_value = (imm_value << 16) & 0xFFFF0000;
 1782|      0|
 1783|      0|            processor.IntRegisterSetSignedValue(dest_reg, imm_value);
 1784|      0|        }
 1785|       |
 1786|       |        void LB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1787|       |                const InstructionArg& arg3)
 1788|      1|        {
 1789|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1790|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1791|      1|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1792|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1793|      1|
 1794|      1|            const auto& dest_reg = arg1.AsRegisterInt();
 1795|      1|
 1796|      1|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1797|      1|
 1798|      1|            if (!optional_address.has_value())
 1799|      0|            {
 1800|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1801|      0|                return;
 1802|      0|            }
 1803|      1|
 1804|      1|            phi::i32 address = optional_address.value();
 1805|      1|
 1806|      1|            auto optional_value =
 1807|      1|                    processor.m_MemoryBlock.LoadByte(static_cast<std::size_t>(address.get()));
 1808|      1|
 1809|      1|            if (!optional_value.has_value())
 1810|      0|            {
 1811|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1812|      0|                PHI_LOG_ERROR("Failed to load byte at address {}", address.get());
 1813|      0|                return;
 1814|      0|            }
 1815|      1|
 1816|      1|            phi::i32 value = optional_value.value();
 1817|      1|
 1818|      1|            processor.IntRegisterSetSignedValue(dest_reg.register_id, value);
 1819|      1|        }
 1820|       |
 1821|       |        void LBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1822|       |                 const InstructionArg& arg3)
 1823|      2|        {
 1824|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1825|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1826|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1827|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1828|      2|
 1829|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1830|      2|
 1831|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1832|      2|
 1833|      2|            if (!optional_address.has_value())
 1834|      0|            {
 1835|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1836|      0|                return;
 1837|      0|            }
 1838|      2|
 1839|      2|            phi::i32 address = optional_address.value();
 1840|      2|
 1841|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedByte(
 1842|      2|                    static_cast<std::size_t>(address.get()));
 1843|      2|
 1844|      2|            if (!optional_value.has_value())
 1845|      0|            {
 1846|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1847|      0|                PHI_LOG_ERROR("Failed to load unsigned byte at address {}", address.get());
 1848|      0|                return;
 1849|      0|            }
 1850|      2|
 1851|      2|            phi::i32 value = optional_value.value();
 1852|      2|
 1853|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1854|      2|        }
 1855|       |
 1856|       |        void LH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1857|       |                const InstructionArg& arg3)
 1858|      2|        {
 1859|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1860|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1861|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1862|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1863|      2|
 1864|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1865|      2|
 1866|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1867|      2|
 1868|      2|            if (!optional_address.has_value())
 1869|      0|            {
 1870|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1871|      0|                return;
 1872|      0|            }
 1873|      2|
 1874|      2|            phi::i32 address = optional_address.value();
 1875|      2|
 1876|      2|            auto optional_value =
 1877|      2|                    processor.m_MemoryBlock.LoadHalfWord(static_cast<std::size_t>(address.get()));
 1878|      2|
 1879|      2|            if (!optional_value.has_value())
 1880|      0|            {
 1881|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1882|      0|                PHI_LOG_ERROR("Failed to load half byte at address {}", address.get());
 1883|      0|                return;
 1884|      0|            }
 1885|      2|
 1886|      2|            phi::i32 value = optional_value.value();
 1887|      2|
 1888|      2|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1889|      2|        }
 1890|       |
 1891|       |        void LHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1892|       |                 const InstructionArg& arg3)
 1893|      2|        {
 1894|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1895|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1896|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1897|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1898|      2|
 1899|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1900|      2|
 1901|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1902|      2|
 1903|      2|            if (!optional_address.has_value())
 1904|      0|            {
 1905|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1906|      0|                return;
 1907|      0|            }
 1908|      2|
 1909|      2|            phi::i32 address = optional_address.value();
 1910|      2|
 1911|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedHalfWord(
 1912|      2|                    static_cast<std::size_t>(address.get()));
 1913|      2|
 1914|      2|            if (!optional_value.has_value())
 1915|      0|            {
 1916|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1917|      0|                PHI_LOG_ERROR("Failed to load unsigned half byte at address {}", address.get());
 1918|      0|                return;
 1919|      0|            }
 1920|      2|
 1921|      2|            phi::i32 value = optional_value.value();
 1922|      2|
 1923|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1924|      2|        }
 1925|       |
 1926|       |        void LW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1927|       |                const InstructionArg& arg3)
 1928|  5.03k|        {
 1929|  5.03k|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1930|  5.03k|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1931|  5.03k|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1932|  5.03k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1933|  5.03k|
 1934|  5.03k|            const auto& dest_reg = arg1.AsRegisterInt();
 1935|  5.03k|
 1936|  5.03k|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1937|  5.03k|
 1938|  5.03k|            if (!optional_address.has_value())
 1939|      1|            {
 1940|      1|                processor.Raise(Exception::AddressOutOfBounds);
 1941|      1|                return;
 1942|      1|            }
 1943|  5.03k|
 1944|  5.03k|            phi::i32 address = optional_address.value();
 1945|  5.03k|
 1946|  5.03k|            auto optional_value =
 1947|  5.03k|                    processor.m_MemoryBlock.LoadWord(static_cast<std::size_t>(address.get()));
 1948|  5.03k|
 1949|  5.03k|            if (!optional_value.has_value())
 1950|      2|            {
 1951|      2|                processor.Raise(Exception::AddressOutOfBounds);
 1952|      2|                PHI_LOG_ERROR("Failed to load word at address {}", address.get());
 1953|      2|                return;
 1954|      2|            }
 1955|  5.03k|
 1956|  5.03k|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1957|  5.03k|        }
 1958|       |
 1959|       |        void LWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1960|       |                 const InstructionArg& arg3)
 1961|      2|        {
 1962|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1963|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1964|      2|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1965|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1966|      2|
 1967|      2|            const auto& dest_reg = arg1.AsRegisterInt();
 1968|      2|
 1969|      2|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1970|      2|
 1971|      2|            if (!optional_address.has_value())
 1972|      0|            {
 1973|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1974|      0|                return;
 1975|      0|            }
 1976|      2|
 1977|      2|            phi::i32 address = optional_address.value();
 1978|      2|
 1979|      2|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedWord(
 1980|      2|                    static_cast<std::size_t>(address.get()));
 1981|      2|
 1982|      2|            if (!optional_value.has_value())
 1983|      0|            {
 1984|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1985|      0|                PHI_LOG_ERROR("Failed to load unsigned word at address {}", address.get());
 1986|      0|                return;
 1987|      0|            }
 1988|      2|
 1989|      2|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1990|      2|        }
 1991|       |
 1992|       |        void LF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1993|       |                const InstructionArg& arg3)
 1994|      0|        {
 1995|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1996|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1997|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1998|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1999|      0|
 2000|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 2001|      0|
 2002|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 2003|      0|
 2004|      0|            if (!optional_address.has_value())
 2005|      0|            {
 2006|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2007|      0|                return;
 2008|      0|            }
 2009|      0|
 2010|      0|            phi::i32 address = optional_address.value();
 2011|      0|
 2012|      0|            auto optional_value =
 2013|      0|                    processor.m_MemoryBlock.LoadFloat(static_cast<std::size_t>(address.get()));
 2014|      0|
 2015|      0|            if (!optional_value.has_value())
 2016|      0|            {
 2017|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2018|      0|                PHI_LOG_ERROR("Failed to load float at address {}", address.get());
 2019|      0|                return;
 2020|      0|            }
 2021|      0|
 2022|      0|            processor.FloatRegisterSetFloatValue(dest_reg.register_id, optional_value.value());
 2023|      0|        }
 2024|       |
 2025|       |        void LD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2026|       |                const InstructionArg& arg3)
 2027|      0|        {
 2028|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2029|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 2030|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 2031|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2032|      0|
 2033|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 2034|      0|
 2035|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 2036|      0|
 2037|      0|            if (!optional_address.has_value())
 2038|      0|            {
 2039|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2040|      0|                return;
 2041|      0|            }
 2042|      0|
 2043|      0|            phi::i32 address = optional_address.value();
 2044|      0|
 2045|      0|            auto optional_value =
 2046|      0|                    processor.m_MemoryBlock.LoadDouble(static_cast<std::size_t>(address.get()));
 2047|      0|
 2048|      0|            if (!optional_value.has_value())
 2049|      0|            {
 2050|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2051|      0|                PHI_LOG_ERROR("Failed to load double at address {}", address.get());
 2052|      0|                return;
 2053|      0|            }
 2054|      0|
 2055|      0|            processor.FloatRegisterSetDoubleValue(dest_reg.register_id, optional_value.value());
 2056|      0|        }
 2057|       |
 2058|       |        void SB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2059|       |                const InstructionArg& arg3)
 2060|      4|        {
 2061|      4|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2062|      4|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2063|      4|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2064|      4|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2065|      4|
 2066|      4|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2067|      4|
 2068|      4|            if (!optional_address.has_value())
 2069|      0|            {
 2070|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2071|      0|                return;
 2072|      0|            }
 2073|      4|
 2074|      4|            phi::i32 address = optional_address.value();
 2075|      4|
 2076|      4|            const auto& src_reg = arg2.AsRegisterInt();
 2077|      4|
 2078|      4|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2079|      4|
 2080|      4|            phi::Boolean success = processor.m_MemoryBlock.StoreByte(
 2081|      4|                    static_cast<std::size_t>(address.get()), static_cast<std::int8_t>(value.get()));
 2082|      4|
 2083|      4|            if (!success)
 2084|      2|            {
 2085|      2|                processor.Raise(Exception::AddressOutOfBounds);
 2086|      2|                PHI_LOG_ERROR("Failed to store byte at address {}", address.get());
 2087|      2|            }
 2088|      4|        }
 2089|       |
 2090|       |        void SBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2091|       |                 const InstructionArg& arg3)
 2092|      2|        {
 2093|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2094|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2095|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2096|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2097|      2|
 2098|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2099|      2|
 2100|      2|            if (!optional_address.has_value())
 2101|      0|            {
 2102|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2103|      0|                return;
 2104|      0|            }
 2105|      2|
 2106|      2|            phi::i32 address = optional_address.value();
 2107|      2|
 2108|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2109|      2|
 2110|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2111|      2|
 2112|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedByte(
 2113|      2|                    static_cast<std::size_t>(address.get()),
 2114|      2|                    static_cast<std::uint8_t>(value.get()));
 2115|      2|
 2116|      2|            if (!success)
 2117|      0|            {
 2118|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2119|      0|                PHI_LOG_ERROR("Failed to store unsigned byte at address {}", address.get());
 2120|      0|            }
 2121|      2|        }
 2122|       |
 2123|       |        void SH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2124|       |                const InstructionArg& arg3)
 2125|      2|        {
 2126|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2127|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2128|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2129|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2130|      2|
 2131|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2132|      2|
 2133|      2|            if (!optional_address.has_value())
 2134|      0|            {
 2135|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2136|      0|                return;
 2137|      0|            }
 2138|      2|
 2139|      2|            phi::i32 address = optional_address.value();
 2140|      2|
 2141|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2142|      2|
 2143|      2|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2144|      2|
 2145|      2|            phi::Boolean success =
 2146|      2|                    processor.m_MemoryBlock.StoreHalfWord(static_cast<std::size_t>(address.get()),
 2147|      2|                                                          static_cast<std::int16_t>(value.get()));
 2148|      2|
 2149|      2|            if (!success)
 2150|      0|            {
 2151|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2152|      0|                PHI_LOG_ERROR("Failed to store half word at address {}", address.get());
 2153|      0|            }
 2154|      2|        }
 2155|       |
 2156|       |        void SHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2157|       |                 const InstructionArg& arg3)
 2158|      2|        {
 2159|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2160|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2161|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2162|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2163|      2|
 2164|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2165|      2|
 2166|      2|            if (!optional_address.has_value())
 2167|      0|            {
 2168|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2169|      0|                return;
 2170|      0|            }
 2171|      2|
 2172|      2|            phi::i32 address = optional_address.value();
 2173|      2|
 2174|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2175|      2|
 2176|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2177|      2|
 2178|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedHalfWord(
 2179|      2|                    static_cast<std::size_t>(address.get()),
 2180|      2|                    static_cast<std::uint16_t>(value.get()));
 2181|      2|
 2182|      2|            if (!success)
 2183|      0|            {
 2184|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2185|      0|                PHI_LOG_ERROR("Failed to store unsigned half word at address {}", address.get());
 2186|      0|            }
 2187|      2|        }
 2188|       |
 2189|       |        void SW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2190|       |                const InstructionArg& arg3)
 2191|     12|        {
 2192|     12|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2193|     12|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2194|     12|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2195|     12|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2196|     12|
 2197|     12|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2198|     12|
 2199|     12|            if (!optional_address.has_value())
 2200|      1|            {
 2201|      1|                processor.Raise(Exception::AddressOutOfBounds);
 2202|      1|                return;
 2203|      1|            }
 2204|     11|
 2205|     11|            phi::i32 address = optional_address.value();
 2206|     11|
 2207|     11|            const auto& src_reg = arg2.AsRegisterInt();
 2208|     11|
 2209|     11|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 2210|     11|
 2211|     11|            phi::Boolean success = processor.m_MemoryBlock.StoreWord(
 2212|     11|                    static_cast<std::size_t>(address.get()), value);
 2213|     11|
 2214|     11|            if (!success)
 2215|      2|            {
 2216|      2|                processor.Raise(Exception::AddressOutOfBounds);
 2217|      2|                PHI_LOG_ERROR("Failed to store word at address {}", address.get());
 2218|      2|            }
 2219|     11|        }
 2220|       |
 2221|       |        void SWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2222|       |                 const InstructionArg& arg3)
 2223|      2|        {
 2224|      2|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2225|      2|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2226|      2|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2227|      2|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2228|      2|
 2229|      2|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2230|      2|
 2231|      2|            if (!optional_address.has_value())
 2232|      0|            {
 2233|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2234|      0|                return;
 2235|      0|            }
 2236|      2|
 2237|      2|            phi::i32 address = optional_address.value();
 2238|      2|
 2239|      2|            const auto& src_reg = arg2.AsRegisterInt();
 2240|      2|
 2241|      2|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2242|      2|
 2243|      2|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedWord(
 2244|      2|                    static_cast<std::size_t>(address.get()), value);
 2245|      2|
 2246|      2|            if (!success)
 2247|      0|            {
 2248|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2249|      0|                PHI_LOG_ERROR("Failed to store unsigned word at address {}", address.get());
 2250|      0|            }
 2251|      2|        }
 2252|       |
 2253|       |        void SF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2254|       |                const InstructionArg& arg3)
 2255|      0|        {
 2256|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2257|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2258|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2259|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2260|      0|
 2261|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2262|      0|
 2263|      0|            if (!optional_address.has_value())
 2264|      0|            {
 2265|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2266|      0|                return;
 2267|      0|            }
 2268|      0|
 2269|      0|            phi::i32 address = optional_address.value();
 2270|      0|
 2271|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2272|      0|
 2273|      0|            phi::f32 value = processor.FloatRegisterGetFloatValue(src_reg.register_id);
 2274|      0|
 2275|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreFloat(
 2276|      0|                    static_cast<std::size_t>(address.get()), value);
 2277|      0|
 2278|      0|            if (!success)
 2279|      0|            {
 2280|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2281|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2282|      0|            }
 2283|      0|        }
 2284|       |
 2285|       |        void SD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2286|       |                const InstructionArg& arg3)
 2287|      0|        {
 2288|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2289|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2290|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2291|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2292|      0|
 2293|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2294|      0|
 2295|      0|            if (!optional_address.has_value())
 2296|      0|            {
 2297|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2298|      0|                return;
 2299|      0|            }
 2300|      0|
 2301|      0|            phi::i32 address = optional_address.value();
 2302|      0|
 2303|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2304|      0|
 2305|      0|            phi::f64 value = processor.FloatRegisterGetDoubleValue(src_reg.register_id);
 2306|      0|
 2307|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreDouble(
 2308|      0|                    static_cast<std::size_t>(address.get()), value);
 2309|      0|
 2310|      0|            if (!success)
 2311|      0|            {
 2312|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2313|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2314|      0|            }
 2315|      0|        }
 2316|       |
 2317|       |        void MOVF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2318|       |                  const InstructionArg& arg3)
 2319|      0|        {
 2320|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2321|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2322|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2323|      0|
 2324|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2325|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2326|      0|
 2327|      0|            const phi::f32 source_value = processor.FloatRegisterGetFloatValue(source_reg);
 2328|      0|
 2329|      0|            processor.FloatRegisterSetFloatValue(dest_reg, source_value);
 2330|      0|        }
 2331|       |
 2332|       |        void MOVD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2333|       |                  const InstructionArg& arg3)
 2334|      0|        {
 2335|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2336|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2337|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2338|      0|
 2339|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2340|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2341|      0|
 2342|      0|            const phi::f64 source_value = processor.FloatRegisterGetDoubleValue(source_reg);
 2343|      0|
 2344|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, source_value);
 2345|      0|        }
 2346|       |
 2347|       |        void MOVFP2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2348|       |                     const InstructionArg& arg3)
 2349|      0|        {
 2350|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 2351|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2352|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2353|      0|
 2354|      0|            const IntRegisterID   dest_reg   = arg1.AsRegisterInt().register_id;
 2355|      0|            const FloatRegisterID source_reg = arg2.AsRegisterFloat().register_id;
 2356|      0|
 2357|      0|            const float source_value = processor.FloatRegisterGetFloatValue(source_reg).get();
 2358|      0|
 2359|      0|            const std::uint32_t moved_value =
 2360|      0|                    *reinterpret_cast<const std::uint32_t*>(&source_value);
 2361|      0|
 2362|      0|            processor.IntRegisterSetUnsignedValue(dest_reg, moved_value);
 2363|      0|        }
 2364|       |
 2365|       |        void MOVI2FP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2366|       |                     const InstructionArg& arg3)
 2367|      0|        {
 2368|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2369|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 2370|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2371|      0|
 2372|      0|            const FloatRegisterID dest_reg   = arg1.AsRegisterFloat().register_id;
 2373|      0|            const IntRegisterID   source_reg = arg2.AsRegisterInt().register_id;
 2374|      0|
 2375|      0|            const std::uint32_t source_value =
 2376|      0|                    processor.IntRegisterGetUnsignedValue(source_reg).get();
 2377|      0|
 2378|      0|            const float moved_value = *reinterpret_cast<const float*>(&source_value);
 2379|      0|
 2380|      0|            processor.FloatRegisterSetFloatValue(dest_reg, moved_value);
 2381|      0|        }
 2382|       |
 2383|       |        void CVTF2D(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2384|       |                    const InstructionArg& arg3)
 2385|      0|        {
 2386|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2387|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2388|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2389|      0|
 2390|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2391|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2392|      0|
 2393|      0|            const phi::f32 src_value = processor.FloatRegisterGetFloatValue(src_reg);
 2394|      0|
 2395|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, src_value);
 2396|      0|        }
 2397|       |
 2398|       |        void CVTF2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2399|       |                    const InstructionArg& arg3)
 2400|      0|        {
 2401|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2402|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2403|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2404|      0|
 2405|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2406|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2407|      0|
 2408|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2409|      0|            const std::int32_t converted_value_int = static_cast<std::int32_t>(src_value);
 2410|      0|            const float        converted_value_float =
 2411|      0|                    *reinterpret_cast<const float*>(&converted_value_int);
 2412|      0|
 2413|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2414|      0|        }
 2415|       |
 2416|       |        void CVTD2F(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2417|       |                    const InstructionArg& arg3)
 2418|      0|        {
 2419|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2420|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2421|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2422|      0|
 2423|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2424|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2425|      0|
 2426|      0|            const double src_value       = processor.FloatRegisterGetDoubleValue(src_reg).get();
 2427|      0|            const float  converted_value = static_cast<float>(src_value);
 2428|      0|
 2429|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value);
 2430|      0|        }
 2431|       |
 2432|       |        void CVTD2I(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2433|       |                    const InstructionArg& arg3)
 2434|      0|        {
 2435|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2436|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2437|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2438|      0|
 2439|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2440|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2441|      0|
 2442|      0|            const double       src_value = processor.FloatRegisterGetDoubleValue(src_reg).get();
 2443|      0|            const std::int32_t converted_value_int = static_cast<std::int32_t>(src_value);
 2444|      0|            const float        converted_value_float =
 2445|      0|                    *reinterpret_cast<const float*>(&converted_value_int);
 2446|      0|
 2447|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2448|      0|        }
 2449|       |
 2450|       |        void CVTI2F(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2451|       |                    const InstructionArg& arg3)
 2452|      0|        {
 2453|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2454|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2455|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2456|      0|
 2457|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2458|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2459|      0|
 2460|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2461|      0|            const std::int32_t converted_value_int =
 2462|      0|                    *reinterpret_cast<const std::int32_t*>(&src_value);
 2463|      0|            const float converted_value_float = static_cast<float>(converted_value_int);
 2464|      0|
 2465|      0|            processor.FloatRegisterSetFloatValue(dest_reg, converted_value_float);
 2466|      0|        }
 2467|       |
 2468|       |        void CVTI2D(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2469|       |                    const InstructionArg& arg3)
 2470|      0|        {
 2471|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 2472|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2473|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2474|      0|
 2475|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 2476|      0|            const FloatRegisterID src_reg  = arg2.AsRegisterFloat().register_id;
 2477|      0|
 2478|      0|            const float        src_value = processor.FloatRegisterGetFloatValue(src_reg).get();
 2479|      0|            const std::int32_t converted_value_int =
 2480|      0|                    *reinterpret_cast<const std::int32_t*>(&src_value);
 2481|      0|            const double converted_value_double = static_cast<double>(converted_value_int);
 2482|      0|
 2483|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, converted_value_double);
 2484|      0|        }
 2485|       |
 2486|       |        void TRAP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2487|       |                  const InstructionArg& arg3)
 2488|      1|        {
 2489|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::ImmediateInteger);
 2490|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2491|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2492|      1|
 2493|      1|            processor.Raise(Exception::Trap);
 2494|      1|        }
 2495|       |
 2496|       |        void HALT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2497|       |                  const InstructionArg& arg3)
 2498|      1|        {
 2499|      1|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2500|      1|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2501|      1|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2502|      1|
 2503|      1|            processor.Raise(Exception::Halt);
 2504|      1|        }
 2505|       |
 2506|       |        void NOP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2507|       |                 const InstructionArg& arg3)
 2508|  5.01k|        {
 2509|  5.01k|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2510|  5.01k|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2511|  5.01k|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2512|  5.01k|
 2513|  5.01k|            /* Do nothing */
 2514|  5.01k|        }
 2515|       |    } // namespace impl
 2516|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/FloatRegister.cpp:
    1|       |#include "DLX/FloatRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void FloatRegister::SetValue(const phi::f32 val)
    6|   528k|    {
    7|   528k|        m_Value = val;
    8|   528k|    }
    9|       |
   10|       |    phi::f32 FloatRegister::GetValue() const
   11|      0|    {
   12|      0|        return m_Value;
   13|      0|    }
   14|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Token.cpp:
    1|       |#include "DLX/Token.hpp"
    2|       |#include "Phi/Core/Assert.hpp"
    3|       |
    4|       |#include <magic_enum.hpp>
    5|       |#include <string>
    6|       |
    7|       |namespace dlx
    8|       |{
    9|       |    Token::Token(Type type, std::string_view text, phi::u64 line_number, phi::u64 column,
   10|       |                 std::uint32_t hint)
   11|       |        : m_Type{type}
   12|       |        , m_Text{text}
   13|       |        , m_LineNumber{line_number}
   14|       |        , m_Column{column}
   15|       |        , m_Hint{hint}
   16|  1.84M|    {}
   17|       |
   18|       |    Token::Type Token::GetType() const noexcept
   19|  2.19M|    {
   20|  2.19M|        return m_Type;
   21|  2.19M|    }
   22|       |
   23|       |    std::string_view Token::GetTypeName() const noexcept
   24|  3.05k|    {
   25|  3.05k|        return magic_enum::enum_name(m_Type);
   26|  3.05k|    }
   27|       |
   28|       |    phi::u64 Token::GetLineNumber() const noexcept
   29|      0|    {
   30|      0|        return m_LineNumber;
   31|      0|    }
   32|       |
   33|       |    phi::u64 Token::GetColumn() const noexcept
   34|      0|    {
   35|      0|        return m_Column;
   36|      0|    }
   37|       |
   38|       |    phi::usize Token::GetLength() const noexcept
   39|      0|    {
   40|      0|        return m_Text.length();
   41|      0|    }
   42|       |
   43|       |    std::string_view Token::GetText() const noexcept
   44|  3.25M|    {
   45|  3.25M|        return m_Text;
   46|  3.25M|    }
   47|       |
   48|       |    std::string Token::GetTextString() const noexcept
   49|      0|    {
   50|      0|        return std::string(m_Text.data(), m_Text.length());
   51|      0|    }
   52|       |
   53|       |    std::uint32_t Token::GetHint() const noexcept
   54|   204k|    {
   55|   204k|        PHI_ASSERT(m_Type == Type::RegisterInt || m_Type == Type::RegisterFloat ||
   56|   204k|                   m_Type == Type::IntegerLiteral || m_Type == Type::OpCode);
   57|   204k|
   58|   204k|        return m_Hint;
   59|   204k|    }
   60|       |
   61|       |    std::string Token::DebugInfo() const noexcept
   62|      0|    {
   63|      0|        std::string pos_info = "(" + std::to_string(GetLineNumber().get()) + ":" +
   64|      0|                               std::to_string(GetColumn().get()) + ")";
   65|      0|
   66|      0|        switch (m_Type)
   67|      0|        {
   68|      0|            case Type::Colon:
   69|      0|                return "Token[Colon]" + pos_info;
   70|      0|            case Type::Comma:
   71|      0|                return "Token[Comma]" + pos_info;
   72|      0|            case Type::Comment:
   73|      0|                return "Token[Comment]" + pos_info + ": '" + GetTextString() + "'";
   74|      0|            case Type::OpCode:
   75|      0|                return "Token[OpCode]" + pos_info + ": '" + GetTextString() + "'";
   76|      0|            case Type::RegisterInt:
   77|      0|                return "Token[RegisterInt]" + pos_info + ": '" + GetTextString() + "'";
   78|      0|            case Type::RegisterFloat:
   79|      0|                return "Token[RegisterFloat]" + pos_info + ": '" + GetTextString() + "'";
   80|      0|            case Type::RegisterStatus:
   81|      0|                return "Token[RegisterStatus]" + pos_info + ": '" + GetTextString() + "'";
   82|      0|            case Type::LabelIdentifier:
   83|      0|                return "Token[LabelIdentifier]" + pos_info + ": '" + GetTextString() + "'";
   84|      0|            case Type::NewLine:
   85|      0|                return "Token[NewLine]" + pos_info;
   86|      0|            case Type::OpenBracket:
   87|      0|                return "Token[OpenBracket]" + pos_info;
   88|      0|            case Type::ClosingBracket:
   89|      0|                return "Token[ClosingBracket]" + pos_info;
   90|      0|            case Type::IntegerLiteral:
   91|      0|                return "Token[IntegerLiteral]" + pos_info + ": '" + GetTextString() + "'";
   92|      0|            case Type::ImmediateInteger:
   93|      0|                return "Token[ImmediateInteger]" + pos_info + ": " + GetTextString() + "'";
   94|      0|            case Type::Unknown:
   95|      0|                return "Token[Unknown]" + pos_info;
   96|      0|            default:
   97|      0|                PHI_ASSERT_NOT_REACHED();
   98|      0|                return "Token[NotFound]" + pos_info;
   99|      0|        }
  100|      0|    }
  101|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/MemoryBlock.cpp:
    1|       |#include "DLX/MemoryBlock.hpp"
    2|       |#include "Phi/Core/Boolean.hpp"
    3|       |#include "Phi/Core/Log.hpp"
    4|       |#include <cstdint>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    MemoryBlock::MemoryBlock(phi::usize start_address, phi::usize starting_size)
    9|       |        : m_StartingAddress(start_address)
   10|  16.5k|    {
   11|  16.5k|        m_Values.resize(starting_size.get());
   12|  16.5k|    }
   13|       |
   14|       |    std::optional<phi::i8> MemoryBlock::LoadByte(phi::usize address) const
   15|      1|    {
   16|      1|        if (!IsAddressValid(address, 1u))
   17|      0|        {
   18|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   19|      0|            return {};
   20|      0|        }
   21|      1|
   22|      1|        return m_Values.at((address - m_StartingAddress).get()).signed_value;
   23|      1|    }
   24|       |
   25|       |    std::optional<phi::u8> MemoryBlock::LoadUnsignedByte(phi::usize address) const
   26|      2|    {
   27|      2|        if (!IsAddressValid(address, 1u))
   28|      0|        {
   29|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   30|      0|            return {};
   31|      0|        }
   32|      2|
   33|      2|        return m_Values.at((address - m_StartingAddress).get()).unsigned_value;
   34|      2|    }
   35|       |
   36|       |    std::optional<phi::i16> MemoryBlock::LoadHalfWord(phi::usize address) const
   37|      2|    {
   38|      2|        if (!IsAddressValid(address, 2u))
   39|      0|        {
   40|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   41|      0|            return {};
   42|      0|        }
   43|      2|
   44|      2|        phi::usize   start_address = address - m_StartingAddress;
   45|      2|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   46|      2|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   47|      2|        std::int16_t result        = first_byte << 8 | second_byte;
   48|      2|
   49|      2|        return result;
   50|      2|    }
   51|       |
   52|       |    std::optional<phi::u16> MemoryBlock::LoadUnsignedHalfWord(phi::usize address) const
   53|      2|    {
   54|      2|        if (!IsAddressValid(address, 2u))
   55|      0|        {
   56|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   57|      0|            return {};
   58|      0|        }
   59|      2|
   60|      2|        phi::usize    start_address = address - m_StartingAddress;
   61|      2|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   62|      2|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   63|      2|        std::uint16_t result        = first_byte << 8 | second_byte;
   64|      2|
   65|      2|        return result;
   66|      2|    }
   67|       |
   68|       |    std::optional<phi::i32> MemoryBlock::LoadWord(phi::usize address) const
   69|  5.03k|    {
   70|  5.03k|        if (!IsAddressValid(address, 4u))
   71|      2|        {
   72|      2|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   73|      2|            return {};
   74|      2|        }
   75|  5.03k|
   76|  5.03k|        phi::usize   start_address = address - m_StartingAddress;
   77|  5.03k|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   78|  5.03k|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   79|  5.03k|        std::int8_t  third_byte    = m_Values.at((start_address + 2u).get()).signed_value;
   80|  5.03k|        std::int8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).signed_value;
   81|  5.03k|        std::int32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
   82|  5.03k|
   83|  5.03k|        return result;
   84|  5.03k|    }
   85|       |
   86|       |    std::optional<phi::u32> MemoryBlock::LoadUnsignedWord(phi::usize address) const
   87|      2|    {
   88|      2|        if (!IsAddressValid(address, 4u))
   89|      0|        {
   90|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   91|      0|            return {};
   92|      0|        }
   93|      2|
   94|      2|        phi::usize    start_address = address - m_StartingAddress;
   95|      2|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   96|      2|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   97|      2|        std::uint8_t  third_byte    = m_Values.at((start_address + 2u).get()).unsigned_value;
   98|      2|        std::uint8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).unsigned_value;
   99|      2|        std::uint32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
  100|      2|
  101|      2|        return result;
  102|      2|    }
  103|       |
  104|       |    std::optional<phi::f32> MemoryBlock::LoadFloat(phi::usize address) const
  105|      0|    {
  106|      0|        if (!IsAddressValid(address, 4u))
  107|      0|        {
  108|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  109|      0|            return {};
  110|      0|        }
  111|      0|
  112|      0|        phi::usize    start_address = address - m_StartingAddress;
  113|      0|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
  114|      0|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
  115|      0|        std::uint8_t  third_byte    = m_Values.at((start_address + 2u).get()).unsigned_value;
  116|      0|        std::uint8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).unsigned_value;
  117|      0|        std::uint32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
  118|      0|
  119|      0|        return *reinterpret_cast<float*>(&result);
  120|      0|    }
  121|       |
  122|       |    std::optional<phi::f64> MemoryBlock::LoadDouble(phi::usize address) const
  123|      0|    {
  124|      0|        if (!IsAddressValid(address, 8u))
  125|      0|        {
  126|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  127|      0|            return {};
  128|      0|        }
  129|      0|
  130|      0|        phi::f32 first_value  = LoadFloat(address).value();
  131|      0|        phi::f32 second_value = LoadFloat(address + 4u).value();
  132|      0|
  133|      0|        std::uint32_t first_bits  = *reinterpret_cast<std::uint32_t*>(&first_value);
  134|      0|        std::uint32_t second_bits = *reinterpret_cast<std::uint32_t*>(&second_value);
  135|      0|
  136|      0|        std::uint64_t final_bits = (static_cast<std::uint64_t>(second_bits) << 32u) | first_bits;
  137|      0|
  138|      0|        return *reinterpret_cast<double*>(&final_bits);
  139|      0|    }
  140|       |
  141|       |    phi::Boolean MemoryBlock::StoreByte(phi::usize address, phi::i8 value)
  142|      4|    {
  143|      4|        if (!IsAddressValid(address, 1u))
  144|      2|        {
  145|      2|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  146|      2|            return false;
  147|      2|        }
  148|      2|
  149|      2|        m_Values.at((address - m_StartingAddress).get()).signed_value = value.get();
  150|      2|        return true;
  151|      2|    }
  152|       |
  153|       |    phi::Boolean MemoryBlock::StoreUnsignedByte(phi::usize address, phi::u8 value)
  154|      2|    {
  155|      2|        if (!IsAddressValid(address, 1u))
  156|      0|        {
  157|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  158|      0|            return false;
  159|      0|        }
  160|      2|
  161|      2|        m_Values.at((address - m_StartingAddress).get()).unsigned_value = value.get();
  162|      2|        return true;
  163|      2|    }
  164|       |
  165|       |    phi::Boolean MemoryBlock::StoreHalfWord(phi::usize address, phi::i16 value)
  166|      2|    {
  167|      2|        if (!IsAddressValid(address, 2u))
  168|      0|        {
  169|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  170|      0|            return false;
  171|      0|        }
  172|      2|
  173|      2|        phi::usize  start_address = address - m_StartingAddress;
  174|      2|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  175|      2|        std::int8_t second_byte   = value.get() & 0b00000000'11111111;
  176|      2|
  177|      2|        m_Values.at(start_address.get()).signed_value        = first_byte;
  178|      2|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  179|      2|
  180|      2|        return true;
  181|      2|    }
  182|       |
  183|       |    phi::Boolean MemoryBlock::StoreUnsignedHalfWord(phi::usize address, phi::u16 value)
  184|      2|    {
  185|      2|        if (!IsAddressValid(address, 2u))
  186|      0|        {
  187|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  188|      0|            return false;
  189|      0|        }
  190|      2|
  191|      2|        phi::usize   start_address = address - m_StartingAddress;
  192|      2|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  193|      2|        std::uint8_t second_byte   = value.get() & 0b00000000'11111111;
  194|      2|
  195|      2|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  196|      2|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  197|      2|
  198|      2|        return true;
  199|      2|    }
  200|       |
  201|       |    phi::Boolean MemoryBlock::StoreWord(phi::usize address, phi::i32 value)
  202|     11|    {
  203|     11|        if (!IsAddressValid(address, 4u))
  204|      2|        {
  205|      2|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  206|      2|            return false;
  207|      2|        }
  208|      9|
  209|      9|        phi::usize  start_address = address - m_StartingAddress;
  210|      9|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  211|      9|        std::int8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  212|      9|        std::int8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  213|      9|        std::int8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  214|      9|
  215|      9|        m_Values.at(start_address.get()).signed_value        = first_byte;
  216|      9|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  217|      9|        m_Values.at((start_address + 2u).get()).signed_value = third_byte;
  218|      9|        m_Values.at((start_address + 3u).get()).signed_value = fourth_byte;
  219|      9|
  220|      9|        return true;
  221|      9|    }
  222|       |
  223|       |    phi::Boolean MemoryBlock::StoreUnsignedWord(phi::usize address, phi::u32 value)
  224|      2|    {
  225|      2|        if (!IsAddressValid(address, 4u))
  226|      0|        {
  227|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  228|      0|            return false;
  229|      0|        }
  230|      2|
  231|      2|        phi::usize   start_address = address - m_StartingAddress;
  232|      2|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  233|      2|        std::uint8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  234|      2|        std::uint8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  235|      2|        std::uint8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  236|      2|
  237|      2|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  238|      2|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  239|      2|        m_Values.at((start_address + 2u).get()).unsigned_value = third_byte;
  240|      2|        m_Values.at((start_address + 3u).get()).unsigned_value = fourth_byte;
  241|      2|
  242|      2|        return true;
  243|      2|    }
  244|       |
  245|       |    phi::Boolean MemoryBlock::StoreFloat(phi::usize address, phi::f32 value)
  246|      0|    {
  247|      0|        if (!IsAddressValid(address, 4u))
  248|      0|        {
  249|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  250|      0|            return false;
  251|      0|        }
  252|      0|
  253|      0|        float         value_raw  = value.get();
  254|      0|        std::uint32_t value_bits = *reinterpret_cast<std::uint32_t*>(&value_raw);
  255|      0|
  256|      0|        phi::usize   start_address = address - m_StartingAddress;
  257|      0|        std::uint8_t first_byte    = (value_bits & 0b11111111'00000000'00000000'00000000) >> 24;
  258|      0|        std::uint8_t second_byte   = (value_bits & 0b00000000'11111111'00000000'00000000) >> 16;
  259|      0|        std::uint8_t third_byte    = (value_bits & 0b00000000'00000000'11111111'00000000) >> 8;
  260|      0|        std::uint8_t fourth_byte   = value_bits & 0b00000000'00000000'00000000'11111111;
  261|      0|
  262|      0|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  263|      0|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  264|      0|        m_Values.at((start_address + 2u).get()).unsigned_value = third_byte;
  265|      0|        m_Values.at((start_address + 3u).get()).unsigned_value = fourth_byte;
  266|      0|
  267|      0|        return true;
  268|      0|    }
  269|       |
  270|       |    phi::Boolean MemoryBlock::StoreDouble(phi::usize address, phi::f64 value)
  271|      0|    {
  272|      0|        if (!IsAddressValid(address, 8u))
  273|      0|        {
  274|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  275|      0|            return false;
  276|      0|        }
  277|      0|
  278|      0|        double value_raw = value.get();
  279|      0|
  280|      0|        std::uint64_t value_bits = *reinterpret_cast<std::uint64_t*>(&value_raw);
  281|      0|
  282|      0|        std::uint32_t first_bits = value_bits & 0xFFFFFFFF;
  283|      0|        std::uint32_t last_bits  = value_bits >> 32;
  284|      0|
  285|      0|        float first_value = *reinterpret_cast<float*>(&first_bits);
  286|      0|        float last_value  = *reinterpret_cast<float*>(&last_bits);
  287|      0|
  288|      0|        StoreFloat(address, first_value);
  289|      0|        StoreFloat(address + 4u, last_value);
  290|      0|
  291|      0|        return true;
  292|      0|    }
  293|       |
  294|       |    phi::Boolean MemoryBlock::IsAddressValid(phi::usize address, phi::usize size) const
  295|  5.06k|    {
  296|  5.06k|        return address >= m_StartingAddress &&
  297|  5.06k|               (address + size) <= (m_StartingAddress + m_Values.size());
  298|  5.06k|    }
  299|       |
  300|       |    void MemoryBlock::Clear()
  301|  16.5k|    {
  302|  16.5k|        for (auto& val : m_Values)
  303|  16.5M|        {
  304|  16.5M|            val.signed_value = 0;
  305|  16.5M|        }
  306|  16.5k|    }
  307|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Instruction.cpp:
    1|       |#include "DLX/Instruction.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include <Phi/Core/Assert.hpp>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    Instruction::Instruction(const InstructionInfo& info)
    9|       |        : m_Info(info)
   10|  76.9k|    {}
   11|       |
   12|       |    void Instruction::SetArgument(phi::u8 argument_number, InstructionArg argument)
   13|   152k|    {
   14|   152k|        PHI_ASSERT(argument_number < 3u);
   15|   152k|
   16|   152k|        switch (argument_number.get())
   17|   152k|        {
   18|  60.7k|            case 0u:
   19|  60.7k|                m_Arg1 = argument;
   20|  60.7k|                break;
   21|  54.5k|            case 1u:
   22|  54.5k|                m_Arg2 = argument;
   23|  54.5k|                break;
   24|  37.5k|            case 2u:
   25|  37.5k|                m_Arg3 = argument;
   26|  37.5k|                break;
   27|      0|            default:
   28|      0|                PHI_ASSERT_NOT_REACHED();
   29|   152k|        }
   30|   152k|    }
   31|       |
   32|       |    std::string Instruction::DebugInfo() const noexcept
   33|      0|    {
   34|      0|        return std::string("Instruction");
   35|      0|    }
   36|       |
   37|       |    void Instruction::Execute(Processor& processor) const noexcept
   38|   140k|    {
   39|   140k|        m_Info.Execute(processor, m_Arg1, m_Arg2, m_Arg3);
   40|   140k|    }
   41|       |
   42|       |    const InstructionInfo& Instruction::GetInfo() const
   43|   140k|    {
   44|   140k|        return m_Info;
   45|   140k|    }
   46|       |
   47|       |    const InstructionArg& Instruction::GetArg1() const
   48|      0|    {
   49|      0|        return m_Arg1;
   50|      0|    }
   51|       |
   52|       |    const InstructionArg& Instruction::GetArg2() const
   53|      0|    {
   54|      0|        return m_Arg2;
   55|      0|    }
   56|       |
   57|       |    const InstructionArg& Instruction::GetArg3() const
   58|      0|    {
   59|      0|        return m_Arg3;
   60|      0|    }
   61|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Parser.cpp:
    1|       |#include "DLX/Parser.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/OpCode.hpp"
    5|       |#include "DLX/ParserUtils.hpp"
    6|       |#include "DLX/RegisterNames.hpp"
    7|       |#include "DLX/Token.hpp"
    8|       |#include <Phi/Config/FunctionLikeMacro.hpp>
    9|       |#include <Phi/Core/Assert.hpp>
   10|       |#include <Phi/Core/Conversion.hpp>
   11|       |#include <Phi/Core/Log.hpp>
   12|       |#include <magic_enum.hpp>
   13|       |#include <algorithm>
   14|       |#include <limits>
   15|       |#include <optional>
   16|       |#include <regex>
   17|       |#include <stdexcept>
   18|       |
   19|       |using namespace phi::literals;
   20|       |
   21|       |namespace dlx
   22|       |{
   23|       |    Token ParseToken(std::string_view token, phi::u64 line_number, phi::u64 column)
   24|  1.33M|    {
   25|  1.33M|        // TODO: Parse the given number here directly?
   26|  1.33M|        if (token.at(0) == '#' && token.size() > 1)
   27|  41.0k|        {
   28|  41.0k|            return Token(Token::Type::ImmediateInteger, token, line_number, column);
   29|  41.0k|        }
   30|  1.29M|
   31|  1.29M|        if (token.at(0) == '/' || token.at(0) == ';')
   32|  12.1k|        {
   33|  12.1k|            return Token(Token::Type::Comment, token, line_number, column);
   34|  12.1k|        }
   35|  1.28M|
   36|  1.28M|        if (auto number = ParseNumber(token); number.has_value())
   37|  21.9k|        {
   38|  21.9k|            return Token(Token::Type::IntegerLiteral, token, line_number, column, number->get());
   39|  21.9k|        }
   40|  1.26M|
   41|  1.26M|        std::string token_upper(token.data(), token.size());
   42|  1.26M|        std::transform(token_upper.begin(), token_upper.end(), token_upper.begin(), ::toupper);
   43|  1.26M|
   44|  1.26M|        if (token_upper == "FPSR")
   45|      0|        {
   46|      0|            return Token(Token::Type::RegisterStatus, token, line_number, column);
   47|      0|        }
   48|  1.26M|
   49|  1.26M|        if (IntRegisterID id = StringToIntRegister(token_upper); id != IntRegisterID::None)
   50|   181k|        {
   51|   181k|            return Token(Token::Type::RegisterInt, token, line_number, column,
   52|   181k|                         static_cast<std::uint32_t>(id));
   53|   181k|        }
   54|  1.08M|
   55|  1.08M|        if (FloatRegisterID id = StringToFloatRegister(token_upper); id != FloatRegisterID::None)
   56|    524|        {
   57|    524|            return Token(Token::Type::RegisterFloat, token, line_number, column,
   58|    524|                         static_cast<std::uint32_t>(id));
   59|    524|        }
   60|  1.07M|
   61|  1.07M|        if (OpCode opcode = StringToOpCode(token_upper); opcode != OpCode::NONE)
   62|  78.1k|        {
   63|  78.1k|            return Token(Token::Type::OpCode, token, line_number, column,
   64|  78.1k|                         static_cast<std::uint32_t>(opcode));
   65|  78.1k|        }
   66|  1.00M|
   67|  1.00M|        return Token(Token::Type::LabelIdentifier, token, line_number, column);
   68|  1.00M|    }
   69|       |
   70|       |    std::vector<Token> Parser::Tokenize(std::string_view source)
   71|  16.5k|    {
   72|  16.5k|        std::vector<Token> tokens{};
   73|  16.5k|        tokens.reserve(5);
   74|  16.5k|
   75|  16.5k|        std::string current_token;
   76|  16.5k|        current_token.reserve(10);
   77|  16.5k|
   78|  16.5k|        phi::u64 current_line_number{1u};
   79|  16.5k|        phi::u64 current_column{1u};
   80|  16.5k|        phi::u64 token_begin{0u};
   81|  16.5k|
   82|  16.5k|        phi::Boolean parsing_comment{false};
   83|  16.5k|
   84|  23.2M|        for (phi::usize i{0u}; i < source.length(); ++i)
   85|  23.2M|        {
   86|  23.2M|            const char c{source.at(i.get())};
   87|  23.2M|
   88|  23.2M|            if (c == '\n')
   89|   233k|            {
   90|   233k|                if (current_token.empty())
   91|  66.7k|                {
   92|  66.7k|                    // Skip empty lines
   93|  66.7k|                    tokens.emplace_back(Token::Type::NewLine, source.substr(token_begin.get(), 1),
   94|  66.7k|                                        current_line_number, current_column - 1u);
   95|  66.7k|
   96|  66.7k|                    parsing_comment = false;
   97|  66.7k|                    current_line_number += 1u;
   98|  66.7k|                    current_column = 1u;
   99|  66.7k|                    continue;
  100|  66.7k|                }
  101|   166k|
  102|   166k|                // Otherwise a new line separates tokens
  103|   166k|                tokens.emplace_back(
  104|   166k|                        ParseToken(source.substr(token_begin.get(), current_token.length()),
  105|   166k|                                   current_line_number, current_column - current_token.length()));
  106|   166k|
  107|   166k|                token_begin = i;
  108|   166k|
  109|   166k|                tokens.emplace_back(Token::Type::NewLine, source.substr(token_begin.get(), 1),
  110|   166k|                                    current_line_number, current_column - 1u);
  111|   166k|
  112|   166k|                current_token.clear();
  113|   166k|                parsing_comment = false;
  114|   166k|                current_line_number += 1u;
  115|   166k|                current_column = 0u;
  116|   166k|            }
  117|  23.0M|            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  118|  23.0M|            else if (c == '/' || c == ';')
  119|   323k|            {
  120|   323k|                if (current_token.empty())
  121|  12.1k|                {
  122|  12.1k|                    token_begin = i;
  123|  12.1k|                }
  124|   323k|
  125|   323k|                parsing_comment = true;
  126|   323k|                current_token.push_back(c);
  127|   323k|            }
  128|  22.6M|            else if (parsing_comment)
  129|  11.2M|            {
  130|  11.2M|                // simply append the character
  131|  11.2M|                current_token.push_back(c);
  132|  11.2M|            }
  133|  11.4M|            else
  134|  11.4M|            {
  135|  11.4M|                // Not parsing a comment
  136|  11.4M|
  137|  11.4M|                switch (c)
  138|  11.4M|                {
  139|  1.39M|                    case ' ':
  140|  1.39M|                    case '\t':
  141|  1.39M|                    case '\v':
  142|  1.39M|                        if (current_token.empty())
  143|   998k|                        {
  144|   998k|                            current_column += 1u;
  145|   998k|                            // We haven't found any usable character for the current token so just skip the whitespace.
  146|   998k|                            continue;
  147|   998k|                        }
  148|   400k|
  149|   400k|                        // Otherwise a whitespace separates tokens
  150|   400k|                        tokens.emplace_back(ParseToken(
  151|   400k|                                source.substr(token_begin.get(), current_token.length()),
  152|   400k|                                current_line_number, current_column - current_token.length()));
  153|   400k|                        current_token.clear();
  154|   400k|                        break;
  155|   712k|                    case ':':
  156|   712k|                        // Need to parse label names together with their colon
  157|   712k|                        if (!current_token.empty())
  158|   631k|                        {
  159|   631k|                            current_token.push_back(c);
  160|   631k|                            tokens.emplace_back(ParseToken(
  161|   631k|                                    source.substr(token_begin.get(), current_token.length()),
  162|   631k|                                    current_line_number,
  163|   631k|                                    current_column + 1u - current_token.length()));
  164|   631k|
  165|   631k|                            current_token.clear();
  166|   631k|                        }
  167|  80.5k|                        else
  168|  80.5k|                        {
  169|  80.5k|                            // Orphan colon
  170|  80.5k|                            token_begin = i;
  171|  80.5k|
  172|  80.5k|                            tokens.emplace_back(Token::Type::Colon,
  173|  80.5k|                                                source.substr(token_begin.get(), 1),
  174|  80.5k|                                                current_line_number, current_column);
  175|  80.5k|                        }
  176|   712k|                        break;
  177|   400k|                    case ',':
  178|   192k|                    case '(':
  179|   192k|                    case ')':
  180|   192k|                        if (!current_token.empty())
  181|   126k|                        {
  182|   126k|                            tokens.emplace_back(ParseToken(
  183|   126k|                                    source.substr(token_begin.get(), current_token.length()),
  184|   126k|                                    current_line_number, current_column - current_token.length()));
  185|   126k|
  186|   126k|                            current_token.clear();
  187|   126k|                        }
  188|   192k|
  189|   192k|                        Token::Type type;
  190|   192k|                        switch (c)
  191|   192k|                        {
  192|   102k|                            case ',':
  193|   102k|                                type = Token::Type::Comma;
  194|   102k|                                break;
  195|  38.6k|                            case '(':
  196|  38.6k|                                type = Token::Type::OpenBracket;
  197|  38.6k|                                break;
  198|  51.8k|                            case ')':
  199|  51.8k|                                type = Token::Type::ClosingBracket;
  200|  51.8k|                                break;
  201|      0|                            default:
  202|      0|                                PHI_ASSERT_NOT_REACHED();
  203|      0|                                break;
  204|   192k|                        }
  205|   192k|
  206|   192k|                        token_begin = i;
  207|   192k|
  208|   192k|                        tokens.emplace_back(type, source.substr(token_begin.get(), 1),
  209|   192k|                                            current_line_number, current_column);
  210|   192k|                        break;
  211|   192k|
  212|  9.14M|                    default:
  213|  9.14M|                        if (current_token.empty())
  214|  1.32M|                        {
  215|  1.32M|                            token_begin = i;
  216|  1.32M|                        }
  217|  9.14M|
  218|  9.14M|                        // simply append the character
  219|  9.14M|                        current_token.push_back(c);
  220|  11.4M|                }
  221|  11.4M|            }
  222|  23.2M|
  223|  23.2M|            current_column += 1u;
  224|  22.1M|        }
  225|  16.5k|
  226|  16.5k|        // Checked the entire string. Parse whats left if anything
  227|  16.5k|        if (!current_token.empty())
  228|  11.4k|        {
  229|  11.4k|            tokens.emplace_back(ParseToken(source.substr(token_begin.get(), current_token.length()),
  230|  11.4k|                                           current_line_number,
  231|  11.4k|                                           current_column - current_token.length()));
  232|  11.4k|        }
  233|  16.5k|
  234|  16.5k|        return tokens;
  235|  16.5k|    }
  236|       |
  237|       |    static phi::Boolean has_x_more_tokens(const std::vector<Token>& tokens, phi::usize index,
  238|       |                                          phi::u64 x)
  239|   199k|    {
  240|   199k|        return index + x <= tokens.size();
  241|   199k|    }
  242|       |
  243|       |    static phi::Boolean has_one_more_token(const std::vector<Token>& tokens, phi::usize index)
  244|   192k|    {
  245|   192k|        return has_x_more_tokens(tokens, index, 1u);
  246|   192k|    }
  247|       |
  248|       |    static phi::Boolean next_token_is(const std::vector<Token>& tokens, phi::usize index,
  249|       |                                      Token::Type token_type)
  250|      0|    {
  251|      0|        PHI_ASSERT(has_one_more_token(tokens, index));
  252|      0|
  253|      0|        const auto& next_token = tokens.at((index + 1u).get());
  254|      0|
  255|      0|        return next_token.GetType() == token_type;
  256|      0|    }
  257|       |
  258|       |    static phi::Boolean has_one_more_token_of_type(const std::vector<Token>& tokens,
  259|       |                                                   phi::usize index, Token::Type token_type)
  260|      0|    {
  261|      0|        if (!has_one_more_token(tokens, index))
  262|      0|        {
  263|      0|            return false;
  264|      0|        }
  265|      0|
  266|      0|        return (next_token_is(tokens, index, token_type));
  267|      0|    }
  268|       |
  269|       |    static void AddParseError(ParsedProgram& program, const std::string& message)
  270|   730k|    {
  271|   730k|        ParseError err;
  272|   730k|        err.message = message;
  273|   730k|
  274|   730k|        //PHI_LOG_ERROR("Parsing error: {}", message);
  275|   730k|
  276|   730k|        program.m_ParseErrors.emplace_back(err);
  277|   730k|    }
  278|       |
  279|       |    static std::optional<InstructionArg> parse_instruction_argument(
  280|       |            const Token& token, ArgumentType expected_argument_type,
  281|       |            const std::vector<Token>& tokens, phi::usize& index, ParsedProgram& program)
  282|   174k|    {
  283|   174k|        // PHI_LOG_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
  284|   174k|        //              magic_enum::enum_name(expected_argument_type));
  285|   174k|
  286|   174k|        switch (token.GetType())
  287|   174k|        {
  288|  7.42k|            case Token::Type::IntegerLiteral: {
  289|  7.42k|                if (!ArgumentTypeIncludes(expected_argument_type,
  290|  7.42k|                                          ArgumentType::AddressDisplacement))
  291|    765|                {
  292|    765|                    AddParseError(program,
  293|    765|                                  fmt::format("Expected {} but got address displacement",
  294|    765|                                              magic_enum::enum_name(expected_argument_type)));
  295|    765|                    return {};
  296|    765|                }
  297|  6.65k|
  298|  6.65k|                // Parse address displacement
  299|  6.65k|                auto displacement_value = ParseNumber(token.GetText());
  300|  6.65k|                if (!displacement_value)
  301|      0|                {
  302|      0|                    AddParseError(program,
  303|      0|                                  "Failed to parse displacement value for Address displacement");
  304|      0|                    return {};
  305|      0|                }
  306|  6.65k|                std::int16_t value = displacement_value.value().get();
  307|  6.65k|
  308|  6.65k|                if (!has_x_more_tokens(tokens, index, 3u))
  309|    133|                {
  310|    133|                    AddParseError(program,
  311|    133|                                  "Not enough arguments left to parse address displacement");
  312|    133|                    return {};
  313|    133|                }
  314|  6.52k|
  315|  6.52k|                const Token& first_token  = tokens.at(index.get());
  316|  6.52k|                const Token& second_token = tokens.at((index + 1u).get());
  317|  6.52k|                const Token& third_token  = tokens.at((index + 2u).get());
  318|  6.52k|
  319|  6.52k|                if (first_token.GetType() != Token::Type::OpenBracket)
  320|    210|                {
  321|    210|                    AddParseError(program, "Expected open bracket");
  322|    210|                    return {};
  323|    210|                }
  324|  6.31k|
  325|  6.31k|                // Second token is the register
  326|  6.31k|                if (second_token.GetType() != Token::Type::RegisterInt)
  327|    353|                {
  328|    353|                    AddParseError(program, "Expected IntRegister");
  329|    353|                    return {};
  330|    353|                }
  331|  5.96k|
  332|  5.96k|                if (third_token.GetType() != Token::Type::ClosingBracket)
  333|     54|                {
  334|     54|                    AddParseError(program, "Expected closing bracket");
  335|     54|                    return {};
  336|     54|                }
  337|  5.90k|
  338|  5.90k|                index += 3u;
  339|  5.90k|
  340|  5.90k|                //PHI_LOG_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
  341|  5.90k|                //             value, magic_enum::enum_name(reg_id));
  342|  5.90k|
  343|  5.90k|                return ConstructInstructionArgAddressDisplacement(
  344|  5.90k|                        static_cast<IntRegisterID>(second_token.GetHint()), value);
  345|  5.90k|            }
  346|   122k|            case Token::Type::RegisterInt: {
  347|   122k|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  348|    848|                {
  349|    848|                    AddParseError(program,
  350|    848|                                  fmt::format("Got IntRegister but expected '{}'",
  351|    848|                                              magic_enum::enum_name(expected_argument_type)));
  352|    848|                    return {};
  353|    848|                }
  354|   121k|
  355|   121k|                //PHI_LOG_INFO("Parsed identifier as int register {}",
  356|   121k|                //             magic_enum::enum_name(reg_id));
  357|   121k|
  358|   121k|                return ConstructInstructionArgRegisterInt(
  359|   121k|                        static_cast<IntRegisterID>(token.GetHint()));
  360|   121k|            }
  361|   121k|            case Token::Type::RegisterFloat: {
  362|     12|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  363|     10|                {
  364|     10|                    AddParseError(program,
  365|     10|                                  fmt::format("Got FloatRegister but expected '{}'",
  366|     10|                                              magic_enum::enum_name(expected_argument_type)));
  367|     10|                    return {};
  368|     10|                }
  369|      2|
  370|      2|                //PHI_LOG_INFO("Parsed identifier as float register {}",
  371|      2|                //             magic_enum::enum_name(float_reg_id));
  372|      2|
  373|      2|                return ConstructInstructionArgRegisterFloat(
  374|      2|                        static_cast<FloatRegisterID>(token.GetHint()));
  375|      2|            }
  376|      2|            case Token::Type::RegisterStatus: {
  377|      0|            }
  378|  16.3k|            case Token::Type::LabelIdentifier: {
  379|  16.3k|                // Parse as Label
  380|  16.3k|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  381|  14.0k|                {
  382|  14.0k|                    AddParseError(program,
  383|  14.0k|                                  fmt::format("Got Label but expected '{}'",
  384|  14.0k|                                              magic_enum::enum_name(expected_argument_type)));
  385|  14.0k|                    return {};
  386|  14.0k|                }
  387|  2.31k|
  388|  2.31k|                if (!IsValidIdentifier(token.GetText()))
  389|    363|                {
  390|    363|                    AddParseError(program, fmt::format("Invalid label identifier found {}",
  391|    363|                                                       token.GetText()));
  392|    363|                    return {};
  393|    363|                }
  394|  1.95k|
  395|  1.95k|                //PHI_LOG_INFO("Parsed Label identifier as '{}'", token.GetText());
  396|  1.95k|
  397|  1.95k|                return ConstructInstructionArgLabel(token.GetText());
  398|  1.95k|            }
  399|  25.4k|            case Token::Type::ImmediateInteger: {
  400|  25.4k|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  401|    375|                {
  402|    375|                    AddParseError(program,
  403|    375|                                  fmt::format("Got ImmediateInteger but expected '{}'",
  404|    375|                                              magic_enum::enum_name(expected_argument_type)));
  405|    375|                    return {};
  406|    375|                }
  407|  25.0k|
  408|  25.0k|                auto parsed_value = ParseNumber(token.GetText().substr(1));
  409|  25.0k|                if (!parsed_value)
  410|  1.32k|                {
  411|  1.32k|                    AddParseError(program, "Failed to parse immediate Integer value");
  412|  1.32k|                    return {};
  413|  1.32k|                }
  414|  23.7k|
  415|  23.7k|                //PHI_LOG_INFO("Parsed Immediate Integer with value {}", parsed_value.value().get());
  416|  23.7k|
  417|  23.7k|                return ConstructInstructionArgImmediateValue(parsed_value.value().get());
  418|  23.7k|            }
  419|  23.7k|            default:
  420|  3.05k|                AddParseError(program,
  421|  3.05k|                              fmt::format("Unexpected token of type '{}'", token.GetTypeName()));
  422|  3.05k|                return {};
  423|   174k|        }
  424|   174k|    }
  425|       |
  426|       |    static void consume_x_tokens(phi::usize& index, phi::usize x)
  427|  1.82M|    {
  428|  1.82M|        index += x;
  429|  1.82M|    }
  430|       |
  431|       |    static void consume_current_token(phi::usize& index)
  432|  1.82M|    {
  433|  1.82M|        consume_x_tokens(index, 1u);
  434|  1.82M|    }
  435|       |
  436|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::vector<Token>& tokens)
  437|  16.5k|    {
  438|  16.5k|        ParsedProgram program;
  439|  16.5k|
  440|  16.5k|        program.m_Tokens = tokens;
  441|  16.5k|
  442|  16.5k|        phi::Boolean line_has_instruction{false};
  443|  16.5k|
  444|  1.64M|        for (phi::usize index{0u}; index < tokens.size();)
  445|  1.63M|        {
  446|  1.63M|            Token& current_token = tokens.at(index.get());
  447|  1.63M|
  448|  1.63M|            consume_current_token(index);
  449|  1.63M|
  450|  1.63M|            //PHI_LOG_INFO("Parsing '{}'", current_token.DebugInfo());
  451|  1.63M|
  452|  1.63M|            switch (current_token.GetType())
  453|  1.63M|            {
  454|      0|                // Ignore comments
  455|  12.0k|                case Token::Type::Comment:
  456|  12.0k|                    //PHI_LOG_DEBUG("Ignoring comment");
  457|  12.0k|                    break;
  458|   231k|                case Token::Type::NewLine:
  459|   231k|                    //PHI_LOG_DEBUG("Ignoring newline");
  460|   231k|                    line_has_instruction = false;
  461|   231k|                    break;
  462|   985k|                case Token::Type::LabelIdentifier: {
  463|   985k|                    if (line_has_instruction)
  464|  1.54k|                    {
  465|  1.54k|                        AddParseError(program, "Expected new line but got label identifer");
  466|  1.54k|                        break;
  467|  1.54k|                    }
  468|   983k|
  469|   983k|                    // Handle jump labels
  470|   983k|                    // Check if the last character of the identifier is a colon
  471|   983k|                    if (current_token.GetText().at(current_token.GetText().size() - 1) == ':')
  472|   627k|                    {
  473|   627k|                        std::string_view label_name = current_token.GetText().substr(
  474|   627k|                                0, current_token.GetText().size() - 1);
  475|   627k|
  476|   627k|                        program.m_JumpData[label_name] =
  477|   627k|                                static_cast<std::uint32_t>(program.m_Instructions.size());
  478|   627k|
  479|   627k|                        //PHI_LOG_INFO("Added jump label {} -> {}", label_name,
  480|   627k|                        //             program.m_Instructions.size());
  481|   627k|                    }
  482|   356k|                    else
  483|   356k|                    {
  484|   356k|                        AddParseError(program, "Label identifier is missing a colon");
  485|   356k|                    }
  486|   983k|
  487|   983k|                    break;
  488|   983k|                }
  489|   983k|                case Token::Type::OpCode: {
  490|  77.2k|                    if (line_has_instruction)
  491|    317|                    {
  492|    317|                        AddParseError(program, "Expected new line but got op code");
  493|    317|                        break;
  494|    317|                    }
  495|  76.9k|
  496|  76.9k|                    // Handle normal instructions
  497|  76.9k|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  498|  76.9k|
  499|  76.9k|                    //PHI_LOG_INFO("Instruction opcode: {}", magic_enum::enum_name(opcode));
  500|  76.9k|
  501|  76.9k|                    const InstructionInfo& info = lib.LookUp(opcode);
  502|  76.9k|
  503|  76.9k|                    // Make sure we got no problems here
  504|  76.9k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  505|  76.9k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  506|  76.9k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  507|  76.9k|                    PHI_ASSERT(info.GetExecutor());
  508|  76.9k|
  509|  76.9k|                    phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  510|  76.9k|                    //PHI_LOG_INFO("Instruction requires {} arguments",
  511|  76.9k|                    //             number_of_argument_required.get());
  512|  76.9k|
  513|  76.9k|                    // Create instruction
  514|  76.9k|                    Instruction instruction(info);
  515|  76.9k|
  516|  76.9k|                    // Parse arguments
  517|   246k|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  518|   192k|                    {
  519|   192k|                        // Get next token
  520|   192k|                        if (!has_one_more_token(tokens, index))
  521|    268|                        {
  522|    268|                            AddParseError(
  523|    268|                                    program,
  524|    268|                                    fmt::format("Missing {} arguments for instruction {}",
  525|    268|                                                (number_of_argument_required - argument_num).get(),
  526|    268|                                                magic_enum::enum_name(opcode)));
  527|    268|                            break;
  528|    268|                        }
  529|   192k|
  530|   192k|                        current_token = tokens.at(index.get());
  531|   192k|                        consume_current_token(index);
  532|   192k|
  533|   192k|                        // Skip commas
  534|   192k|                        if (current_token.GetType() == Token::Type::Comma)
  535|  16.3k|                        {
  536|  16.3k|                            //PHI_LOG_DEBUG("Skipping comma");
  537|  16.3k|                            continue;
  538|  16.3k|                        }
  539|   176k|
  540|   176k|                        if (current_token.GetType() == Token::Type::NewLine)
  541|  1.89k|                        {
  542|  1.89k|                            AddParseError(program, "Unexpected end of line");
  543|  1.89k|                            break;
  544|  1.89k|                        }
  545|   174k|
  546|   174k|                        std::optional<InstructionArg> optional_parsed_argument =
  547|   174k|                                parse_instruction_argument(current_token,
  548|   174k|                                                           info.GetArgumentType(argument_num),
  549|   174k|                                                           tokens, index, program);
  550|   174k|                        if (!optional_parsed_argument.has_value())
  551|  21.5k|                        {
  552|  21.5k|                            AddParseError(program, fmt::format("Failed to parse argument number {}",
  553|  21.5k|                                                               argument_num.get()));
  554|  21.5k|                            break;
  555|  21.5k|                        }
  556|   152k|
  557|   152k|                        // Successfully parsed one argument
  558|   152k|                        InstructionArg parsed_argument = optional_parsed_argument.value();
  559|   152k|
  560|   152k|                        instruction.SetArgument(argument_num, parsed_argument);
  561|   152k|                        argument_num++;
  562|   152k|
  563|   152k|                        //PHI_LOG_INFO("Successfully parsed argument {}", argument_num.get());
  564|   152k|                    }
  565|  76.9k|
  566|  76.9k|                    // Only add the instruction if we got no parsing errors
  567|  76.9k|                    if (program.m_ParseErrors.empty())
  568|  9.28k|                    {
  569|  9.28k|                        //PHI_LOG_INFO("Successfully parsed instruction '{}'",
  570|  9.28k|                        //            instruction.DebugInfo());
  571|  9.28k|                        program.m_Instructions.emplace_back(instruction);
  572|  9.28k|                        line_has_instruction = true;
  573|  9.28k|                    }
  574|  76.9k|                    break;
  575|  76.9k|                }
  576|  76.9k|
  577|   326k|                default:
  578|   326k|                    AddParseError(program, "Unexpected token");
  579|   326k|                    break;
  580|  1.63M|            }
  581|  1.63M|        }
  582|  16.5k|
  583|  16.5k|        return program;
  584|  16.5k|    }
  585|       |
  586|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::string_view source)
  587|  16.5k|    {
  588|  16.5k|        std::vector<Token> tokens = Tokenize(source);
  589|  16.5k|        return Parse(lib, tokens);
  590|  16.5k|    }
  591|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/OpCode.cpp:
    1|       |#include "DLX/OpCode.hpp"
    2|       |
    3|       |#include <magic_enum.hpp>
    4|       |#include <algorithm>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    OpCode StringToOpCode(std::string_view token)
    9|  1.07M|    {
   10|  1.07M|        std::optional<OpCode> opcode_casted = magic_enum::enum_cast<OpCode>(token);
   11|  1.07M|        if (opcode_casted.has_value())
   12|  78.8k|        {
   13|  78.8k|            // TODO: Bit of a hacky way around magic_enum begin able to cast every member...
   14|  78.8k|            if (opcode_casted.value() == OpCode::NUMBER_OF_ELEMENTS)
   15|      5|            {
   16|      5|                return OpCode::NONE;
   17|      5|            }
   18|  78.8k|            return opcode_casted.value();
   19|  78.8k|        }
   20|  1.00M|
   21|  1.00M|        // None found
   22|  1.00M|        return OpCode::NONE;
   23|  1.00M|    }
   24|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionArg.cpp:
    1|       |#include "DLX/InstructionArg.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    InstructionArg::InstructionArg()
    6|       |        : m_Type(ArgumentType::None)
    7|       |        , address_displacement()
    8|   383k|    {}
    9|       |
   10|       |    ArgumentType InstructionArg::GetType() const
   11|   432k|    {
   12|   432k|        return m_Type;
   13|   432k|    }
   14|       |
   15|       |    std::string InstructionArg::DebugInfo() const
   16|      0|    {
   17|      0|        return "InstructionArgument";
   18|      0|    }
   19|       |
   20|       |    const InstructionArg::RegisterInt& InstructionArg::AsRegisterInt() const
   21|  97.1k|    {
   22|  97.1k|        PHI_ASSERT(m_Type == ArgumentType::IntRegister);
   23|  97.1k|
   24|  97.1k|        return register_int;
   25|  97.1k|    }
   26|       |
   27|       |    const InstructionArg::RegisterFloat& InstructionArg::AsRegisterFloat() const
   28|      0|    {
   29|      0|        PHI_ASSERT(m_Type == ArgumentType::FloatRegister);
   30|      0|
   31|      0|        return register_float;
   32|      0|    }
   33|       |
   34|       |    const InstructionArg::ImmediateValue& InstructionArg::AsImmediateValue() const
   35|    365|    {
   36|    365|        PHI_ASSERT(m_Type == ArgumentType::ImmediateInteger);
   37|    365|
   38|    365|        return immediate_value;
   39|    365|    }
   40|       |
   41|       |    const InstructionArg::AddressDisplacement& InstructionArg::AsAddressDisplacement() const
   42|  5.04k|    {
   43|  5.04k|        PHI_ASSERT(m_Type == ArgumentType::AddressDisplacement);
   44|  5.04k|
   45|  5.04k|        return address_displacement;
   46|  5.04k|    }
   47|       |
   48|       |    const InstructionArg::Label& InstructionArg::AsLabel() const
   49|  80.0k|    {
   50|  80.0k|        PHI_ASSERT(m_Type == ArgumentType::Label);
   51|  80.0k|
   52|  80.0k|        return label;
   53|  80.0k|    }
   54|       |
   55|       |    phi::Boolean operator==(const InstructionArg& lhs, const InstructionArg& rhs)
   56|      0|    {
   57|      0|        if (lhs.GetType() != rhs.GetType())
   58|      0|        {
   59|      0|            return false;
   60|      0|        }
   61|      0|
   62|      0|        switch (lhs.GetType())
   63|      0|        {
   64|      0|            case ArgumentType::AddressDisplacement:
   65|      0|                return (lhs.AsAddressDisplacement().displacement ==
   66|      0|                        rhs.AsAddressDisplacement().displacement) &&
   67|      0|                       (lhs.AsAddressDisplacement().register_id ==
   68|      0|                        rhs.AsAddressDisplacement().register_id);
   69|      0|            case ArgumentType::ImmediateInteger:
   70|      0|                return lhs.AsImmediateValue().signed_value == rhs.AsImmediateValue().signed_value;
   71|      0|            case ArgumentType::IntRegister:
   72|      0|                return lhs.AsRegisterInt().register_id == rhs.AsRegisterInt().register_id;
   73|      0|            case ArgumentType::FloatRegister:
   74|      0|                return lhs.AsRegisterFloat().register_id == rhs.AsRegisterFloat().register_id;
   75|      0|            case ArgumentType::Label:
   76|      0|                return lhs.AsLabel().label_name == rhs.AsLabel().label_name;
   77|      0|            case ArgumentType::None:
   78|      0|                return true;
   79|      0|            default:
   80|      0|                PHI_ASSERT_NOT_REACHED();
   81|      0|                break;
   82|      0|        }
   83|      0|
   84|      0|        PHI_ASSERT_NOT_REACHED();
   85|      0|        return false;
   86|      0|    }
   87|       |
   88|       |    phi::Boolean operator!=(const InstructionArg& lhs, const InstructionArg& rhs)
   89|      0|    {
   90|      0|        return !(lhs == rhs);
   91|      0|    }
   92|       |
   93|       |    InstructionArg ConstructInstructionArgRegisterInt(IntRegisterID id)
   94|   121k|    {
   95|   121k|        InstructionArg arg;
   96|   121k|        arg.m_Type                   = ArgumentType::IntRegister;
   97|   121k|        arg.register_int.register_id = id;
   98|   121k|        return arg;
   99|   121k|    }
  100|       |
  101|       |    InstructionArg ConstructInstructionArgRegisterFloat(FloatRegisterID id)
  102|      2|    {
  103|      2|        InstructionArg arg;
  104|      2|        arg.m_Type                     = ArgumentType::FloatRegister;
  105|      2|        arg.register_float.register_id = id;
  106|      2|        return arg;
  107|      2|    }
  108|       |
  109|       |    InstructionArg ConstructInstructionArgImmediateValue(std::int16_t value)
  110|  23.7k|    {
  111|  23.7k|        InstructionArg arg;
  112|  23.7k|        arg.m_Type                       = ArgumentType::ImmediateInteger;
  113|  23.7k|        arg.immediate_value.signed_value = value;
  114|  23.7k|        return arg;
  115|  23.7k|    }
  116|       |
  117|       |    InstructionArg ConstructInstructionArgAddressDisplacement(IntRegisterID id,
  118|       |                                                              phi::i32      displacement)
  119|  5.90k|    {
  120|  5.90k|        InstructionArg arg;
  121|  5.90k|        arg.m_Type                            = ArgumentType::AddressDisplacement;
  122|  5.90k|        arg.address_displacement.register_id  = id;
  123|  5.90k|        arg.address_displacement.displacement = displacement;
  124|  5.90k|        return arg;
  125|  5.90k|    }
  126|       |
  127|       |    InstructionArg ConstructInstructionArgLabel(std::string_view label_name)
  128|  1.95k|    {
  129|  1.95k|        InstructionArg arg;
  130|  1.95k|        arg.m_Type           = ArgumentType::Label;
  131|  1.95k|        arg.label.label_name = label_name;
  132|  1.95k|        return arg;
  133|  1.95k|    }
  134|       |} // namespace dlx

