/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Processor.cpp:
    1|       |#include "DLX/Processor.hpp"
    2|       |
    3|       |#include "DLX/FloatRegister.hpp"
    4|       |#include "DLX/InstructionInfo.hpp"
    5|       |#include "DLX/Parser.hpp"
    6|       |#include "Phi/Core/Log.hpp"
    7|       |#include "Phi/Core/Types.hpp"
    8|       |
    9|       |namespace dlx
   10|       |{
   11|       |    static phi::Boolean RegisterAccessTypeMatches(RegisterAccessType expected_access,
   12|       |                                                  RegisterAccessType access)
   13|      0|    {
   14|      0|        PHI_ASSERT(access == RegisterAccessType::Signed || access == RegisterAccessType::Unsigned ||
   15|      0|                   access == RegisterAccessType::Float || access == RegisterAccessType::Double);
   16|      0|
   17|      0|        switch (expected_access)
   18|      0|        {
   19|      0|            case RegisterAccessType::Ignored:
   20|      0|                return true;
   21|      0|            case RegisterAccessType::None:
   22|      0|                return false;
   23|      0|            case RegisterAccessType::MixedFloatDouble:
   24|      0|                return access == RegisterAccessType::Float || access == RegisterAccessType::Double;
   25|      0|            default:
   26|      0|                return expected_access == access;
   27|      0|        }
   28|      0|    }
   29|       |
   30|       |    Processor::Processor()
   31|       |        : m_MemoryBlock(1000u, 1000u)
   32|      0|    {
   33|      0|        // Mark R0 as ready only
   34|      0|        m_IntRegisters.at(0).SetReadOnly(true);
   35|      0|    }
   36|       |
   37|       |    IntRegister& Processor::GetIntRegister(IntRegisterID id)
   38|      0|    {
   39|      0|        PHI_ASSERT(id != IntRegisterID::None);
   40|      0|        std::underlying_type_t<IntRegisterID> id_value =
   41|      0|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   42|      0|
   43|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   44|      0|
   45|      0|        return m_IntRegisters.at(id_value);
   46|      0|    }
   47|       |
   48|       |    const IntRegister& Processor::GetIntRegister(IntRegisterID id) const
   49|      0|    {
   50|      0|        PHI_ASSERT(id != IntRegisterID::None);
   51|      0|        std::underlying_type_t<IntRegisterID> id_value =
   52|      0|                static_cast<std::underlying_type_t<IntRegisterID>>(id);
   53|      0|
   54|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
   55|      0|
   56|      0|        return m_IntRegisters.at(id_value);
   57|      0|    }
   58|       |
   59|       |    phi::i32 Processor::IntRegisterGetSignedValue(IntRegisterID id) const
   60|      0|    {
   61|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   62|      0|        {
   63|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   64|      0|        }
   65|      0|
   66|      0|        return GetIntRegister(id).GetSignedValue();
   67|      0|    }
   68|       |
   69|       |    phi::u32 Processor::IntRegisterGetUnsignedValue(IntRegisterID id) const
   70|      0|    {
   71|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
   72|      0|                                       RegisterAccessType::Unsigned))
   73|      0|        {
   74|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   75|      0|        }
   76|      0|
   77|      0|        return GetIntRegister(id).GetUnsignedValue();
   78|      0|    }
   79|       |
   80|       |    void Processor::IntRegisterSetSignedValue(IntRegisterID id, phi::i32 value)
   81|      0|    {
   82|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Signed))
   83|      0|        {
   84|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
   85|      0|        }
   86|      0|
   87|      0|        IntRegister& reg = GetIntRegister(id);
   88|      0|
   89|      0|        if (reg.IsReadOnly())
   90|      0|        {
   91|      0|            return;
   92|      0|        }
   93|      0|
   94|      0|        reg.SetSignedValue(value);
   95|      0|    }
   96|       |
   97|       |    void Processor::IntRegisterSetUnsignedValue(IntRegisterID id, phi::u32 value)
   98|      0|    {
   99|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType,
  100|      0|                                       RegisterAccessType::Unsigned))
  101|      0|        {
  102|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  103|      0|        }
  104|      0|
  105|      0|        IntRegister& reg = GetIntRegister(id);
  106|      0|
  107|      0|        if (reg.IsReadOnly())
  108|      0|        {
  109|      0|            return;
  110|      0|        }
  111|      0|
  112|      0|        reg.SetUnsignedValue(value);
  113|      0|    }
  114|       |
  115|       |    FloatRegister& Processor::GetFloatRegister(FloatRegisterID id)
  116|      0|    {
  117|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  118|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  119|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  120|      0|
  121|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  122|      0|
  123|      0|        return m_FloatRegisters.at(id_value);
  124|      0|    }
  125|       |
  126|       |    const FloatRegister& Processor::GetFloatRegister(FloatRegisterID id) const
  127|      0|    {
  128|      0|        PHI_ASSERT(id != FloatRegisterID::None);
  129|      0|        std::underlying_type_t<FloatRegisterID> id_value =
  130|      0|                static_cast<std::underlying_type_t<FloatRegisterID>>(id);
  131|      0|
  132|      0|        PHI_ASSERT(id_value >= 0 && id_value <= 31);
  133|      0|
  134|      0|        return m_FloatRegisters.at(id_value);
  135|      0|    }
  136|       |
  137|       |    [[nodiscard]] phi::f32 Processor::FloatRegisterGetFloatValue(FloatRegisterID id) const
  138|      0|    {
  139|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  140|      0|        {
  141|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  142|      0|        }
  143|      0|
  144|      0|        const FloatRegister& reg = GetFloatRegister(id);
  145|      0|
  146|      0|        return reg.GetValue();
  147|      0|    }
  148|       |
  149|       |    [[nodiscard]] phi::f64 Processor::FloatRegisterGetDoubleValue(FloatRegisterID id)
  150|      0|    {
  151|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  152|      0|        {
  153|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  154|      0|        }
  155|      0|
  156|      0|        if (id == FloatRegisterID::F31)
  157|      0|        {
  158|      0|            Raise(Exception::RegisterOutOfBounds);
  159|      0|            return phi::f64(0.0);
  160|      0|        }
  161|      0|
  162|      0|        const FloatRegister& first_reg = GetFloatRegister(id);
  163|      0|        const FloatRegister& second_reg =
  164|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  165|      0|
  166|      0|        const float first_value  = first_reg.GetValue().get();
  167|      0|        const float second_value = second_reg.GetValue().get();
  168|      0|
  169|      0|        const std::uint32_t first_value_bits =
  170|      0|                *reinterpret_cast<const std::uint32_t*>(&first_value);
  171|      0|        const std::uint32_t second_value_bits =
  172|      0|                *reinterpret_cast<const std::uint32_t*>(&second_value);
  173|      0|
  174|      0|        std::uint64_t final_value_bits =
  175|      0|                static_cast<std::uint64_t>(second_value_bits) << 32u | first_value_bits;
  176|      0|
  177|      0|        return *reinterpret_cast<double*>(&final_value_bits);
  178|      0|    }
  179|       |
  180|       |    void Processor::FloatRegisterSetFloatValue(FloatRegisterID id, phi::f32 value)
  181|      0|    {
  182|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Float))
  183|      0|        {
  184|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  185|      0|        }
  186|      0|
  187|      0|        FloatRegister& reg = GetFloatRegister(id);
  188|      0|
  189|      0|        reg.SetValue(value);
  190|      0|    }
  191|       |
  192|       |    void Processor::FloatRegisterSetDoubleValue(FloatRegisterID id, phi::f64 value)
  193|      0|    {
  194|      0|        if (!RegisterAccessTypeMatches(m_CurrentInstructionAccessType, RegisterAccessType::Double))
  195|      0|        {
  196|      0|            PHI_LOG_WARN("Mismatch for instruction access type");
  197|      0|        }
  198|      0|
  199|      0|        if (id == FloatRegisterID::F31)
  200|      0|        {
  201|      0|            Raise(Exception::RegisterOutOfBounds);
  202|      0|            return;
  203|      0|        }
  204|      0|
  205|      0|        const constexpr std::uint64_t first_32_bits  = 0b11111111'11111111'11111111'11111111;
  206|      0|        const constexpr std::uint64_t second_32_bits = first_32_bits << 32u;
  207|      0|
  208|      0|        double              value_raw  = value.get();
  209|      0|        const std::uint64_t value_bits = *reinterpret_cast<std::uint64_t*>(&value_raw);
  210|      0|
  211|      0|        const std::uint32_t first_bits  = value_bits & first_32_bits;
  212|      0|        const std::uint32_t second_bits = (value_bits & second_32_bits) >> 32u;
  213|      0|
  214|      0|        const float first_value  = *reinterpret_cast<const float*>(&first_bits);
  215|      0|        const float second_value = *reinterpret_cast<const float*>(&second_bits);
  216|      0|
  217|      0|        FloatRegister& first_reg = GetFloatRegister(id);
  218|      0|        FloatRegister& second_reg =
  219|      0|                GetFloatRegister(static_cast<FloatRegisterID>(static_cast<std::size_t>(id) + 1));
  220|      0|
  221|      0|        first_reg.SetValue(first_value);
  222|      0|        second_reg.SetValue(second_value);
  223|      0|    }
  224|       |
  225|       |    void Processor::ExecuteInstruction(const Instruction& inst)
  226|      0|    {
  227|      0|        m_CurrentInstructionAccessType = inst.GetInfo().GetRegisterAccessType();
  228|      0|
  229|      0|        inst.Execute(*this);
  230|      0|    }
  231|       |
  232|       |    void Processor::LoadProgram(ParsedProgram& programm)
  233|      0|    {
  234|      0|        m_CurrentProgram = &programm;
  235|      0|
  236|      0|        m_ProgramCounter               = 0u;
  237|      0|        m_Halted                       = false;
  238|      0|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  239|      0|    }
  240|       |
  241|       |    phi::ObserverPtr<ParsedProgram> Processor::GetCurrentProgramm() const noexcept
  242|      0|    {
  243|      0|        return m_CurrentProgram;
  244|      0|    }
  245|       |
  246|       |    void Processor::ExecuteCurrentProgram()
  247|      0|    {
  248|      0|        PHI_ASSERT(m_CurrentProgram);
  249|      0|
  250|      0|        // Don't execute a program with parsing errors
  251|      0|        if (!m_CurrentProgram->m_ParseErrors.empty())
  252|      0|        {
  253|      0|            return;
  254|      0|        }
  255|      0|
  256|      0|        m_ProgramCounter      = 0u;
  257|      0|        m_Halted              = false;
  258|      0|        m_LastRaisedException = Exception::None;
  259|      0|
  260|      0|        phi::usize StepCount{0u};
  261|      0|
  262|      0|        while (m_ProgramCounter < m_CurrentProgram->m_Instructions.size() && !m_Halted &&
  263|      0|               (m_MaxNumberOfSteps != 0u && StepCount < m_MaxNumberOfSteps))
  264|      0|        {
  265|      0|            m_NextProgramCounter = m_ProgramCounter + 1u;
  266|      0|
  267|      0|            const auto& current_instruction =
  268|      0|                    m_CurrentProgram->m_Instructions.at(m_ProgramCounter.get());
  269|      0|            ExecuteInstruction(current_instruction);
  270|      0|
  271|      0|            m_ProgramCounter = m_NextProgramCounter;
  272|      0|
  273|      0|            ++StepCount;
  274|      0|        }
  275|      0|    }
  276|       |
  277|       |    void Processor::ClearRegisters()
  278|      0|    {
  279|      0|        for (auto& reg : m_IntRegisters)
  280|      0|        {
  281|      0|            reg.SetSignedValue(0);
  282|      0|        }
  283|      0|
  284|      0|        for (auto& reg : m_FloatRegisters)
  285|      0|        {
  286|      0|            reg.SetValue(0.0f);
  287|      0|        }
  288|      0|    }
  289|       |
  290|       |    void Processor::ClearMemory()
  291|      0|    {
  292|      0|        m_MemoryBlock.Clear();
  293|      0|    }
  294|       |
  295|       |    void Processor::Raise(Exception exception)
  296|      0|    {
  297|      0|        PHI_ASSERT(exception != Exception::None, "Cannot raise None exception");
  298|      0|
  299|      0|        m_LastRaisedException = exception;
  300|      0|
  301|      0|        switch (exception)
  302|      0|        {
  303|      0|            case Exception::None:
  304|      0|                PHI_ASSERT_NOT_REACHED();
  305|      0|                return;
  306|      0|            case Exception::DivideByZero:
  307|      0|                m_Halted = true;
  308|      0|                PHI_LOG_ERROR("Division through zero");
  309|      0|                return;
  310|      0|            case Exception::Overflow:
  311|      0|                PHI_LOG_WARN("Overflow");
  312|      0|                return;
  313|      0|            case Exception::Underflow:
  314|      0|                PHI_LOG_WARN("Underflow");
  315|      0|                return;
  316|      0|            case Exception::Trap:
  317|      0|                m_Halted = true;
  318|      0|                PHI_LOG_ERROR("Trapped");
  319|      0|                return;
  320|      0|            case Exception::Halt:
  321|      0|                m_Halted = true;
  322|      0|                return;
  323|      0|            case Exception::UnknownLabel:
  324|      0|                m_Halted = true;
  325|      0|                PHI_LOG_ERROR("Unknown label");
  326|      0|                return;
  327|      0|            case Exception::BadShift:
  328|      0|                PHI_LOG_ERROR("Bad shift");
  329|      0|                return;
  330|      0|            case Exception::AddressOutOfBounds:
  331|      0|                PHI_LOG_ERROR("Address out of bounds");
  332|      0|                m_Halted = true;
  333|      0|                return;
  334|      0|            case Exception::RegisterOutOfBounds:
  335|      0|                PHI_LOG_ERROR("Register out of bounds");
  336|      0|                m_Halted = true;
  337|      0|                return;
  338|      0|        }
  339|      0|
  340|      0|        PHI_ASSERT_NOT_REACHED();
  341|      0|    }
  342|       |
  343|       |    Exception Processor::GetLastRaisedException() const noexcept
  344|      0|    {
  345|      0|        return m_LastRaisedException;
  346|      0|    }
  347|       |
  348|       |    [[nodiscard]] phi::Boolean Processor::IsHalted() const noexcept
  349|      0|    {
  350|      0|        return m_Halted;
  351|      0|    }
  352|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/RegisterNames.cpp:
    1|       |#include "DLX/RegisterNames.hpp"
    2|       |
    3|       |#include "DLX/Containers/LookUpMap.hpp"
    4|       |#include <algorithm>
    5|       |#include <cctype>
    6|       |
    7|       |namespace dlx
    8|       |{
    9|       |    static constexpr std::array<std::pair<std::string_view, IntRegisterID>, 32> IntRegisterValues{
   10|       |            {{"R0", IntRegisterID::R0},   {"R1", IntRegisterID::R1},   {"R2", IntRegisterID::R2},
   11|       |             {"R3", IntRegisterID::R3},   {"R4", IntRegisterID::R4},   {"R5", IntRegisterID::R5},
   12|       |             {"R6", IntRegisterID::R6},   {"R7", IntRegisterID::R7},   {"R8", IntRegisterID::R8},
   13|       |             {"R9", IntRegisterID::R9},   {"R10", IntRegisterID::R10}, {"R11", IntRegisterID::R11},
   14|       |             {"R12", IntRegisterID::R12}, {"R13", IntRegisterID::R13}, {"R14", IntRegisterID::R14},
   15|       |             {"R15", IntRegisterID::R15}, {"R16", IntRegisterID::R16}, {"R17", IntRegisterID::R17},
   16|       |             {"R18", IntRegisterID::R18}, {"R19", IntRegisterID::R19}, {"R20", IntRegisterID::R20},
   17|       |             {"R21", IntRegisterID::R21}, {"R22", IntRegisterID::R22}, {"R23", IntRegisterID::R23},
   18|       |             {"R24", IntRegisterID::R24}, {"R25", IntRegisterID::R25}, {"R26", IntRegisterID::R26},
   19|       |             {"R27", IntRegisterID::R27}, {"R28", IntRegisterID::R28}, {"R29", IntRegisterID::R29},
   20|       |             {"R30", IntRegisterID::R30}, {"R31", IntRegisterID::R31}}};
   21|       |
   22|       |    static constexpr std::array<std::pair<std::string_view, FloatRegisterID>, 32>
   23|       |            FloatRegisterValues{{{"F0", FloatRegisterID::F0},   {"F1", FloatRegisterID::F1},
   24|       |                                 {"F2", FloatRegisterID::F2},   {"F3", FloatRegisterID::F3},
   25|       |                                 {"F4", FloatRegisterID::F4},   {"F5", FloatRegisterID::F5},
   26|       |                                 {"F6", FloatRegisterID::F6},   {"F7", FloatRegisterID::F7},
   27|       |                                 {"F8", FloatRegisterID::F8},   {"F9", FloatRegisterID::F9},
   28|       |                                 {"F10", FloatRegisterID::F10}, {"F11", FloatRegisterID::F11},
   29|       |                                 {"F12", FloatRegisterID::F12}, {"F13", FloatRegisterID::F13},
   30|       |                                 {"F14", FloatRegisterID::F14}, {"F15", FloatRegisterID::F15},
   31|       |                                 {"F16", FloatRegisterID::F16}, {"F17", FloatRegisterID::F17},
   32|       |                                 {"F18", FloatRegisterID::F18}, {"F19", FloatRegisterID::F19},
   33|       |                                 {"F20", FloatRegisterID::F20}, {"F21", FloatRegisterID::F21},
   34|       |                                 {"F22", FloatRegisterID::F22}, {"F23", FloatRegisterID::F23},
   35|       |                                 {"F24", FloatRegisterID::F24}, {"F25", FloatRegisterID::F25},
   36|       |                                 {"F26", FloatRegisterID::F26}, {"F27", FloatRegisterID::F27},
   37|       |                                 {"F28", FloatRegisterID::F28}, {"F29", FloatRegisterID::F29},
   38|       |                                 {"F30", FloatRegisterID::F30}, {"F31", FloatRegisterID::F31}}};
   39|       |
   40|       |    IntRegisterID StringToIntRegister(std::string token)
   41|  16.8k|    {
   42|  16.8k|        std::transform(token.begin(), token.end(), token.begin(), ::toupper);
   43|  16.8k|
   44|  16.8k|        static constexpr auto map =
   45|  16.8k|                LookUpMap<std::string_view, IntRegisterID, IntRegisterValues.size()>(
   46|  16.8k|                        IntRegisterValues, IntRegisterID::None);
   47|  16.8k|
   48|  16.8k|        return map.at(token.c_str());
   49|  16.8k|    }
   50|       |
   51|       |    FloatRegisterID StringToFloatRegister(std::string token)
   52|    556|    {
   53|    556|        std::transform(token.begin(), token.end(), token.begin(), ::toupper);
   54|    556|
   55|    556|        static constexpr auto map =
   56|    556|                LookUpMap<std::string_view, FloatRegisterID, FloatRegisterValues.size()>(
   57|    556|                        FloatRegisterValues, FloatRegisterID::None);
   58|    556|
   59|    556|        return map.at(token.c_str());
   60|    556|    }
   61|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionLibrary.cpp:
    1|       |#include "DLX/InstructionLibrary.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionImplementation.hpp"
    5|       |#include "DLX/InstructionInfo.hpp"
    6|       |#include <magic_enum.hpp>
    7|       |
    8|       |namespace dlx
    9|       |{
   10|       |    InstructionLibrary::InstructionLibrary()
   11|       |        : m_Instructions()
   12|    690|    {
   13|    690|        PHI_ASSERT(Initialize());
   14|    690|    }
   15|       |
   16|       |    phi::Boolean InstructionLibrary::Initialize()
   17|    690|    {
   18|    690|        /* Arithmetic */
   19|    690|
   20|    690|        // Addition
   21|    690|        InitInstruction(OpCode::ADD, ArgumentType::IntRegister, ArgumentType::IntRegister,
   22|    690|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::ADD);
   23|    690|        InitInstruction(OpCode::ADDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   24|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::ADDI);
   25|    690|        InitInstruction(OpCode::ADDU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   26|    690|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::ADDU);
   27|    690|        InitInstruction(OpCode::ADDUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   28|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::ADDUI);
   29|    690|        InitInstruction(OpCode::ADDF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   30|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::ADDF);
   31|    690|        InitInstruction(OpCode::ADDD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   32|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::ADDD);
   33|    690|
   34|    690|        // Subtraction
   35|    690|        InitInstruction(OpCode::SUB, ArgumentType::IntRegister, ArgumentType::IntRegister,
   36|    690|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::SUB);
   37|    690|        InitInstruction(OpCode::SUBI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   38|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::SUBI);
   39|    690|        InitInstruction(OpCode::SUBU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   40|    690|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::SUBU);
   41|    690|        InitInstruction(OpCode::SUBUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   42|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::SUBUI);
   43|    690|        InitInstruction(OpCode::SUBF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   44|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::SUBF);
   45|    690|        InitInstruction(OpCode::SUBD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   46|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::SUBD);
   47|    690|
   48|    690|        // Multiplikation
   49|    690|        InitInstruction(OpCode::MULT, ArgumentType::IntRegister, ArgumentType::IntRegister,
   50|    690|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::MULT);
   51|    690|        InitInstruction(OpCode::MULTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   52|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::MULTI);
   53|    690|        InitInstruction(OpCode::MULTU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   54|    690|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::MULTU);
   55|    690|        InitInstruction(OpCode::MULTUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   56|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::MULTUI);
   57|    690|        InitInstruction(OpCode::MULTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   58|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::MULTF);
   59|    690|        InitInstruction(OpCode::MULTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   60|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::MULTD);
   61|    690|
   62|    690|        // Division
   63|    690|        InitInstruction(OpCode::DIV, ArgumentType::IntRegister, ArgumentType::IntRegister,
   64|    690|                        ArgumentType::IntRegister, RegisterAccessType::Signed, impl::DIV);
   65|    690|        InitInstruction(OpCode::DIVI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   66|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Signed, impl::DIVI);
   67|    690|        InitInstruction(OpCode::DIVU, ArgumentType::IntRegister, ArgumentType::IntRegister,
   68|    690|                        ArgumentType::IntRegister, RegisterAccessType::Unsigned, impl::DIVU);
   69|    690|        InitInstruction(OpCode::DIVUI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   70|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Unsigned, impl::DIVUI);
   71|    690|        InitInstruction(OpCode::DIVF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   72|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Float, impl::DIVF);
   73|    690|        InitInstruction(OpCode::DIVD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
   74|    690|                        ArgumentType::FloatRegister, RegisterAccessType::Double, impl::DIVD);
   75|    690|
   76|    690|        // Shift left logical
   77|    690|        InitInstruction(OpCode::SLL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   78|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLL);
   79|    690|        InitInstruction(OpCode::SLLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   80|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLLI);
   81|    690|
   82|    690|        // Shift right logical
   83|    690|        InitInstruction(OpCode::SRL, ArgumentType::IntRegister, ArgumentType::IntRegister,
   84|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRL);
   85|    690|        InitInstruction(OpCode::SRLI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   86|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRLI);
   87|    690|
   88|    690|        // Shift left arithmetic
   89|    690|        InitInstruction(OpCode::SLA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   90|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLA);
   91|    690|        InitInstruction(OpCode::SLAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   92|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLAI);
   93|    690|
   94|    690|        // Shift right arithmetic
   95|    690|        InitInstruction(OpCode::SRA, ArgumentType::IntRegister, ArgumentType::IntRegister,
   96|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SRA);
   97|    690|        InitInstruction(OpCode::SRAI, ArgumentType::IntRegister, ArgumentType::IntRegister,
   98|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SRAI);
   99|    690|
  100|    690|        /* Logical */
  101|    690|
  102|    690|        // And
  103|    690|        InitInstruction(OpCode::AND, ArgumentType::IntRegister, ArgumentType::IntRegister,
  104|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::AND);
  105|    690|        InitInstruction(OpCode::ANDI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  106|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ANDI);
  107|    690|
  108|    690|        // Or
  109|    690|        InitInstruction(OpCode::OR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  110|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::OR);
  111|    690|        InitInstruction(OpCode::ORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  112|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::ORI);
  113|    690|
  114|    690|        // Xor
  115|    690|        InitInstruction(OpCode::XOR, ArgumentType::IntRegister, ArgumentType::IntRegister,
  116|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::XOR);
  117|    690|        InitInstruction(OpCode::XORI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  118|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::XORI);
  119|    690|
  120|    690|        /* Conditionals */
  121|    690|
  122|    690|        // Set less than
  123|    690|        InitInstruction(OpCode::SLT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  124|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLT);
  125|    690|        InitInstruction(OpCode::SLTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  126|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLTI);
  127|    690|        InitInstruction(OpCode::LTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  128|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  129|    690|                        impl::LTF);
  130|    690|        InitInstruction(OpCode::LTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  131|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  132|    690|                        impl::LTD);
  133|    690|
  134|    690|        // Set greater than
  135|    690|        InitInstruction(OpCode::SGT, ArgumentType::IntRegister, ArgumentType::IntRegister,
  136|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SGT);
  137|    690|        InitInstruction(OpCode::SGTI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  138|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SGTI);
  139|    690|        InitInstruction(OpCode::GTF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  140|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  141|    690|                        impl::GTF);
  142|    690|        InitInstruction(OpCode::GTD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  143|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  144|    690|                        impl::GTD);
  145|    690|
  146|    690|        // Set less than or equal
  147|    690|        InitInstruction(OpCode::SLE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  148|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SLE);
  149|    690|        InitInstruction(OpCode::SLEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  150|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SLEI);
  151|    690|        InitInstruction(OpCode::LEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  152|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  153|    690|                        impl::LEF);
  154|    690|        InitInstruction(OpCode::LED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  155|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  156|    690|                        impl::LED);
  157|    690|
  158|    690|        // Set greater than or equal
  159|    690|        InitInstruction(OpCode::SGE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  160|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SGE);
  161|    690|        InitInstruction(OpCode::SGEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  162|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SGEI);
  163|    690|        InitInstruction(OpCode::GEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  164|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  165|    690|                        impl::GEF);
  166|    690|        InitInstruction(OpCode::GED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  167|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  168|    690|                        impl::GED);
  169|    690|
  170|    690|        // Set equal
  171|    690|        InitInstruction(OpCode::SEQ, ArgumentType::IntRegister, ArgumentType::IntRegister,
  172|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SEQ);
  173|    690|        InitInstruction(OpCode::SEQI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  174|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SEQI);
  175|    690|        InitInstruction(OpCode::EQF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  176|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  177|    690|                        impl::EQF);
  178|    690|        InitInstruction(OpCode::EQD, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  179|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  180|    690|                        impl::EQD);
  181|    690|
  182|    690|        // Set not equal
  183|    690|        InitInstruction(OpCode::SNE, ArgumentType::IntRegister, ArgumentType::IntRegister,
  184|    690|                        ArgumentType::IntRegister, RegisterAccessType::Ignored, impl::SNE);
  185|    690|        InitInstruction(OpCode::SNEI, ArgumentType::IntRegister, ArgumentType::IntRegister,
  186|    690|                        ArgumentType::ImmediateInteger, RegisterAccessType::Ignored, impl::SNEI);
  187|    690|        InitInstruction(OpCode::NEF, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  188|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  189|    690|                        impl::NEF);
  190|    690|        InitInstruction(OpCode::NED, ArgumentType::FloatRegister, ArgumentType::FloatRegister,
  191|    690|                        ArgumentType::FloatRegister, RegisterAccessType::MixedFloatDouble,
  192|    690|                        impl::NED);
  193|    690|
  194|    690|        /* Conditional branching */
  195|    690|
  196|    690|        // Branch equal zero
  197|    690|        InitInstruction(OpCode::BEQZ, ArgumentType::IntRegister, ArgumentType::Label,
  198|    690|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BEQZ);
  199|    690|
  200|    690|        // Branch not equal zero
  201|    690|        InitInstruction(OpCode::BNEZ, ArgumentType::IntRegister, ArgumentType::Label,
  202|    690|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BNEZ);
  203|    690|
  204|    690|        // Branch floating point true
  205|    690|        InitInstruction(OpCode::BFPT, ArgumentType::FloatRegister, ArgumentType::Label,
  206|    690|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BFPT);
  207|    690|
  208|    690|        // Branch floating point false
  209|    690|        InitInstruction(OpCode::BFPF, ArgumentType::FloatRegister, ArgumentType::Label,
  210|    690|                        ArgumentType::None, RegisterAccessType::Ignored, impl::BFPF);
  211|    690|
  212|    690|        /* Unconditional branching */
  213|    690|
  214|    690|        // Jump
  215|    690|        InitInstruction(OpCode::J, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  216|    690|                        RegisterAccessType::None, impl::J);
  217|    690|
  218|    690|        // Jump to register
  219|    690|        InitInstruction(OpCode::JR, ArgumentType::IntRegister, ArgumentType::None,
  220|    690|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JR);
  221|    690|
  222|    690|        // Jump and link
  223|    690|        InitInstruction(OpCode::JAL, ArgumentType::Label, ArgumentType::None, ArgumentType::None,
  224|    690|                        RegisterAccessType::Unsigned, impl::JAL);
  225|    690|
  226|    690|        // Jump and link to register
  227|    690|        InitInstruction(OpCode::JALR, ArgumentType::IntRegister, ArgumentType::None,
  228|    690|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::JALR);
  229|    690|
  230|    690|        /* Loading data */
  231|    690|
  232|    690|        // Load byte
  233|    690|        InitInstruction(OpCode::LB, ArgumentType::IntRegister,
  234|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  235|    690|                        ArgumentType::None, RegisterAccessType::Signed, impl::LB);
  236|    690|
  237|    690|        // Load byte unsigned
  238|    690|        InitInstruction(OpCode::LBU, ArgumentType::IntRegister,
  239|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  240|    690|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LBU);
  241|    690|
  242|    690|        // Load half word
  243|    690|        InitInstruction(OpCode::LH, ArgumentType::IntRegister,
  244|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  245|    690|                        ArgumentType::None, RegisterAccessType::Signed, impl::LH);
  246|    690|
  247|    690|        // Load half word unsigned
  248|    690|        InitInstruction(OpCode::LHU, ArgumentType::IntRegister,
  249|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  250|    690|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LHU);
  251|    690|
  252|    690|        // Load word
  253|    690|        InitInstruction(OpCode::LW, ArgumentType::IntRegister,
  254|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  255|    690|                        ArgumentType::None, RegisterAccessType::Signed, impl::LW);
  256|    690|
  257|    690|        // Load word unsigned
  258|    690|        InitInstruction(OpCode::LWU, ArgumentType::IntRegister,
  259|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  260|    690|                        ArgumentType::None, RegisterAccessType::Unsigned, impl::LWU);
  261|    690|
  262|    690|        // Load float
  263|    690|        InitInstruction(OpCode::LF, ArgumentType::FloatRegister,
  264|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  265|    690|                        ArgumentType::None, RegisterAccessType::Float, impl::LF);
  266|    690|
  267|    690|        // Load double
  268|    690|        InitInstruction(OpCode::LD, ArgumentType::FloatRegister,
  269|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  270|    690|                        ArgumentType::None, RegisterAccessType::Double, impl::LD);
  271|    690|
  272|    690|        /* Storing data */
  273|    690|
  274|    690|        // Store byte
  275|    690|        InitInstruction(OpCode::SB,
  276|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  277|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  278|    690|                        impl::SB);
  279|    690|
  280|    690|        // Store byte unsigned
  281|    690|        InitInstruction(OpCode::SBU,
  282|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  283|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  284|    690|                        impl::SBU);
  285|    690|
  286|    690|        // Store half word
  287|    690|        InitInstruction(OpCode::SH,
  288|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  289|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  290|    690|                        impl::SH);
  291|    690|
  292|    690|        // Store half word unsigned
  293|    690|        InitInstruction(OpCode::SHU,
  294|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  295|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  296|    690|                        impl::SHU);
  297|    690|
  298|    690|        // Store word
  299|    690|        InitInstruction(OpCode::SW,
  300|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  301|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Signed,
  302|    690|                        impl::SW);
  303|    690|
  304|    690|        // Store word unsigned
  305|    690|        InitInstruction(OpCode::SWU,
  306|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  307|    690|                        ArgumentType::IntRegister, ArgumentType::None, RegisterAccessType::Unsigned,
  308|    690|                        impl::SWU);
  309|    690|
  310|    690|        // Store float
  311|    690|        InitInstruction(OpCode::SF,
  312|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  313|    690|                        ArgumentType::FloatRegister, ArgumentType::None, RegisterAccessType::Float,
  314|    690|                        impl::SF);
  315|    690|
  316|    690|        // Store double
  317|    690|        InitInstruction(OpCode::SD,
  318|    690|                        ArgumentType::ImmediateInteger | ArgumentType::AddressDisplacement,
  319|    690|                        ArgumentType::FloatRegister, ArgumentType::None,
  320|    690|                        RegisterAccessType::Double, impl::SD);
  321|    690|
  322|    690|        /* Special */
  323|    690|
  324|    690|        // Trap
  325|    690|        InitInstruction(OpCode::TRAP, ArgumentType::ImmediateInteger, ArgumentType::None,
  326|    690|                        ArgumentType::None, RegisterAccessType::None, impl::TRAP);
  327|    690|
  328|    690|        // Halt
  329|    690|        InitInstruction(OpCode::HALT, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  330|    690|                        RegisterAccessType::None, impl::HALT);
  331|    690|
  332|    690|        // No operation
  333|    690|        InitInstruction(OpCode::NOP, ArgumentType::None, ArgumentType::None, ArgumentType::None,
  334|    690|                        RegisterAccessType::None, impl::NOP);
  335|    690|
  336|    690|        return true;
  337|    690|    }
  338|       |
  339|       |    const InstructionInfo& InstructionLibrary::LookUp(OpCode instruction) const noexcept
  340|  69.4k|    {
  341|  69.4k|        return m_Instructions.at(static_cast<std::size_t>(instruction));
  342|  69.4k|    }
  343|       |
  344|       |    void InstructionLibrary::InitInstruction(OpCode opcode, ArgumentType arg1, ArgumentType arg2,
  345|       |                                             ArgumentType        arg3,
  346|       |                                             RegisterAccessType  register_access_type,
  347|       |                                             InstructionExecutor executor)
  348|  61.4k|    {
  349|  61.4k|        PHI_ASSERT(LookUp(opcode).GetExecutor() == nullptr, "Already registered instruction {}",
  350|  61.4k|                   magic_enum::enum_name(opcode));
  351|  61.4k|
  352|  61.4k|        m_Instructions.at(static_cast<std::size_t>(opcode)) =
  353|  61.4k|                InstructionInfo(opcode, arg1, arg2, arg3, register_access_type, executor);
  354|  61.4k|    }
  355|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/IntRegister.cpp:
    1|       |#include "DLX/IntRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    IntRegister::IntRegister()
    6|       |        : m_ValueSigned{0}
    7|       |        , m_IsReadOnly{false}
    8|      0|    {}
    9|       |
   10|       |    void IntRegister::SetSignedValue(phi::i32 val)
   11|      0|    {
   12|      0|        m_ValueSigned = val;
   13|      0|    }
   14|       |
   15|       |    void IntRegister::SetUnsignedValue(phi::u32 val)
   16|      0|    {
   17|      0|        m_ValueUnsigned = val;
   18|      0|    }
   19|       |
   20|       |    phi::i32 IntRegister::GetSignedValue() const
   21|      0|    {
   22|      0|        return m_ValueSigned;
   23|      0|    }
   24|       |
   25|       |    phi::u32 IntRegister::GetUnsignedValue() const
   26|      0|    {
   27|      0|        return m_ValueUnsigned;
   28|      0|    }
   29|       |
   30|       |    phi::Boolean IntRegister::IsReadOnly() const
   31|      0|    {
   32|      0|        return m_IsReadOnly;
   33|      0|    }
   34|       |
   35|       |    void IntRegister::SetReadOnly(phi::Boolean read_only)
   36|      0|    {
   37|      0|        m_IsReadOnly = read_only;
   38|      0|    }
   39|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionInfo.cpp:
    1|       |#include "DLX/InstructionInfo.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void InstructionInfo::Execute(Processor& processor, const InstructionArg& arg1,
    6|       |                                  const InstructionArg& arg2,
    7|       |                                  const InstructionArg& arg3) const noexcept
    8|      0|    {
    9|      0|        PHI_ASSERT(m_Executor, "No execution function defined");
   10|      0|
   11|      0|        m_Executor(processor, arg1, arg2, arg3);
   12|      0|    }
   13|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionImplementation.cpp:
    1|       |#include "DLX/InstructionImplementation.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/InstructionInfo.hpp"
    5|       |#include "DLX/Parser.hpp"
    6|       |#include "DLX/Processor.hpp"
    7|       |#include "DLX/RegisterNames.hpp"
    8|       |#include "Phi/Core/Assert.hpp"
    9|       |#include "Phi/Core/Types.hpp"
   10|       |#include <string_view>
   11|       |
   12|       |namespace dlx
   13|       |{
   14|       |    static constexpr float float_true{1.0f};
   15|       |    static constexpr float float_false{0.0f};
   16|       |
   17|       |    static std::int32_t clear_top_n_bits(std::int32_t value, std::int32_t n)
   18|      0|    {
   19|      0|        PHI_ASSERT(n > 0 && n < 32, "Would invoke undefined behaviour");
   20|      0|
   21|      0|        return value & ~(-1 << (32 - n));
   22|      0|    }
   23|       |
   24|       |    static void JumpToLabel(Processor& processor, std::string_view label_name)
   25|      0|    {
   26|      0|        // Lookup the label
   27|      0|        const phi::ObserverPtr<ParsedProgram> program = processor.GetCurrentProgramm();
   28|      0|        PHI_ASSERT(program);
   29|      0|
   30|      0|        std::string label(label_name.data(), label_name.size());
   31|      0|        if (program->m_JumpData.find(label) == program->m_JumpData.end())
   32|      0|        {
   33|      0|            PHI_LOG_ERROR("Unable to find jump label {}", label_name);
   34|      0|            processor.Raise(Exception::UnknownLabel);
   35|      0|            return;
   36|      0|        }
   37|      0|
   38|      0|        // Set program counter
   39|      0|        processor.m_NextProgramCounter = program->m_JumpData.at(label);
   40|      0|    }
   41|       |
   42|       |    static void JumpToRegister(Processor& processor, IntRegisterID reg_id)
   43|      0|    {
   44|      0|        phi::u32 address = processor.IntRegisterGetUnsignedValue(reg_id);
   45|      0|
   46|      0|        phi::u32 max_address =
   47|      0|                static_cast<std::uint32_t>(processor.GetCurrentProgramm()->m_Instructions.size());
   48|      0|        if (address >= max_address)
   49|      0|        {
   50|      0|            processor.Raise(Exception::AddressOutOfBounds);
   51|      0|            return;
   52|      0|        }
   53|      0|
   54|      0|        processor.m_NextProgramCounter = address.get();
   55|      0|    }
   56|       |
   57|       |    static std::optional<phi::i32> CalculateDisplacementAddress(
   58|       |            Processor& processor, const InstructionArg::AddressDisplacement& adr_displacement)
   59|      0|    {
   60|      0|        phi::i32 register_value = processor.IntRegisterGetSignedValue(adr_displacement.register_id);
   61|      0|
   62|      0|        phi::i32 address = adr_displacement.displacement + register_value;
   63|      0|
   64|      0|        if (address < 0)
   65|      0|        {
   66|      0|            processor.Raise(Exception::AddressOutOfBounds);
   67|      0|            return {};
   68|      0|        }
   69|      0|
   70|      0|        return address;
   71|      0|    }
   72|       |
   73|       |    static std::optional<phi::i32> GetLoadStoreAddress(Processor&           processor,
   74|       |                                                       const InstructionArg argument)
   75|      0|    {
   76|      0|        if (argument.GetType() == ArgumentType::ImmediateInteger)
   77|      0|        {
   78|      0|            const auto& imm_value = argument.AsImmediateValue();
   79|      0|
   80|      0|            if (imm_value.signed_value < 0)
   81|      0|            {
   82|      0|                return {};
   83|      0|            }
   84|      0|
   85|      0|            return imm_value.signed_value;
   86|      0|        }
   87|      0|        else if (argument.GetType() == ArgumentType::AddressDisplacement)
   88|      0|        {
   89|      0|            const auto& adr_displacement = argument.AsAddressDisplacement();
   90|      0|            return CalculateDisplacementAddress(processor, adr_displacement);
   91|      0|        }
   92|      0|        else
   93|      0|        {
   94|      0|            PHI_ASSERT_NOT_REACHED();
   95|      0|        }
   96|      0|    }
   97|       |
   98|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::i64 value)
   99|      0|    {
  100|      0|        constexpr phi::i64 min = phi::i32::limits_type::min();
  101|      0|        constexpr phi::i64 max = phi::i32::limits_type::max();
  102|      0|
  103|      0|        // Check for underflow
  104|      0|        if (value < min)
  105|      0|        {
  106|      0|            processor.Raise(Exception::Underflow);
  107|      0|
  108|      0|            value = max + (value % (min - 1));
  109|      0|        }
  110|      0|        // Check for overflow
  111|      0|        else if (value > max)
  112|      0|        {
  113|      0|            processor.Raise(Exception::Overflow);
  114|      0|
  115|      0|            value = min + (value % (max + 1));
  116|      0|        }
  117|      0|
  118|      0|        PHI_ASSERT(value >= min);
  119|      0|        PHI_ASSERT(value <= max);
  120|      0|
  121|      0|        processor.IntRegisterSetSignedValue(dest_reg, static_cast<std::int32_t>(value.get()));
  122|      0|    }
  123|       |
  124|       |    static void SafeWriteInteger(Processor& processor, IntRegisterID dest_reg, phi::u64 value)
  125|      0|    {
  126|      0|        constexpr phi::u64 min = phi::u32::limits_type::min();
  127|      0|        constexpr phi::u64 max = phi::u32::limits_type::max();
  128|      0|
  129|      0|        // Check for overflow
  130|      0|        if (value > max)
  131|      0|        {
  132|      0|            processor.Raise(Exception::Overflow);
  133|      0|
  134|      0|            value %= max + 1u;
  135|      0|        }
  136|      0|
  137|      0|        PHI_ASSERT(value <= max);
  138|      0|
  139|      0|        processor.IntRegisterSetUnsignedValue(dest_reg, static_cast<std::uint32_t>(value.get()));
  140|      0|    }
  141|       |
  142|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  143|      0|    {
  144|      0|        phi::i64 res = phi::i64(lhs) + rhs;
  145|      0|
  146|      0|        SafeWriteInteger(processor, dest_reg, res);
  147|      0|    }
  148|       |
  149|       |    static void Addition(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  150|      0|    {
  151|      0|        phi::u64 res = phi::u64(lhs) + rhs;
  152|      0|
  153|      0|        SafeWriteInteger(processor, dest_reg, res);
  154|      0|    }
  155|       |
  156|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  157|       |                            phi::i32 rhs)
  158|      0|    {
  159|      0|        phi::i64 res = phi::i64(lhs) - rhs;
  160|      0|
  161|      0|        SafeWriteInteger(processor, dest_reg, res);
  162|      0|    }
  163|       |
  164|       |    static void Subtraction(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  165|       |                            phi::u32 rhs)
  166|      0|    {
  167|      0|        constexpr phi::u32 max = phi::u32::limits_type::max();
  168|      0|
  169|      0|        if (lhs < rhs)
  170|      0|        {
  171|      0|            processor.Raise(Exception::Underflow);
  172|      0|
  173|      0|            phi::u64 res = max - rhs + lhs + 1u;
  174|      0|            SafeWriteInteger(processor, dest_reg, res);
  175|      0|            return;
  176|      0|        }
  177|      0|
  178|      0|        phi::u64 res = phi::u64(lhs) - rhs;
  179|      0|
  180|      0|        SafeWriteInteger(processor, dest_reg, res);
  181|      0|    }
  182|       |
  183|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs,
  184|       |                               phi::i32 rhs)
  185|      0|    {
  186|      0|        phi::i64 res = phi::i64(lhs) * rhs;
  187|      0|
  188|      0|        SafeWriteInteger(processor, dest_reg, res);
  189|      0|    }
  190|       |
  191|       |    static void Multiplication(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs,
  192|       |                               phi::u32 rhs)
  193|      0|    {
  194|      0|        phi::u64 res = phi::u64(lhs) * rhs;
  195|      0|
  196|      0|        SafeWriteInteger(processor, dest_reg, res);
  197|      0|    }
  198|       |
  199|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::i32 lhs, phi::i32 rhs)
  200|      0|    {
  201|      0|        if (rhs == 0)
  202|      0|        {
  203|      0|            processor.Raise(Exception::DivideByZero);
  204|      0|            return;
  205|      0|        }
  206|      0|
  207|      0|        phi::i64 res = phi::i64(lhs) / rhs;
  208|      0|
  209|      0|        SafeWriteInteger(processor, dest_reg, res);
  210|      0|    }
  211|       |
  212|       |    static void Division(Processor& processor, IntRegisterID dest_reg, phi::u32 lhs, phi::u32 rhs)
  213|      0|    {
  214|      0|        if (rhs == 0u)
  215|      0|        {
  216|      0|            processor.Raise(Exception::DivideByZero);
  217|      0|            return;
  218|      0|        }
  219|      0|
  220|      0|        phi::u64 res = phi::u64(lhs) / rhs;
  221|      0|
  222|      0|        SafeWriteInteger(processor, dest_reg, res);
  223|      0|    }
  224|       |
  225|       |    static void ShiftRightLogical(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  226|       |                                  phi::i32 shift)
  227|      0|    {
  228|      0|        // Prevent undefined behavior by shifting by more than 31
  229|      0|        if (shift > 31)
  230|      0|        {
  231|      0|            processor.Raise(Exception::BadShift);
  232|      0|
  233|      0|            // Just set register to 0
  234|      0|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  235|      0|            return;
  236|      0|        }
  237|      0|        else if (shift == 0)
  238|      0|        {
  239|      0|            // Do nothing when shifting by zero to prevent undefined behavior
  240|      0|            return;
  241|      0|        }
  242|      0|        else if (shift < 0)
  243|      0|        {
  244|      0|            processor.Raise(Exception::BadShift);
  245|      0|            return;
  246|      0|        }
  247|      0|
  248|      0|        phi::i32 new_value = base.get() >> shift.get();
  249|      0|
  250|      0|        new_value = clear_top_n_bits(new_value.get(), shift.get());
  251|      0|
  252|      0|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  253|      0|    }
  254|       |
  255|       |    static void ShiftRightArithmetic(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  256|       |                                     phi::i32 shift)
  257|      0|    {
  258|      0|        // Prevent undefined behavior by shifting by more than 31
  259|      0|        if (shift > 31)
  260|      0|        {
  261|      0|            processor.Raise(Exception::BadShift);
  262|      0|
  263|      0|            // Is negative ie. sign bit is set
  264|      0|            if (base < 0)
  265|      0|            {
  266|      0|                // Set every byte to 1
  267|      0|                processor.IntRegisterSetSignedValue(dest_reg, ~0);
  268|      0|            }
  269|      0|            else
  270|      0|            {
  271|      0|                // Set every byte to 0
  272|      0|                processor.IntRegisterSetSignedValue(dest_reg, 0);
  273|      0|            }
  274|      0|            return;
  275|      0|        }
  276|      0|        else if (shift < 0)
  277|      0|        {
  278|      0|            processor.Raise(Exception::BadShift);
  279|      0|            return;
  280|      0|        }
  281|      0|
  282|      0|        phi::i32 new_value = base.get() >> shift.get();
  283|      0|
  284|      0|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  285|      0|    }
  286|       |
  287|       |    // Behavior is the same for logical and arithmetic shifts
  288|       |    static void ShiftLeft(Processor& processor, IntRegisterID dest_reg, phi::i32 base,
  289|       |                          phi::i32 shift)
  290|      0|    {
  291|      0|        if (shift > 31)
  292|      0|        {
  293|      0|            processor.Raise(Exception::BadShift);
  294|      0|
  295|      0|            // Just set register to 0
  296|      0|            processor.IntRegisterSetSignedValue(dest_reg, 0);
  297|      0|            return;
  298|      0|        }
  299|      0|        else if (shift < 0)
  300|      0|        {
  301|      0|            processor.Raise(Exception::BadShift);
  302|      0|            return;
  303|      0|        }
  304|      0|
  305|      0|        phi::i32 new_value = base.get() << shift.get();
  306|      0|
  307|      0|        processor.IntRegisterSetSignedValue(dest_reg, new_value);
  308|      0|    }
  309|       |
  310|       |    namespace impl
  311|       |    {
  312|       |        void ADD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  313|       |                 const InstructionArg& arg3)
  314|      0|        {
  315|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  316|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  317|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  318|      0|
  319|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  320|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  321|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  322|      0|
  323|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  324|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  325|      0|
  326|      0|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  327|      0|        }
  328|       |
  329|       |        void ADDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  330|       |                  const InstructionArg& arg3)
  331|      0|        {
  332|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  333|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  334|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  335|      0|
  336|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  337|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  338|      0|            const auto& imm_value = arg3.AsImmediateValue();
  339|      0|
  340|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  341|      0|
  342|      0|            Addition(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  343|      0|        }
  344|       |
  345|       |        void ADDU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  346|       |                  const InstructionArg& arg3)
  347|      0|        {
  348|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  349|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  350|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  351|      0|
  352|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  353|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  354|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  355|      0|
  356|      0|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  357|      0|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  358|      0|
  359|      0|            Addition(processor, dest_reg.register_id, lhs_value, rhs_value);
  360|      0|        }
  361|       |
  362|       |        void ADDUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  363|       |                   const InstructionArg& arg3)
  364|      0|        {
  365|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  366|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  367|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  368|      0|
  369|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  370|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  371|      0|            const auto& imm_value = arg3.AsImmediateValue();
  372|      0|
  373|      0|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  374|      0|
  375|      0|            Addition(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  376|      0|        }
  377|       |
  378|       |        void ADDF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  379|       |                  const InstructionArg& arg3)
  380|      0|        {
  381|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  382|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  383|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  384|      0|
  385|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  386|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  387|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  388|      0|
  389|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  390|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  391|      0|
  392|      0|            const phi::f32 new_value = lhs_value + rhs_value;
  393|      0|
  394|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  395|      0|        }
  396|       |
  397|       |        void ADDD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  398|       |                  const InstructionArg& arg3)
  399|      0|        {
  400|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  401|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  402|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  403|      0|
  404|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  405|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  406|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  407|      0|
  408|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  409|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  410|      0|
  411|      0|            const phi::f64 new_value = lhs_value + rhs_value;
  412|      0|
  413|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  414|      0|        }
  415|       |
  416|       |        void SUB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  417|       |                 const InstructionArg& arg3)
  418|      0|        {
  419|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  420|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  421|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  422|      0|
  423|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  424|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  425|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  426|      0|
  427|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  428|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  429|      0|
  430|      0|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  431|      0|        }
  432|       |
  433|       |        void SUBI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  434|       |                  const InstructionArg& arg3)
  435|      0|        {
  436|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  437|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  438|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  439|      0|
  440|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  441|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  442|      0|            const auto& imm_value = arg3.AsImmediateValue();
  443|      0|
  444|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  445|      0|
  446|      0|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  447|      0|        }
  448|       |
  449|       |        void SUBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  450|       |                  const InstructionArg& arg3)
  451|      0|        {
  452|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  453|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  454|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  455|      0|
  456|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  457|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  458|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  459|      0|
  460|      0|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  461|      0|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  462|      0|
  463|      0|            Subtraction(processor, dest_reg.register_id, lhs_value, rhs_value);
  464|      0|        }
  465|       |
  466|       |        void SUBUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  467|       |                   const InstructionArg& arg3)
  468|      0|        {
  469|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  470|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  471|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  472|      0|
  473|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  474|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  475|      0|            const auto& imm_value = arg3.AsImmediateValue();
  476|      0|
  477|      0|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  478|      0|
  479|      0|            Subtraction(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  480|      0|        }
  481|       |
  482|       |        void SUBF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  483|       |                  const InstructionArg& arg3)
  484|      0|        {
  485|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  486|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  487|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  488|      0|
  489|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  490|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  491|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  492|      0|
  493|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  494|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  495|      0|
  496|      0|            const phi::f32 new_value = lhs_value - rhs_value;
  497|      0|
  498|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  499|      0|        }
  500|       |
  501|       |        void SUBD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  502|       |                  const InstructionArg& arg3)
  503|      0|        {
  504|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  505|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  506|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  507|      0|
  508|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  509|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  510|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  511|      0|
  512|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  513|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  514|      0|
  515|      0|            const phi::f64 new_value = lhs_value - rhs_value;
  516|      0|
  517|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  518|      0|        }
  519|       |
  520|       |        void MULT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  521|       |                  const InstructionArg& arg3)
  522|      0|        {
  523|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  524|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  525|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  526|      0|
  527|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  528|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  529|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  530|      0|
  531|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  532|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  533|      0|
  534|      0|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  535|      0|        }
  536|       |
  537|       |        void MULTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  538|       |                   const InstructionArg& arg3)
  539|      0|        {
  540|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  541|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  542|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  543|      0|
  544|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  545|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  546|      0|            const auto& imm_value = arg3.AsImmediateValue();
  547|      0|
  548|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  549|      0|
  550|      0|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  551|      0|        }
  552|       |
  553|       |        void MULTU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  554|       |                   const InstructionArg& arg3)
  555|      0|        {
  556|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  557|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  558|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  559|      0|
  560|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  561|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  562|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  563|      0|
  564|      0|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  565|      0|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  566|      0|
  567|      0|            Multiplication(processor, dest_reg.register_id, lhs_value, rhs_value);
  568|      0|        }
  569|       |
  570|       |        void MULTUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  571|       |                    const InstructionArg& arg3)
  572|      0|        {
  573|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  574|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  575|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  576|      0|
  577|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  578|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  579|      0|            const auto& imm_value = arg3.AsImmediateValue();
  580|      0|
  581|      0|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  582|      0|
  583|      0|            Multiplication(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  584|      0|        }
  585|       |
  586|       |        void MULTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  587|       |                   const InstructionArg& arg3)
  588|      0|        {
  589|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  590|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  591|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  592|      0|
  593|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  594|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  595|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  596|      0|
  597|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  598|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  599|      0|
  600|      0|            const phi::f32 new_value = lhs_value * rhs_value;
  601|      0|
  602|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  603|      0|        }
  604|       |
  605|       |        void MULTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  606|       |                   const InstructionArg& arg3)
  607|      0|        {
  608|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  609|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  610|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  611|      0|
  612|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  613|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  614|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  615|      0|
  616|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  617|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  618|      0|
  619|      0|            const phi::f64 new_value = lhs_value * rhs_value;
  620|      0|
  621|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  622|      0|        }
  623|       |
  624|       |        void DIV(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  625|       |                 const InstructionArg& arg3)
  626|      0|        {
  627|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  628|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  629|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  630|      0|
  631|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  632|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  633|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  634|      0|
  635|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  636|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  637|      0|
  638|      0|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  639|      0|        }
  640|       |
  641|       |        void DIVI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  642|       |                  const InstructionArg& arg3)
  643|      0|        {
  644|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  645|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  646|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  647|      0|
  648|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  649|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  650|      0|            const auto& imm_value = arg3.AsImmediateValue();
  651|      0|
  652|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  653|      0|
  654|      0|            Division(processor, dest_reg.register_id, src_value, imm_value.signed_value);
  655|      0|        }
  656|       |
  657|       |        void DIVU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  658|       |                  const InstructionArg& arg3)
  659|      0|        {
  660|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  661|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  662|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  663|      0|
  664|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  665|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  666|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  667|      0|
  668|      0|            phi::u32 lhs_value = processor.IntRegisterGetUnsignedValue(lhs_reg.register_id);
  669|      0|            phi::u32 rhs_value = processor.IntRegisterGetUnsignedValue(rhs_reg.register_id);
  670|      0|
  671|      0|            Division(processor, dest_reg.register_id, lhs_value, rhs_value);
  672|      0|        }
  673|       |
  674|       |        void DIVUI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  675|       |                   const InstructionArg& arg3)
  676|      0|        {
  677|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  678|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  679|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  680|      0|
  681|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  682|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  683|      0|            const auto& imm_value = arg3.AsImmediateValue();
  684|      0|
  685|      0|            phi::u32 src_value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
  686|      0|
  687|      0|            Division(processor, dest_reg.register_id, src_value, imm_value.unsigned_value);
  688|      0|        }
  689|       |
  690|       |        void DIVF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  691|       |                  const InstructionArg& arg3)
  692|      0|        {
  693|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  694|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  695|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  696|      0|
  697|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  698|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  699|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  700|      0|
  701|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
  702|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
  703|      0|
  704|      0|            const phi::f32 new_value = lhs_value / rhs_value;
  705|      0|
  706|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
  707|      0|        }
  708|       |
  709|       |        void DIVD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  710|       |                  const InstructionArg& arg3)
  711|      0|        {
  712|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
  713|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
  714|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
  715|      0|
  716|      0|            const auto& dest_reg = arg1.AsRegisterFloat().register_id;
  717|      0|            const auto& lhs_reg  = arg2.AsRegisterFloat().register_id;
  718|      0|            const auto& rhs_reg  = arg3.AsRegisterFloat().register_id;
  719|      0|
  720|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
  721|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
  722|      0|
  723|      0|            const phi::f64 new_value = lhs_value / rhs_value;
  724|      0|
  725|      0|            processor.FloatRegisterSetDoubleValue(dest_reg, new_value);
  726|      0|        }
  727|       |
  728|       |        void SLL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  729|       |                 const InstructionArg& arg3)
  730|      0|        {
  731|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  732|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  733|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  734|      0|
  735|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  736|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  737|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  738|      0|
  739|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  740|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  741|      0|
  742|      0|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  743|      0|        }
  744|       |
  745|       |        void SLLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  746|       |                  const InstructionArg& arg3)
  747|      0|        {
  748|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  749|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  750|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  751|      0|
  752|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  753|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  754|      0|            const auto& imm_value = arg3.AsImmediateValue();
  755|      0|
  756|      0|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  757|      0|            phi::i32 shift_value = imm_value.signed_value;
  758|      0|
  759|      0|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  760|      0|        }
  761|       |
  762|       |        void SRL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  763|       |                 const InstructionArg& arg3)
  764|      0|        {
  765|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  766|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  767|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  768|      0|
  769|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  770|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  771|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  772|      0|
  773|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  774|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  775|      0|
  776|      0|            ShiftRightLogical(processor, dest_reg.register_id, lhs_value, rhs_value);
  777|      0|        }
  778|       |
  779|       |        void SRLI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  780|       |                  const InstructionArg& arg3)
  781|      0|        {
  782|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  783|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  784|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  785|      0|
  786|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  787|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  788|      0|            const auto& imm_value = arg3.AsImmediateValue();
  789|      0|
  790|      0|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  791|      0|            phi::i32 shift_value = imm_value.signed_value;
  792|      0|
  793|      0|            ShiftRightLogical(processor, dest_reg.register_id, src_value, shift_value);
  794|      0|        }
  795|       |
  796|       |        void SLA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  797|       |                 const InstructionArg& arg3)
  798|      0|        {
  799|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  800|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  801|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  802|      0|
  803|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  804|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  805|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  806|      0|
  807|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  808|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  809|      0|
  810|      0|            ShiftLeft(processor, dest_reg.register_id, lhs_value, rhs_value);
  811|      0|        }
  812|       |
  813|       |        void SLAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  814|       |                  const InstructionArg& arg3)
  815|      0|        {
  816|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  817|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  818|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  819|      0|
  820|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  821|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  822|      0|            const auto& imm_value = arg3.AsImmediateValue();
  823|      0|
  824|      0|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  825|      0|            phi::i32 shift_value = imm_value.signed_value;
  826|      0|
  827|      0|            ShiftLeft(processor, dest_reg.register_id, src_value, shift_value);
  828|      0|        }
  829|       |
  830|       |        void SRA(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  831|       |                 const InstructionArg& arg3)
  832|      0|        {
  833|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  834|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  835|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  836|      0|
  837|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  838|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  839|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  840|      0|
  841|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  842|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  843|      0|
  844|      0|            ShiftRightArithmetic(processor, dest_reg.register_id, lhs_value, rhs_value);
  845|      0|        }
  846|       |
  847|       |        void SRAI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  848|       |                  const InstructionArg& arg3)
  849|      0|        {
  850|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  851|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  852|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  853|      0|
  854|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  855|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  856|      0|            const auto& imm_value = arg3.AsImmediateValue();
  857|      0|
  858|      0|            phi::i32 src_value   = processor.IntRegisterGetSignedValue(src_reg.register_id);
  859|      0|            phi::i32 shift_value = imm_value.signed_value;
  860|      0|
  861|      0|            ShiftRightArithmetic(processor, dest_reg.register_id, src_value, shift_value);
  862|      0|        }
  863|       |
  864|       |        void AND(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  865|       |                 const InstructionArg& arg3)
  866|      0|        {
  867|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  868|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  869|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  870|      0|
  871|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  872|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  873|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  874|      0|
  875|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  876|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  877|      0|            phi::i32 new_value = lhs_value.get() & rhs_value.get();
  878|      0|
  879|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  880|      0|        }
  881|       |
  882|       |        void ANDI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  883|       |                  const InstructionArg& arg3)
  884|      0|        {
  885|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  886|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  887|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  888|      0|
  889|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  890|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  891|      0|            const auto& imm_value = arg3.AsImmediateValue();
  892|      0|
  893|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  894|      0|            phi::i32 new_value = src_value.get() & imm_value.signed_value.get();
  895|      0|
  896|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  897|      0|        }
  898|       |
  899|       |        void OR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  900|       |                const InstructionArg& arg3)
  901|      0|        {
  902|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  903|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  904|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  905|      0|
  906|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  907|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  908|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  909|      0|
  910|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  911|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  912|      0|            phi::i32 new_value = lhs_value.get() | rhs_value.get();
  913|      0|
  914|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  915|      0|        }
  916|       |
  917|       |        void ORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  918|       |                 const InstructionArg& arg3)
  919|      0|        {
  920|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  921|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  922|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  923|      0|
  924|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  925|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  926|      0|            const auto& imm_value = arg3.AsImmediateValue();
  927|      0|
  928|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  929|      0|            phi::i32 new_value = src_value.get() | imm_value.signed_value.get();
  930|      0|
  931|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  932|      0|        }
  933|       |
  934|       |        void XOR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  935|       |                 const InstructionArg& arg3)
  936|      0|        {
  937|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  938|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  939|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  940|      0|
  941|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  942|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  943|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  944|      0|
  945|      0|            phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  946|      0|            phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  947|      0|            phi::i32 new_value = lhs_value.get() ^ rhs_value.get();
  948|      0|
  949|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  950|      0|        }
  951|       |
  952|       |        void XORI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  953|       |                  const InstructionArg& arg3)
  954|      0|        {
  955|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  956|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  957|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  958|      0|
  959|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  960|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  961|      0|            const auto& imm_value = arg3.AsImmediateValue();
  962|      0|
  963|      0|            phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
  964|      0|            phi::i32 new_value = src_value.get() ^ imm_value.signed_value.get();
  965|      0|
  966|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  967|      0|        }
  968|       |
  969|       |        void SLT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  970|       |                 const InstructionArg& arg3)
  971|      0|        {
  972|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  973|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  974|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
  975|      0|
  976|      0|            const auto& dest_reg = arg1.AsRegisterInt();
  977|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
  978|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
  979|      0|
  980|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
  981|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
  982|      0|
  983|      0|            const phi::i32 new_value = (lhs_value < rhs_value ? 1 : 0);
  984|      0|
  985|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
  986|      0|        }
  987|       |
  988|       |        void SLTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
  989|       |                  const InstructionArg& arg3)
  990|      0|        {
  991|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
  992|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
  993|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
  994|      0|
  995|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
  996|      0|            const auto& src_reg   = arg2.AsRegisterInt();
  997|      0|            const auto& imm_value = arg3.AsImmediateValue();
  998|      0|
  999|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1000|      0|
 1001|      0|            const phi::i32 new_value = (src_value < imm_value.signed_value ? 1 : 0);
 1002|      0|
 1003|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1004|      0|        }
 1005|       |
 1006|       |        void LTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1007|       |                 const InstructionArg& arg3)
 1008|      0|        {
 1009|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1010|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1011|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1012|      0|
 1013|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1014|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1015|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1016|      0|
 1017|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1018|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1019|      0|
 1020|      0|            const phi::f32 new_value = (lhs_value < rhs_value) ? float_true : float_false;
 1021|      0|
 1022|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1023|      0|        }
 1024|       |
 1025|       |        void LTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1026|       |                 const InstructionArg& arg3)
 1027|      0|        {
 1028|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1029|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1030|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1031|      0|
 1032|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1033|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1034|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1035|      0|
 1036|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1037|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1038|      0|
 1039|      0|            const phi::f32 new_value = (lhs_value < rhs_value) ? float_true : float_false;
 1040|      0|
 1041|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1042|      0|        }
 1043|       |
 1044|       |        void SGT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1045|       |                 const InstructionArg& arg3)
 1046|      0|        {
 1047|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1048|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1049|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1050|      0|
 1051|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1052|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1053|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1054|      0|
 1055|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1056|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1057|      0|
 1058|      0|            const phi::i32 new_value = (lhs_value > rhs_value ? 1 : 0);
 1059|      0|
 1060|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1061|      0|        }
 1062|       |
 1063|       |        void SGTI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1064|       |                  const InstructionArg& arg3)
 1065|      0|        {
 1066|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1067|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1068|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1069|      0|
 1070|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1071|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1072|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1073|      0|
 1074|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1075|      0|
 1076|      0|            const phi::i32 new_value = (src_value > imm_value.signed_value ? 1 : 0);
 1077|      0|
 1078|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1079|      0|        }
 1080|       |
 1081|       |        void GTF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1082|       |                 const InstructionArg& arg3)
 1083|      0|        {
 1084|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1085|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1086|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1087|      0|
 1088|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1089|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1090|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1091|      0|
 1092|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1093|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1094|      0|
 1095|      0|            const phi::f32 new_value = (lhs_value > rhs_value) ? float_true : float_false;
 1096|      0|
 1097|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1098|      0|        }
 1099|       |
 1100|       |        void GTD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1101|       |                 const InstructionArg& arg3)
 1102|      0|        {
 1103|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1104|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1105|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1106|      0|
 1107|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1108|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1109|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1110|      0|
 1111|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1112|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1113|      0|
 1114|      0|            const phi::f32 new_value = (lhs_value > rhs_value) ? float_true : float_false;
 1115|      0|
 1116|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1117|      0|        }
 1118|       |
 1119|       |        void SLE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1120|       |                 const InstructionArg& arg3)
 1121|      0|        {
 1122|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1123|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1124|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1125|      0|
 1126|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1127|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1128|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1129|      0|
 1130|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1131|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1132|      0|
 1133|      0|            const phi::i32 new_value = (lhs_value <= rhs_value ? 1 : 0);
 1134|      0|
 1135|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1136|      0|        }
 1137|       |
 1138|       |        void SLEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1139|       |                  const InstructionArg& arg3)
 1140|      0|        {
 1141|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1142|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1143|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1144|      0|
 1145|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1146|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1147|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1148|      0|
 1149|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1150|      0|
 1151|      0|            const phi::i32 new_value = (src_value <= imm_value.signed_value ? 1 : 0);
 1152|      0|
 1153|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1154|      0|        }
 1155|       |
 1156|       |        void LEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1157|       |                 const InstructionArg& arg3)
 1158|      0|        {
 1159|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1160|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1161|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1162|      0|
 1163|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1164|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1165|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1166|      0|
 1167|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1168|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1169|      0|
 1170|      0|            const phi::f32 new_value = (lhs_value <= rhs_value) ? float_true : float_false;
 1171|      0|
 1172|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1173|      0|        }
 1174|       |
 1175|       |        void LED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1176|       |                 const InstructionArg& arg3)
 1177|      0|        {
 1178|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1179|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1180|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1181|      0|
 1182|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1183|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1184|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1185|      0|
 1186|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1187|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1188|      0|
 1189|      0|            const phi::f32 new_value = (lhs_value <= rhs_value) ? float_true : float_false;
 1190|      0|
 1191|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1192|      0|        }
 1193|       |
 1194|       |        void SGE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1195|       |                 const InstructionArg& arg3)
 1196|      0|        {
 1197|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1198|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1199|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1200|      0|
 1201|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1202|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1203|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1204|      0|
 1205|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1206|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1207|      0|
 1208|      0|            const phi::i32 new_value = (lhs_value >= rhs_value ? 1 : 0);
 1209|      0|
 1210|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1211|      0|        }
 1212|       |
 1213|       |        void SGEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1214|       |                  const InstructionArg& arg3)
 1215|      0|        {
 1216|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1217|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1218|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1219|      0|
 1220|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1221|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1222|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1223|      0|
 1224|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1225|      0|
 1226|      0|            const phi::i32 new_value = (src_value >= imm_value.signed_value ? 1 : 0);
 1227|      0|
 1228|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1229|      0|        }
 1230|       |
 1231|       |        void GEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1232|       |                 const InstructionArg& arg3)
 1233|      0|        {
 1234|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1235|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1236|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1237|      0|
 1238|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1239|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1240|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1241|      0|
 1242|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1243|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1244|      0|
 1245|      0|            const phi::f32 new_value = (lhs_value >= rhs_value) ? float_true : float_false;
 1246|      0|
 1247|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1248|      0|        }
 1249|       |
 1250|       |        void GED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1251|       |                 const InstructionArg& arg3)
 1252|      0|        {
 1253|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1254|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1255|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1256|      0|
 1257|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1258|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1259|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1260|      0|
 1261|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1262|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1263|      0|
 1264|      0|            const phi::f32 new_value = (lhs_value >= rhs_value) ? float_true : float_false;
 1265|      0|
 1266|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1267|      0|        }
 1268|       |
 1269|       |        void SEQ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1270|       |                 const InstructionArg& arg3)
 1271|      0|        {
 1272|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1273|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1274|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1275|      0|
 1276|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1277|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1278|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1279|      0|
 1280|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1281|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1282|      0|
 1283|      0|            const phi::i32 new_value = (lhs_value == rhs_value ? 1 : 0);
 1284|      0|
 1285|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1286|      0|        }
 1287|       |
 1288|       |        void SEQI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1289|       |                  const InstructionArg& arg3)
 1290|      0|        {
 1291|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1292|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1293|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1294|      0|
 1295|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1296|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1297|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1298|      0|
 1299|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1300|      0|
 1301|      0|            const phi::i32 new_value = (src_value == imm_value.signed_value ? 1 : 0);
 1302|      0|
 1303|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1304|      0|        }
 1305|       |
 1306|       |        void EQF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1307|       |                 const InstructionArg& arg3)
 1308|      0|        {
 1309|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1310|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1311|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1312|      0|
 1313|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1314|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1315|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1316|      0|
 1317|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1318|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1319|      0|
 1320|      0|            const phi::f32 new_value =
 1321|      0|                    (lhs_value.get() == rhs_value.get()) ? float_true : float_false;
 1322|      0|
 1323|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1324|      0|        }
 1325|       |
 1326|       |        void EQD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1327|       |                 const InstructionArg& arg3)
 1328|      0|        {
 1329|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1330|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1331|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1332|      0|
 1333|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1334|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1335|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1336|      0|
 1337|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1338|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1339|      0|
 1340|      0|            const phi::f32 new_value =
 1341|      0|                    (lhs_value.get() == rhs_value.get()) ? float_true : float_false;
 1342|      0|
 1343|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1344|      0|        }
 1345|       |
 1346|       |        void SNE(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1347|       |                 const InstructionArg& arg3)
 1348|      0|        {
 1349|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1350|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1351|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::IntRegister);
 1352|      0|
 1353|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1354|      0|            const auto& lhs_reg  = arg2.AsRegisterInt();
 1355|      0|            const auto& rhs_reg  = arg3.AsRegisterInt();
 1356|      0|
 1357|      0|            const phi::i32 lhs_value = processor.IntRegisterGetSignedValue(lhs_reg.register_id);
 1358|      0|            const phi::i32 rhs_value = processor.IntRegisterGetSignedValue(rhs_reg.register_id);
 1359|      0|
 1360|      0|            const phi::i32 new_value = (lhs_value != rhs_value ? 1 : 0);
 1361|      0|
 1362|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1363|      0|        }
 1364|       |
 1365|       |        void SNEI(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1366|       |                  const InstructionArg& arg3)
 1367|      0|        {
 1368|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1369|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1370|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::ImmediateInteger);
 1371|      0|
 1372|      0|            const auto& dest_reg  = arg1.AsRegisterInt();
 1373|      0|            const auto& src_reg   = arg2.AsRegisterInt();
 1374|      0|            const auto& imm_value = arg3.AsImmediateValue();
 1375|      0|
 1376|      0|            const phi::i32 src_value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1377|      0|
 1378|      0|            const phi::i32 new_value = (src_value != imm_value.signed_value ? 1 : 0);
 1379|      0|
 1380|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, new_value);
 1381|      0|        }
 1382|       |
 1383|       |        void NEF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1384|       |                 const InstructionArg& arg3)
 1385|      0|        {
 1386|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1387|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1388|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1389|      0|
 1390|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1391|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1392|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1393|      0|
 1394|      0|            const phi::f32 lhs_value = processor.FloatRegisterGetFloatValue(lhs_reg);
 1395|      0|            const phi::f32 rhs_value = processor.FloatRegisterGetFloatValue(rhs_reg);
 1396|      0|
 1397|      0|            const phi::f32 new_value =
 1398|      0|                    (lhs_value.get() != rhs_value.get()) ? float_true : float_false;
 1399|      0|
 1400|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1401|      0|        }
 1402|       |
 1403|       |        void NED(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1404|       |                 const InstructionArg& arg3)
 1405|      0|        {
 1406|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1407|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 1408|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::FloatRegister);
 1409|      0|
 1410|      0|            const FloatRegisterID dest_reg = arg1.AsRegisterFloat().register_id;
 1411|      0|            const FloatRegisterID lhs_reg  = arg2.AsRegisterFloat().register_id;
 1412|      0|            const FloatRegisterID rhs_reg  = arg3.AsRegisterFloat().register_id;
 1413|      0|
 1414|      0|            const phi::f64 lhs_value = processor.FloatRegisterGetDoubleValue(lhs_reg);
 1415|      0|            const phi::f64 rhs_value = processor.FloatRegisterGetDoubleValue(rhs_reg);
 1416|      0|
 1417|      0|            const phi::f32 new_value =
 1418|      0|                    (lhs_value.get() != rhs_value.get()) ? float_true : float_false;
 1419|      0|
 1420|      0|            processor.FloatRegisterSetFloatValue(dest_reg, new_value);
 1421|      0|        }
 1422|       |
 1423|       |        void BEQZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1424|       |                  const InstructionArg& arg3)
 1425|      0|        {
 1426|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1427|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1428|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1429|      0|
 1430|      0|            const auto& test_reg   = arg1.AsRegisterInt();
 1431|      0|            const auto& jump_label = arg2.AsLabel();
 1432|      0|
 1433|      0|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1434|      0|
 1435|      0|            if (test_value == 0)
 1436|      0|            {
 1437|      0|                JumpToLabel(processor, jump_label.label_name);
 1438|      0|            }
 1439|      0|        }
 1440|       |
 1441|       |        void BNEZ(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1442|       |                  const InstructionArg& arg3)
 1443|      0|        {
 1444|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1445|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1446|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1447|      0|
 1448|      0|            const auto& test_reg   = arg1.AsRegisterInt();
 1449|      0|            const auto& jump_label = arg2.AsLabel();
 1450|      0|
 1451|      0|            phi::i32 test_value = processor.IntRegisterGetSignedValue(test_reg.register_id);
 1452|      0|
 1453|      0|            if (test_value != 0)
 1454|      0|            {
 1455|      0|                JumpToLabel(processor, jump_label.label_name);
 1456|      0|            }
 1457|      0|        }
 1458|       |
 1459|       |        void BFPT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1460|       |                  const InstructionArg& arg3)
 1461|      0|        {
 1462|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1463|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1464|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1465|      0|
 1466|      0|            const auto& test_reg   = arg1.AsRegisterFloat().register_id;
 1467|      0|            const auto& jump_label = arg2.AsLabel();
 1468|      0|
 1469|      0|            phi::f32 test_value = processor.FloatRegisterGetFloatValue(test_reg);
 1470|      0|
 1471|      0|            if (test_value.get() == float_true)
 1472|      0|            {
 1473|      0|                JumpToLabel(processor, jump_label.label_name);
 1474|      0|            }
 1475|      0|        }
 1476|       |
 1477|       |        void BFPF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1478|       |                  const InstructionArg& arg3)
 1479|      0|        {
 1480|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1481|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::Label);
 1482|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1483|      0|
 1484|      0|            const auto& test_reg   = arg1.AsRegisterFloat().register_id;
 1485|      0|            const auto& jump_label = arg2.AsLabel();
 1486|      0|
 1487|      0|            phi::f32 test_value = processor.FloatRegisterGetFloatValue(test_reg);
 1488|      0|
 1489|      0|            if (test_value.get() == float_false)
 1490|      0|            {
 1491|      0|                JumpToLabel(processor, jump_label.label_name);
 1492|      0|            }
 1493|      0|        }
 1494|       |
 1495|       |        void J(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1496|       |               const InstructionArg& arg3)
 1497|      0|        {
 1498|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1499|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1500|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1501|      0|
 1502|      0|            const auto& jump_label = arg1.AsLabel();
 1503|      0|
 1504|      0|            JumpToLabel(processor, jump_label.label_name);
 1505|      0|        }
 1506|       |
 1507|       |        void JR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1508|       |                const InstructionArg& arg3)
 1509|      0|        {
 1510|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1511|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1512|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1513|      0|
 1514|      0|            const auto& jump_register = arg1.AsRegisterInt();
 1515|      0|
 1516|      0|            JumpToRegister(processor, jump_register.register_id);
 1517|      0|        }
 1518|       |
 1519|       |        void JAL(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1520|       |                 const InstructionArg& arg3)
 1521|      0|        {
 1522|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::Label);
 1523|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1524|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1525|      0|
 1526|      0|            const auto& jump_label = arg1.AsLabel();
 1527|      0|
 1528|      0|            processor.IntRegisterSetUnsignedValue(
 1529|      0|                    IntRegisterID::R31,
 1530|      0|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1531|      0|
 1532|      0|            JumpToLabel(processor, jump_label.label_name);
 1533|      0|        }
 1534|       |
 1535|       |        void JALR(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1536|       |                  const InstructionArg& arg3)
 1537|      0|        {
 1538|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1539|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 1540|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1541|      0|
 1542|      0|            const auto& jump_register = arg1.AsRegisterInt();
 1543|      0|
 1544|      0|            processor.IntRegisterSetUnsignedValue(
 1545|      0|                    IntRegisterID::R31,
 1546|      0|                    static_cast<std::uint32_t>(processor.m_NextProgramCounter.get()));
 1547|      0|
 1548|      0|            JumpToRegister(processor, jump_register.register_id);
 1549|      0|        }
 1550|       |
 1551|       |        void LB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1552|       |                const InstructionArg& arg3)
 1553|      0|        {
 1554|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1555|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1556|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1557|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1558|      0|
 1559|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1560|      0|
 1561|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1562|      0|
 1563|      0|            if (!optional_address.has_value())
 1564|      0|            {
 1565|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1566|      0|                return;
 1567|      0|            }
 1568|      0|
 1569|      0|            phi::i32 address = optional_address.value();
 1570|      0|
 1571|      0|            auto optional_value =
 1572|      0|                    processor.m_MemoryBlock.LoadByte(static_cast<std::size_t>(address.get()));
 1573|      0|
 1574|      0|            if (!optional_value.has_value())
 1575|      0|            {
 1576|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1577|      0|                PHI_LOG_ERROR("Failed to load byte at address {}", address.get());
 1578|      0|                return;
 1579|      0|            }
 1580|      0|
 1581|      0|            phi::i32 value = optional_value.value();
 1582|      0|
 1583|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, value);
 1584|      0|        }
 1585|       |
 1586|       |        void LBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1587|       |                 const InstructionArg& arg3)
 1588|      0|        {
 1589|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1590|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1591|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1592|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1593|      0|
 1594|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1595|      0|
 1596|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1597|      0|
 1598|      0|            if (!optional_address.has_value())
 1599|      0|            {
 1600|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1601|      0|                return;
 1602|      0|            }
 1603|      0|
 1604|      0|            phi::i32 address = optional_address.value();
 1605|      0|
 1606|      0|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedByte(
 1607|      0|                    static_cast<std::size_t>(address.get()));
 1608|      0|
 1609|      0|            if (!optional_value.has_value())
 1610|      0|            {
 1611|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1612|      0|                PHI_LOG_ERROR("Failed to load unsigned byte at address {}", address.get());
 1613|      0|                return;
 1614|      0|            }
 1615|      0|
 1616|      0|            phi::i32 value = optional_value.value();
 1617|      0|
 1618|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1619|      0|        }
 1620|       |
 1621|       |        void LH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1622|       |                const InstructionArg& arg3)
 1623|      0|        {
 1624|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1625|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1626|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1627|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1628|      0|
 1629|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1630|      0|
 1631|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1632|      0|
 1633|      0|            if (!optional_address.has_value())
 1634|      0|            {
 1635|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1636|      0|                return;
 1637|      0|            }
 1638|      0|
 1639|      0|            phi::i32 address = optional_address.value();
 1640|      0|
 1641|      0|            auto optional_value =
 1642|      0|                    processor.m_MemoryBlock.LoadHalfWord(static_cast<std::size_t>(address.get()));
 1643|      0|
 1644|      0|            if (!optional_value.has_value())
 1645|      0|            {
 1646|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1647|      0|                PHI_LOG_ERROR("Failed to load half byte at address {}", address.get());
 1648|      0|                return;
 1649|      0|            }
 1650|      0|
 1651|      0|            phi::i32 value = optional_value.value();
 1652|      0|
 1653|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1654|      0|        }
 1655|       |
 1656|       |        void LHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1657|       |                 const InstructionArg& arg3)
 1658|      0|        {
 1659|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1660|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1661|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1662|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1663|      0|
 1664|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1665|      0|
 1666|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1667|      0|
 1668|      0|            if (!optional_address.has_value())
 1669|      0|            {
 1670|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1671|      0|                return;
 1672|      0|            }
 1673|      0|
 1674|      0|            phi::i32 address = optional_address.value();
 1675|      0|
 1676|      0|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedHalfWord(
 1677|      0|                    static_cast<std::size_t>(address.get()));
 1678|      0|
 1679|      0|            if (!optional_value.has_value())
 1680|      0|            {
 1681|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1682|      0|                PHI_LOG_ERROR("Failed to load unsigned half byte at address {}", address.get());
 1683|      0|                return;
 1684|      0|            }
 1685|      0|
 1686|      0|            phi::i32 value = optional_value.value();
 1687|      0|
 1688|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1689|      0|        }
 1690|       |
 1691|       |        void LW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1692|       |                const InstructionArg& arg3)
 1693|      0|        {
 1694|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1695|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1696|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1697|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1698|      0|
 1699|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1700|      0|
 1701|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1702|      0|
 1703|      0|            if (!optional_address.has_value())
 1704|      0|            {
 1705|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1706|      0|                return;
 1707|      0|            }
 1708|      0|
 1709|      0|            phi::i32 address = optional_address.value();
 1710|      0|
 1711|      0|            auto optional_value =
 1712|      0|                    processor.m_MemoryBlock.LoadWord(static_cast<std::size_t>(address.get()));
 1713|      0|
 1714|      0|            if (!optional_value.has_value())
 1715|      0|            {
 1716|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1717|      0|                PHI_LOG_ERROR("Failed to load word at address {}", address.get());
 1718|      0|                return;
 1719|      0|            }
 1720|      0|
 1721|      0|            processor.IntRegisterSetSignedValue(dest_reg.register_id, optional_value.value());
 1722|      0|        }
 1723|       |
 1724|       |        void LWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1725|       |                 const InstructionArg& arg3)
 1726|      0|        {
 1727|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::IntRegister);
 1728|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1729|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1730|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1731|      0|
 1732|      0|            const auto& dest_reg = arg1.AsRegisterInt();
 1733|      0|
 1734|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1735|      0|
 1736|      0|            if (!optional_address.has_value())
 1737|      0|            {
 1738|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1739|      0|                return;
 1740|      0|            }
 1741|      0|
 1742|      0|            phi::i32 address = optional_address.value();
 1743|      0|
 1744|      0|            auto optional_value = processor.m_MemoryBlock.LoadUnsignedWord(
 1745|      0|                    static_cast<std::size_t>(address.get()));
 1746|      0|
 1747|      0|            if (!optional_value.has_value())
 1748|      0|            {
 1749|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1750|      0|                PHI_LOG_ERROR("Failed to load unsigned word at address {}", address.get());
 1751|      0|                return;
 1752|      0|            }
 1753|      0|
 1754|      0|            processor.IntRegisterSetUnsignedValue(dest_reg.register_id, optional_value.value());
 1755|      0|        }
 1756|       |
 1757|       |        void LF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1758|       |                const InstructionArg& arg3)
 1759|      0|        {
 1760|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1761|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1762|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1763|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1764|      0|
 1765|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 1766|      0|
 1767|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1768|      0|
 1769|      0|            if (!optional_address.has_value())
 1770|      0|            {
 1771|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1772|      0|                return;
 1773|      0|            }
 1774|      0|
 1775|      0|            phi::i32 address = optional_address.value();
 1776|      0|
 1777|      0|            auto optional_value =
 1778|      0|                    processor.m_MemoryBlock.LoadFloat(static_cast<std::size_t>(address.get()));
 1779|      0|
 1780|      0|            if (!optional_value.has_value())
 1781|      0|            {
 1782|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1783|      0|                PHI_LOG_ERROR("Failed to load float at address {}", address.get());
 1784|      0|                return;
 1785|      0|            }
 1786|      0|
 1787|      0|            processor.FloatRegisterSetFloatValue(dest_reg.register_id, optional_value.value());
 1788|      0|        }
 1789|       |
 1790|       |        void LD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1791|       |                const InstructionArg& arg3)
 1792|      0|        {
 1793|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::FloatRegister);
 1794|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::AddressDisplacement ||
 1795|      0|                       arg2.GetType() == ArgumentType::ImmediateInteger);
 1796|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1797|      0|
 1798|      0|            const auto& dest_reg = arg1.AsRegisterFloat();
 1799|      0|
 1800|      0|            auto optional_address = GetLoadStoreAddress(processor, arg2);
 1801|      0|
 1802|      0|            if (!optional_address.has_value())
 1803|      0|            {
 1804|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1805|      0|                return;
 1806|      0|            }
 1807|      0|
 1808|      0|            phi::i32 address = optional_address.value();
 1809|      0|
 1810|      0|            auto optional_value =
 1811|      0|                    processor.m_MemoryBlock.LoadDouble(static_cast<std::size_t>(address.get()));
 1812|      0|
 1813|      0|            if (!optional_value.has_value())
 1814|      0|            {
 1815|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1816|      0|                PHI_LOG_ERROR("Failed to load double at address {}", address.get());
 1817|      0|                return;
 1818|      0|            }
 1819|      0|
 1820|      0|            processor.FloatRegisterSetDoubleValue(dest_reg.register_id, optional_value.value());
 1821|      0|        }
 1822|       |
 1823|       |        void SB(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1824|       |                const InstructionArg& arg3)
 1825|      0|        {
 1826|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1827|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1828|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1829|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1830|      0|
 1831|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1832|      0|
 1833|      0|            if (!optional_address.has_value())
 1834|      0|            {
 1835|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1836|      0|                return;
 1837|      0|            }
 1838|      0|
 1839|      0|            phi::i32 address = optional_address.value();
 1840|      0|
 1841|      0|            const auto& src_reg = arg2.AsRegisterInt();
 1842|      0|
 1843|      0|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1844|      0|
 1845|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreByte(
 1846|      0|                    static_cast<std::size_t>(address.get()), static_cast<std::int8_t>(value.get()));
 1847|      0|
 1848|      0|            if (!success)
 1849|      0|            {
 1850|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1851|      0|                PHI_LOG_ERROR("Failed to store byte at address {}", address.get());
 1852|      0|            }
 1853|      0|        }
 1854|       |
 1855|       |        void SBU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1856|       |                 const InstructionArg& arg3)
 1857|      0|        {
 1858|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1859|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1860|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1861|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1862|      0|
 1863|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1864|      0|
 1865|      0|            if (!optional_address.has_value())
 1866|      0|            {
 1867|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1868|      0|                return;
 1869|      0|            }
 1870|      0|
 1871|      0|            phi::i32 address = optional_address.value();
 1872|      0|
 1873|      0|            const auto& src_reg = arg2.AsRegisterInt();
 1874|      0|
 1875|      0|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1876|      0|
 1877|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedByte(
 1878|      0|                    static_cast<std::size_t>(address.get()),
 1879|      0|                    static_cast<std::uint8_t>(value.get()));
 1880|      0|
 1881|      0|            if (!success)
 1882|      0|            {
 1883|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1884|      0|                PHI_LOG_ERROR("Failed to store unsigned byte at address {}", address.get());
 1885|      0|            }
 1886|      0|        }
 1887|       |
 1888|       |        void SH(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1889|       |                const InstructionArg& arg3)
 1890|      0|        {
 1891|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1892|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1893|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1894|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1895|      0|
 1896|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1897|      0|
 1898|      0|            if (!optional_address.has_value())
 1899|      0|            {
 1900|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1901|      0|                return;
 1902|      0|            }
 1903|      0|
 1904|      0|            phi::i32 address = optional_address.value();
 1905|      0|
 1906|      0|            const auto& src_reg = arg2.AsRegisterInt();
 1907|      0|
 1908|      0|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1909|      0|
 1910|      0|            phi::Boolean success =
 1911|      0|                    processor.m_MemoryBlock.StoreHalfWord(static_cast<std::size_t>(address.get()),
 1912|      0|                                                          static_cast<std::int16_t>(value.get()));
 1913|      0|
 1914|      0|            if (!success)
 1915|      0|            {
 1916|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1917|      0|                PHI_LOG_ERROR("Failed to store half word at address {}", address.get());
 1918|      0|            }
 1919|      0|        }
 1920|       |
 1921|       |        void SHU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1922|       |                 const InstructionArg& arg3)
 1923|      0|        {
 1924|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1925|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1926|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1927|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1928|      0|
 1929|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1930|      0|
 1931|      0|            if (!optional_address.has_value())
 1932|      0|            {
 1933|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1934|      0|                return;
 1935|      0|            }
 1936|      0|
 1937|      0|            phi::i32 address = optional_address.value();
 1938|      0|
 1939|      0|            const auto& src_reg = arg2.AsRegisterInt();
 1940|      0|
 1941|      0|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 1942|      0|
 1943|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedHalfWord(
 1944|      0|                    static_cast<std::size_t>(address.get()),
 1945|      0|                    static_cast<std::uint16_t>(value.get()));
 1946|      0|
 1947|      0|            if (!success)
 1948|      0|            {
 1949|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1950|      0|                PHI_LOG_ERROR("Failed to store unsigned half word at address {}", address.get());
 1951|      0|            }
 1952|      0|        }
 1953|       |
 1954|       |        void SW(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1955|       |                const InstructionArg& arg3)
 1956|      0|        {
 1957|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1958|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1959|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1960|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1961|      0|
 1962|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1963|      0|
 1964|      0|            if (!optional_address.has_value())
 1965|      0|            {
 1966|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1967|      0|                return;
 1968|      0|            }
 1969|      0|
 1970|      0|            phi::i32 address = optional_address.value();
 1971|      0|
 1972|      0|            const auto& src_reg = arg2.AsRegisterInt();
 1973|      0|
 1974|      0|            phi::i32 value = processor.IntRegisterGetSignedValue(src_reg.register_id);
 1975|      0|
 1976|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreWord(
 1977|      0|                    static_cast<std::size_t>(address.get()), value);
 1978|      0|
 1979|      0|            if (!success)
 1980|      0|            {
 1981|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1982|      0|                PHI_LOG_ERROR("Failed to store word at address {}", address.get());
 1983|      0|            }
 1984|      0|        }
 1985|       |
 1986|       |        void SWU(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 1987|       |                 const InstructionArg& arg3)
 1988|      0|        {
 1989|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 1990|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 1991|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::IntRegister);
 1992|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 1993|      0|
 1994|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 1995|      0|
 1996|      0|            if (!optional_address.has_value())
 1997|      0|            {
 1998|      0|                processor.Raise(Exception::AddressOutOfBounds);
 1999|      0|                return;
 2000|      0|            }
 2001|      0|
 2002|      0|            phi::i32 address = optional_address.value();
 2003|      0|
 2004|      0|            const auto& src_reg = arg2.AsRegisterInt();
 2005|      0|
 2006|      0|            phi::u32 value = processor.IntRegisterGetUnsignedValue(src_reg.register_id);
 2007|      0|
 2008|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreUnsignedWord(
 2009|      0|                    static_cast<std::size_t>(address.get()), value);
 2010|      0|
 2011|      0|            if (!success)
 2012|      0|            {
 2013|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2014|      0|                PHI_LOG_ERROR("Failed to store unsigned word at address {}", address.get());
 2015|      0|            }
 2016|      0|        }
 2017|       |
 2018|       |        void SF(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2019|       |                const InstructionArg& arg3)
 2020|      0|        {
 2021|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2022|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2023|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2024|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2025|      0|
 2026|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2027|      0|
 2028|      0|            if (!optional_address.has_value())
 2029|      0|            {
 2030|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2031|      0|                return;
 2032|      0|            }
 2033|      0|
 2034|      0|            phi::i32 address = optional_address.value();
 2035|      0|
 2036|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2037|      0|
 2038|      0|            phi::f32 value = processor.FloatRegisterGetFloatValue(src_reg.register_id);
 2039|      0|
 2040|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreFloat(
 2041|      0|                    static_cast<std::size_t>(address.get()), value);
 2042|      0|
 2043|      0|            if (!success)
 2044|      0|            {
 2045|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2046|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2047|      0|            }
 2048|      0|        }
 2049|       |
 2050|       |        void SD(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2051|       |                const InstructionArg& arg3)
 2052|      0|        {
 2053|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::AddressDisplacement ||
 2054|      0|                       arg1.GetType() == ArgumentType::ImmediateInteger);
 2055|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::FloatRegister);
 2056|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2057|      0|
 2058|      0|            auto optional_address = GetLoadStoreAddress(processor, arg1);
 2059|      0|
 2060|      0|            if (!optional_address.has_value())
 2061|      0|            {
 2062|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2063|      0|                return;
 2064|      0|            }
 2065|      0|
 2066|      0|            phi::i32 address = optional_address.value();
 2067|      0|
 2068|      0|            const auto& src_reg = arg2.AsRegisterFloat();
 2069|      0|
 2070|      0|            phi::f64 value = processor.FloatRegisterGetDoubleValue(src_reg.register_id);
 2071|      0|
 2072|      0|            phi::Boolean success = processor.m_MemoryBlock.StoreDouble(
 2073|      0|                    static_cast<std::size_t>(address.get()), value);
 2074|      0|
 2075|      0|            if (!success)
 2076|      0|            {
 2077|      0|                processor.Raise(Exception::AddressOutOfBounds);
 2078|      0|                PHI_LOG_ERROR("Failed to store float at address {}", address.get());
 2079|      0|            }
 2080|      0|        }
 2081|       |
 2082|       |        void TRAP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2083|       |                  const InstructionArg& arg3)
 2084|      0|        {
 2085|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::ImmediateInteger);
 2086|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2087|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2088|      0|
 2089|      0|            processor.Raise(Exception::Trap);
 2090|      0|        }
 2091|       |
 2092|       |        void HALT(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2093|       |                  const InstructionArg& arg3)
 2094|      0|        {
 2095|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2096|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2097|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2098|      0|
 2099|      0|            processor.Raise(Exception::Halt);
 2100|      0|        }
 2101|       |
 2102|       |        void NOP(Processor& processor, const InstructionArg& arg1, const InstructionArg& arg2,
 2103|       |                 const InstructionArg& arg3)
 2104|      0|        {
 2105|      0|            PHI_ASSERT(arg1.GetType() == ArgumentType::None);
 2106|      0|            PHI_ASSERT(arg2.GetType() == ArgumentType::None);
 2107|      0|            PHI_ASSERT(arg3.GetType() == ArgumentType::None);
 2108|      0|
 2109|      0|            /* Do nothing */
 2110|      0|        }
 2111|       |    } // namespace impl
 2112|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/FloatRegister.cpp:
    1|       |#include "DLX/FloatRegister.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    void FloatRegister::SetValue(const phi::f32 val)
    6|      0|    {
    7|      0|        m_Value = val;
    8|      0|    }
    9|       |
   10|       |    phi::f32 FloatRegister::GetValue() const
   11|      0|    {
   12|      0|        return m_Value;
   13|      0|    }
   14|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Token.cpp:
    1|       |#include "DLX/Token.hpp"
    2|       |
    3|       |#include <magic_enum.hpp>
    4|       |#include <string>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    Token::Token(Type type, std::string_view text, phi::u64 line_number, phi::u64 column)
    9|       |        : m_Type{type}
   10|       |        , m_Text{text}
   11|       |        , m_LineNumber{line_number}
   12|       |        , m_Column{column}
   13|   151k|    {}
   14|       |
   15|       |    Token::Type Token::GetType() const noexcept
   16|   192k|    {
   17|   192k|        return m_Type;
   18|   192k|    }
   19|       |
   20|       |    std::string_view Token::GetTypeName() const noexcept
   21|    361|    {
   22|    361|        return magic_enum::enum_name(m_Type);
   23|    361|    }
   24|       |
   25|       |    phi::u64 Token::GetLineNumber() const noexcept
   26|   148k|    {
   27|   148k|        return m_LineNumber;
   28|   148k|    }
   29|       |
   30|       |    phi::u64 Token::GetColumn() const noexcept
   31|   148k|    {
   32|   148k|        return m_Column;
   33|   148k|    }
   34|       |
   35|       |    phi::usize Token::GetLength() const noexcept
   36|      0|    {
   37|      0|        return m_Text.length();
   38|      0|    }
   39|       |
   40|       |    std::string_view Token::GetText() const noexcept
   41|   251k|    {
   42|   251k|        return m_Text;
   43|   251k|    }
   44|       |
   45|       |    std::string Token::GetTextString() const noexcept
   46|   185k|    {
   47|   185k|        return std::string(m_Text.data(), m_Text.length());
   48|   185k|    }
   49|       |
   50|       |    std::string Token::DebugInfo() const noexcept
   51|   148k|    {
   52|   148k|        std::string pos_info = "(" + std::to_string(GetLineNumber().get()) + ":" +
   53|   148k|                               std::to_string(GetColumn().get()) + ")";
   54|   148k|
   55|   148k|        switch (m_Type)
   56|   148k|        {
   57|  4.52k|            case Type::Colon:
   58|  4.52k|                return "Token[Colon]" + pos_info;
   59|  4.22k|            case Type::Comma:
   60|  4.22k|                return "Token[Comma]" + pos_info;
   61|  2.80k|            case Type::Comment:
   62|  2.80k|                return "Token[Comment]" + pos_info + ": '" + GetTextString() + "'";
   63|  96.1k|            case Type::Identifier:
   64|  96.1k|                return "Token[Identifier]" + pos_info + ": '" + GetTextString() + "'";
   65|  23.9k|            case Type::NewLine:
   66|  23.9k|                return "Token[NewLine]" + pos_info;
   67|  5.42k|            case Type::OpenBracket:
   68|  5.42k|                return "Token[OpenBracket]" + pos_info;
   69|  5.27k|            case Type::ClosingBracket:
   70|  5.27k|                return "Token[OpenBracket]" + pos_info;
   71|  1.41k|            case Type::IntegerLiteral:
   72|  1.41k|                return "Token[IntegerLiteral]" + pos_info + ": '" + GetTextString() + "'";
   73|  4.22k|            case Type::ImmediateInteger:
   74|  4.22k|                return "Token[ImmediateInteger]" + pos_info + ": " + GetTextString() + "'";
   75|      0|            case Type::Unknown:
   76|      0|                return "Token[Unknown]" + pos_info;
   77|      0|            default:
   78|      0|                PHI_ASSERT_NOT_REACHED();
   79|      0|                return "Token[NotFound]" + pos_info;
   80|   148k|        }
   81|   148k|    }
   82|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/MemoryBlock.cpp:
    1|       |#include "DLX/MemoryBlock.hpp"
    2|       |#include "Phi/Core/Boolean.hpp"
    3|       |#include "Phi/Core/Log.hpp"
    4|       |#include <cstdint>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    MemoryBlock::MemoryBlock(phi::usize start_address, phi::usize starting_size)
    9|       |        : m_StartingAddress(start_address)
   10|      0|    {
   11|      0|        m_Values.resize(starting_size.get());
   12|      0|    }
   13|       |
   14|       |    std::optional<phi::i8> MemoryBlock::LoadByte(phi::usize address) const
   15|      0|    {
   16|      0|        if (!IsAddressValid(address, 1u))
   17|      0|        {
   18|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   19|      0|            return {};
   20|      0|        }
   21|      0|
   22|      0|        return m_Values.at((address - m_StartingAddress).get()).signed_value;
   23|      0|    }
   24|       |
   25|       |    std::optional<phi::u8> MemoryBlock::LoadUnsignedByte(phi::usize address) const
   26|      0|    {
   27|      0|        if (!IsAddressValid(address, 1u))
   28|      0|        {
   29|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   30|      0|            return {};
   31|      0|        }
   32|      0|
   33|      0|        return m_Values.at((address - m_StartingAddress).get()).unsigned_value;
   34|      0|    }
   35|       |
   36|       |    std::optional<phi::i16> MemoryBlock::LoadHalfWord(phi::usize address) const
   37|      0|    {
   38|      0|        if (!IsAddressValid(address, 2u))
   39|      0|        {
   40|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   41|      0|            return {};
   42|      0|        }
   43|      0|
   44|      0|        phi::usize   start_address = address - m_StartingAddress;
   45|      0|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   46|      0|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   47|      0|        std::int16_t result        = first_byte << 8 | second_byte;
   48|      0|
   49|      0|        return result;
   50|      0|    }
   51|       |
   52|       |    std::optional<phi::u16> MemoryBlock::LoadUnsignedHalfWord(phi::usize address) const
   53|      0|    {
   54|      0|        if (!IsAddressValid(address, 2u))
   55|      0|        {
   56|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   57|      0|            return {};
   58|      0|        }
   59|      0|
   60|      0|        phi::usize    start_address = address - m_StartingAddress;
   61|      0|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   62|      0|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   63|      0|        std::uint16_t result        = first_byte << 8 | second_byte;
   64|      0|
   65|      0|        return result;
   66|      0|    }
   67|       |
   68|       |    std::optional<phi::i32> MemoryBlock::LoadWord(phi::usize address) const
   69|      0|    {
   70|      0|        if (!IsAddressValid(address, 4u))
   71|      0|        {
   72|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   73|      0|            return {};
   74|      0|        }
   75|      0|
   76|      0|        phi::usize   start_address = address - m_StartingAddress;
   77|      0|        std::int8_t  first_byte    = m_Values.at(start_address.get()).signed_value;
   78|      0|        std::int8_t  second_byte   = m_Values.at((start_address + 1u).get()).signed_value;
   79|      0|        std::int8_t  third_byte    = m_Values.at((start_address + 2u).get()).signed_value;
   80|      0|        std::int8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).signed_value;
   81|      0|        std::int32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
   82|      0|
   83|      0|        return result;
   84|      0|    }
   85|       |
   86|       |    std::optional<phi::u32> MemoryBlock::LoadUnsignedWord(phi::usize address) const
   87|      0|    {
   88|      0|        if (!IsAddressValid(address, 4u))
   89|      0|        {
   90|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
   91|      0|            return {};
   92|      0|        }
   93|      0|
   94|      0|        phi::usize    start_address = address - m_StartingAddress;
   95|      0|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
   96|      0|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
   97|      0|        std::uint8_t  third_byte    = m_Values.at((start_address + 2u).get()).unsigned_value;
   98|      0|        std::uint8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).unsigned_value;
   99|      0|        std::uint32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
  100|      0|
  101|      0|        return result;
  102|      0|    }
  103|       |
  104|       |    std::optional<phi::f32> MemoryBlock::LoadFloat(phi::usize address) const
  105|      0|    {
  106|      0|        if (!IsAddressValid(address, 4u))
  107|      0|        {
  108|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  109|      0|            return {};
  110|      0|        }
  111|      0|
  112|      0|        phi::usize    start_address = address - m_StartingAddress;
  113|      0|        std::uint8_t  first_byte    = m_Values.at(start_address.get()).unsigned_value;
  114|      0|        std::uint8_t  second_byte   = m_Values.at((start_address + 1u).get()).unsigned_value;
  115|      0|        std::uint8_t  third_byte    = m_Values.at((start_address + 2u).get()).unsigned_value;
  116|      0|        std::uint8_t  fourth_byte   = m_Values.at((start_address + 3u).get()).unsigned_value;
  117|      0|        std::uint32_t result = first_byte << 24 | second_byte << 16 | third_byte << 8 | fourth_byte;
  118|      0|
  119|      0|        return *reinterpret_cast<float*>(&result);
  120|      0|    }
  121|       |
  122|       |    std::optional<phi::f64> MemoryBlock::LoadDouble(phi::usize address) const
  123|      0|    {
  124|      0|        if (!IsAddressValid(address, 8u))
  125|      0|        {
  126|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  127|      0|            return {};
  128|      0|        }
  129|      0|
  130|      0|        phi::f32 first_value  = LoadFloat(address).value();
  131|      0|        phi::f32 second_value = LoadFloat(address + 4u).value();
  132|      0|
  133|      0|        std::uint32_t first_bits  = *reinterpret_cast<std::uint32_t*>(&first_value);
  134|      0|        std::uint32_t second_bits = *reinterpret_cast<std::uint32_t*>(&second_value);
  135|      0|
  136|      0|        std::uint64_t final_bits = (static_cast<std::uint64_t>(second_bits) << 32u) | first_bits;
  137|      0|
  138|      0|        return *reinterpret_cast<double*>(&final_bits);
  139|      0|    }
  140|       |
  141|       |    phi::Boolean MemoryBlock::StoreByte(phi::usize address, phi::i8 value)
  142|      0|    {
  143|      0|        if (!IsAddressValid(address, 1u))
  144|      0|        {
  145|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  146|      0|            return false;
  147|      0|        }
  148|      0|
  149|      0|        m_Values.at((address - m_StartingAddress).get()).signed_value = value.get();
  150|      0|        return true;
  151|      0|    }
  152|       |
  153|       |    phi::Boolean MemoryBlock::StoreUnsignedByte(phi::usize address, phi::u8 value)
  154|      0|    {
  155|      0|        if (!IsAddressValid(address, 1u))
  156|      0|        {
  157|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  158|      0|            return false;
  159|      0|        }
  160|      0|
  161|      0|        m_Values.at((address - m_StartingAddress).get()).unsigned_value = value.get();
  162|      0|        return true;
  163|      0|    }
  164|       |
  165|       |    phi::Boolean MemoryBlock::StoreHalfWord(phi::usize address, phi::i16 value)
  166|      0|    {
  167|      0|        if (!IsAddressValid(address, 2u))
  168|      0|        {
  169|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  170|      0|            return false;
  171|      0|        }
  172|      0|
  173|      0|        phi::usize  start_address = address - m_StartingAddress;
  174|      0|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  175|      0|        std::int8_t second_byte   = value.get() & 0b00000000'11111111;
  176|      0|
  177|      0|        m_Values.at(start_address.get()).signed_value        = first_byte;
  178|      0|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  179|      0|
  180|      0|        return true;
  181|      0|    }
  182|       |
  183|       |    phi::Boolean MemoryBlock::StoreUnsignedHalfWord(phi::usize address, phi::u16 value)
  184|      0|    {
  185|      0|        if (!IsAddressValid(address, 2u))
  186|      0|        {
  187|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  188|      0|            return false;
  189|      0|        }
  190|      0|
  191|      0|        phi::usize   start_address = address - m_StartingAddress;
  192|      0|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000) >> 8;
  193|      0|        std::uint8_t second_byte   = value.get() & 0b00000000'11111111;
  194|      0|
  195|      0|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  196|      0|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  197|      0|
  198|      0|        return true;
  199|      0|    }
  200|       |
  201|       |    phi::Boolean MemoryBlock::StoreWord(phi::usize address, phi::i32 value)
  202|      0|    {
  203|      0|        if (!IsAddressValid(address, 4u))
  204|      0|        {
  205|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  206|      0|            return false;
  207|      0|        }
  208|      0|
  209|      0|        phi::usize  start_address = address - m_StartingAddress;
  210|      0|        std::int8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  211|      0|        std::int8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  212|      0|        std::int8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  213|      0|        std::int8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  214|      0|
  215|      0|        m_Values.at(start_address.get()).signed_value        = first_byte;
  216|      0|        m_Values.at((start_address + 1u).get()).signed_value = second_byte;
  217|      0|        m_Values.at((start_address + 2u).get()).signed_value = third_byte;
  218|      0|        m_Values.at((start_address + 3u).get()).signed_value = fourth_byte;
  219|      0|
  220|      0|        return true;
  221|      0|    }
  222|       |
  223|       |    phi::Boolean MemoryBlock::StoreUnsignedWord(phi::usize address, phi::u32 value)
  224|      0|    {
  225|      0|        if (!IsAddressValid(address, 4u))
  226|      0|        {
  227|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  228|      0|            return false;
  229|      0|        }
  230|      0|
  231|      0|        phi::usize   start_address = address - m_StartingAddress;
  232|      0|        std::uint8_t first_byte    = (value.get() & 0b11111111'00000000'00000000'00000000) >> 24;
  233|      0|        std::uint8_t second_byte   = (value.get() & 0b00000000'11111111'00000000'00000000) >> 16;
  234|      0|        std::uint8_t third_byte    = (value.get() & 0b00000000'00000000'11111111'00000000) >> 8;
  235|      0|        std::uint8_t fourth_byte   = value.get() & 0b00000000'00000000'00000000'11111111;
  236|      0|
  237|      0|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  238|      0|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  239|      0|        m_Values.at((start_address + 2u).get()).unsigned_value = third_byte;
  240|      0|        m_Values.at((start_address + 3u).get()).unsigned_value = fourth_byte;
  241|      0|
  242|      0|        return true;
  243|      0|    }
  244|       |
  245|       |    phi::Boolean MemoryBlock::StoreFloat(phi::usize address, phi::f32 value)
  246|      0|    {
  247|      0|        if (!IsAddressValid(address, 4u))
  248|      0|        {
  249|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  250|      0|            return false;
  251|      0|        }
  252|      0|
  253|      0|        float         value_raw  = value.get();
  254|      0|        std::uint32_t value_bits = *reinterpret_cast<std::uint32_t*>(&value_raw);
  255|      0|
  256|      0|        phi::usize   start_address = address - m_StartingAddress;
  257|      0|        std::uint8_t first_byte    = (value_bits & 0b11111111'00000000'00000000'00000000) >> 24;
  258|      0|        std::uint8_t second_byte   = (value_bits & 0b00000000'11111111'00000000'00000000) >> 16;
  259|      0|        std::uint8_t third_byte    = (value_bits & 0b00000000'00000000'11111111'00000000) >> 8;
  260|      0|        std::uint8_t fourth_byte   = value_bits & 0b00000000'00000000'00000000'11111111;
  261|      0|
  262|      0|        m_Values.at(start_address.get()).unsigned_value        = first_byte;
  263|      0|        m_Values.at((start_address + 1u).get()).unsigned_value = second_byte;
  264|      0|        m_Values.at((start_address + 2u).get()).unsigned_value = third_byte;
  265|      0|        m_Values.at((start_address + 3u).get()).unsigned_value = fourth_byte;
  266|      0|
  267|      0|        return true;
  268|      0|    }
  269|       |
  270|       |    phi::Boolean MemoryBlock::StoreDouble(phi::usize address, phi::f64 value)
  271|      0|    {
  272|      0|        if (!IsAddressValid(address, 8u))
  273|      0|        {
  274|      0|            PHI_LOG_ERROR("Address {} is out of bounds", address.get());
  275|      0|            return false;
  276|      0|        }
  277|      0|
  278|      0|        double value_raw = value.get();
  279|      0|
  280|      0|        std::uint64_t value_bits = *reinterpret_cast<std::uint64_t*>(&value_raw);
  281|      0|
  282|      0|        std::uint32_t first_bits = value_bits & 0xFFFFFFFF;
  283|      0|        std::uint32_t last_bits  = value_bits >> 32;
  284|      0|
  285|      0|        float first_value = *reinterpret_cast<float*>(&first_bits);
  286|      0|        float last_value  = *reinterpret_cast<float*>(&last_bits);
  287|      0|
  288|      0|        StoreFloat(address, first_value);
  289|      0|        StoreFloat(address + 4u, last_value);
  290|      0|
  291|      0|        return true;
  292|      0|    }
  293|       |
  294|       |    phi::Boolean MemoryBlock::IsAddressValid(phi::usize address, phi::usize size) const
  295|      0|    {
  296|      0|        return address >= m_StartingAddress &&
  297|      0|               (address + size) <= (m_StartingAddress + m_Values.size());
  298|      0|    }
  299|       |
  300|       |    void MemoryBlock::Clear()
  301|      0|    {
  302|      0|        for (auto& val : m_Values)
  303|      0|        {
  304|      0|            val.signed_value = 0;
  305|      0|        }
  306|      0|    }
  307|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Instruction.cpp:
    1|       |#include "DLX/Instruction.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include <Phi/Core/Assert.hpp>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    Instruction::Instruction(const InstructionInfo& info)
    9|       |        : m_Info(info)
   10|  8.07k|    {}
   11|       |
   12|       |    void Instruction::SetArgument(phi::u8 argument_number, InstructionArg argument)
   13|  19.8k|    {
   14|  19.8k|        PHI_ASSERT(argument_number < 3u);
   15|  19.8k|
   16|  19.8k|        switch (argument_number.get())
   17|  19.8k|        {
   18|  7.20k|            case 0u:
   19|  7.20k|                m_Arg1 = argument;
   20|  7.20k|                break;
   21|  7.04k|            case 1u:
   22|  7.04k|                m_Arg2 = argument;
   23|  7.04k|                break;
   24|  5.60k|            case 2u:
   25|  5.60k|                m_Arg3 = argument;
   26|  5.60k|                break;
   27|      0|            default:
   28|      0|                PHI_ASSERT_NOT_REACHED();
   29|  19.8k|        }
   30|  19.8k|    }
   31|       |
   32|       |    std::string Instruction::DebugInfo() const noexcept
   33|  5.82k|    {
   34|  5.82k|        return std::string("Instruction");
   35|  5.82k|    }
   36|       |
   37|       |    void Instruction::Execute(Processor& processor) const noexcept
   38|      0|    {
   39|      0|        m_Info.Execute(processor, m_Arg1, m_Arg2, m_Arg3);
   40|      0|    }
   41|       |
   42|       |    const InstructionInfo& Instruction::GetInfo() const
   43|      0|    {
   44|      0|        return m_Info;
   45|      0|    }
   46|       |
   47|       |    const InstructionArg& Instruction::GetArg1() const
   48|      0|    {
   49|      0|        return m_Arg1;
   50|      0|    }
   51|       |
   52|       |    const InstructionArg& Instruction::GetArg2() const
   53|      0|    {
   54|      0|        return m_Arg2;
   55|      0|    }
   56|       |
   57|       |    const InstructionArg& Instruction::GetArg3() const
   58|      0|    {
   59|      0|        return m_Arg3;
   60|      0|    }
   61|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/Parser.cpp:
    1|       |#include "DLX/Parser.hpp"
    2|       |
    3|       |#include "DLX/InstructionArg.hpp"
    4|       |#include "DLX/RegisterNames.hpp"
    5|       |#include <Phi/Config/FunctionLikeMacro.hpp>
    6|       |#include <Phi/Core/Conversion.hpp>
    7|       |#include <Phi/Core/Log.hpp>
    8|       |#include <magic_enum.hpp>
    9|       |#include <algorithm>
   10|       |#include <optional>
   11|       |
   12|       |using namespace phi::literals;
   13|       |
   14|       |namespace dlx
   15|       |{
   16|       |    phi::Boolean CharIsValidForIdentifer(const char c)
   17|    524|    {
   18|    524|        if (std::isalpha(c) || std::isdigit(c))
   19|    496|        {
   20|    496|            return true;
   21|    496|        }
   22|     28|
   23|     28|        switch (c)
   24|     28|        {
   25|     21|            case '_':
   26|     21|                return true;
   27|      0|
   28|      7|            default:
   29|      7|                return false;
   30|     28|        }
   31|     28|    }
   32|       |
   33|       |    static phi::Boolean is_integer_literal(std::string_view token)
   34|  98.2k|    {
   35|  98.2k|        if (token.length() == 0)
   36|      0|        {
   37|      0|            return false;
   38|      0|        }
   39|  98.2k|
   40|  98.2k|        // First character need to a plus sign a minus sign or a digit but only if theres a digit after that
   41|  98.2k|        if (!std::isdigit(token.at(0)) &&
   42|  98.2k|            !(token.length() > 1 && (token.at(0) == '+' || token.at(0) == '-')))
   43|  78.4k|        {
   44|  78.4k|            return false;
   45|  78.4k|        }
   46|  19.8k|
   47|  19.8k|        // Check that the rest of the token is only made up of numbers
   48|  42.5k|        for (phi::usize i{1u}; i < token.length(); ++i)
   49|  41.0k|        {
   50|  41.0k|            if (!std::isdigit(token.at(i.get())))
   51|  18.4k|            {
   52|  18.4k|                return false;
   53|  18.4k|            }
   54|  41.0k|        }
   55|  19.8k|
   56|  19.8k|        return true;
   57|  19.8k|    }
   58|       |
   59|       |    Token ParseToken(std::string_view token, phi::u64 line_number, phi::u64 column)
   60|   105k|    {
   61|   105k|        if (token.at(0) == '#' && token.size() > 1)
   62|  4.22k|        {
   63|  4.22k|            return Token(Token::Type::ImmediateInteger, token, line_number, column);
   64|  4.22k|        }
   65|   101k|        else if (token.at(0) == '/' || token.at(0) == ';')
   66|  2.80k|        {
   67|  2.80k|            return Token(Token::Type::Comment, token, line_number, column);
   68|  2.80k|        }
   69|  98.2k|        else if (is_integer_literal(token))
   70|  1.41k|        {
   71|  1.41k|            return Token(Token::Type::IntegerLiteral, token, line_number, column);
   72|  1.41k|        }
   73|  96.8k|
   74|  96.8k|        return Token(Token::Type::Identifier, token, line_number, column);
   75|  96.8k|    }
   76|       |
   77|       |    std::vector<Token> Parser::Tokenize(std::string_view str)
   78|    690|    {
   79|    690|        std::vector<Token> tokens{};
   80|    690|        tokens.reserve(5);
   81|    690|
   82|    690|        std::string current_token;
   83|    690|        current_token.reserve(10);
   84|    690|
   85|    690|        phi::u64 current_line_number{1u};
   86|    690|        phi::u64 token_begin{0u};
   87|    690|
   88|    690|        phi::Boolean parsing_comment{false};
   89|    690|
   90|  2.86M|        for (phi::usize i{0u}; i < str.length(); ++i)
   91|  2.85M|        {
   92|  2.85M|            const char c{str.at(i.get())};
   93|  2.85M|
   94|  2.85M|            if (c == '\n')
   95|  24.0k|            {
   96|  24.0k|                if (current_token.empty())
   97|  4.15k|                {
   98|  4.15k|                    tokens.emplace_back(Token::Type::NewLine, str.substr(token_begin.get(), 1),
   99|  4.15k|                                        current_line_number, token_begin);
  100|  4.15k|                    // Skip empty lines
  101|  4.15k|                    continue;
  102|  4.15k|                }
  103|  19.8k|
  104|  19.8k|                // Otherwise a new line separates tokens
  105|  19.8k|                tokens.emplace_back(
  106|  19.8k|                        ParseToken(str.substr(token_begin.get(), current_token.length()),
  107|  19.8k|                                   current_line_number, token_begin));
  108|  19.8k|
  109|  19.8k|                token_begin = i;
  110|  19.8k|
  111|  19.8k|                tokens.emplace_back(Token::Type::NewLine, str.substr(token_begin.get(), 1),
  112|  19.8k|                                    current_line_number, token_begin);
  113|  19.8k|
  114|  19.8k|                current_token.clear();
  115|  19.8k|                parsing_comment = false;
  116|  19.8k|                current_line_number += 1u;
  117|  19.8k|            }
  118|  2.83M|            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  119|  2.83M|            else if (c == '/' || c == ';')
  120|  89.4k|            {
  121|  89.4k|                if (current_token.empty())
  122|  2.80k|                {
  123|  2.80k|                    token_begin = i;
  124|  2.80k|                }
  125|  89.4k|
  126|  89.4k|                parsing_comment = true;
  127|  89.4k|                current_token.push_back(c);
  128|  89.4k|            }
  129|  2.74M|            else if (parsing_comment)
  130|  1.97M|            {
  131|  1.97M|                // simply append the character
  132|  1.97M|                current_token.push_back(c);
  133|  1.97M|            }
  134|   773k|            else
  135|   773k|            {
  136|   773k|                // Not parsing a comment
  137|   773k|
  138|   773k|                switch (c)
  139|   773k|                {
  140|   217k|                    case ' ':
  141|   217k|                    case '\t':
  142|   217k|                    case '\v':
  143|   217k|                        if (current_token.empty())
  144|   165k|                        {
  145|   165k|                            // We haven't found any usable character for the current token so just skip the whitespace.
  146|   165k|                            continue;
  147|   165k|                        }
  148|  51.3k|
  149|  51.3k|                        // Otherwise a whitespace separates tokens
  150|  51.3k|                        tokens.push_back(
  151|  51.3k|                                ParseToken(str.substr(token_begin.get(), current_token.length()),
  152|  51.3k|                                           current_line_number, token_begin));
  153|  51.3k|                        current_token.clear();
  154|  51.3k|                        break;
  155|  51.3k|                    case ':':
  156|  24.2k|                        // Need to parse label names together with their colon
  157|  24.2k|                        if (!current_token.empty())
  158|  19.7k|                        {
  159|  19.7k|                            current_token.push_back(c);
  160|  19.7k|                            tokens.emplace_back(ParseToken(
  161|  19.7k|                                    str.substr(token_begin.get(), current_token.length()),
  162|  19.7k|                                    current_line_number, token_begin));
  163|  19.7k|
  164|  19.7k|                            current_token.clear();
  165|  19.7k|                        }
  166|  4.52k|                        else
  167|  4.52k|                        {
  168|  4.52k|                            // Orphan colon
  169|  4.52k|                            token_begin = i;
  170|  4.52k|
  171|  4.52k|                            tokens.emplace_back(Token::Type::Colon,
  172|  4.52k|                                                str.substr(token_begin.get(), 1),
  173|  4.52k|                                                current_line_number, token_begin);
  174|  4.52k|                            break;
  175|  4.52k|                        }
  176|  19.7k|                        break;
  177|  19.7k|                    case ',':
  178|  17.8k|                    case '(':
  179|  17.8k|                    case ')':
  180|  17.8k|                        if (!current_token.empty())
  181|  13.9k|                        {
  182|  13.9k|                            tokens.emplace_back(ParseToken(
  183|  13.9k|                                    str.substr(token_begin.get(), current_token.length()),
  184|  13.9k|                                    current_line_number, token_begin));
  185|  13.9k|
  186|  13.9k|                            current_token.clear();
  187|  13.9k|                        }
  188|  17.8k|
  189|  17.8k|                        Token::Type type;
  190|  17.8k|                        switch (c)
  191|  17.8k|                        {
  192|  5.84k|                            case ',':
  193|  5.84k|                                type = Token::Type::Comma;
  194|  5.84k|                                break;
  195|  6.08k|                            case '(':
  196|  6.08k|                                type = Token::Type::OpenBracket;
  197|  6.08k|                                break;
  198|  5.93k|                            case ')':
  199|  5.93k|                                type = Token::Type::ClosingBracket;
  200|  5.93k|                                break;
  201|  17.8k|                        }
  202|  17.8k|
  203|  17.8k|                        token_begin = i;
  204|  17.8k|
  205|  17.8k|                        tokens.emplace_back(type, str.substr(token_begin.get(), 1),
  206|  17.8k|                                            current_line_number, token_begin);
  207|  17.8k|                        break;
  208|  17.8k|
  209|   514k|                    default:
  210|   514k|                        if (current_token.empty())
  211|   102k|                        {
  212|   102k|                            token_begin = i;
  213|   102k|                        }
  214|   514k|
  215|   514k|                        // simply append the character
  216|   514k|                        current_token.push_back(c);
  217|   773k|                }
  218|   773k|            }
  219|  2.85M|        }
  220|    690|
  221|    690|        // Checked the entire string. Parse whats left if anything
  222|    690|        if (!current_token.empty())
  223|    423|        {
  224|    423|            tokens.emplace_back(ParseToken(str.substr(token_begin.get(), current_token.length()),
  225|    423|                                           current_line_number, token_begin));
  226|    423|        }
  227|    690|
  228|    690|        return tokens;
  229|    690|    }
  230|       |
  231|       |    static phi::Boolean has_x_more_tokens(const std::vector<Token>& tokens, phi::usize index,
  232|       |                                          phi::u64 x)
  233|  22.9k|    {
  234|  22.9k|        return index + x <= tokens.size();
  235|  22.9k|    }
  236|       |
  237|       |    static phi::Boolean has_one_more_token(const std::vector<Token>& tokens, phi::usize index)
  238|  22.3k|    {
  239|  22.3k|        return has_x_more_tokens(tokens, index, 1u);
  240|  22.3k|    }
  241|       |
  242|       |    static phi::Boolean next_token_is(const std::vector<Token>& tokens, phi::usize index,
  243|       |                                      Token::Type token_type)
  244|      0|    {
  245|      0|        PHI_ASSERT(has_one_more_token(tokens, index));
  246|      0|
  247|      0|        const auto& next_token = tokens.at((index + 1u).get());
  248|      0|
  249|      0|        return next_token.GetType() == token_type;
  250|      0|    }
  251|       |
  252|       |    static phi::Boolean has_one_more_token_of_type(const std::vector<Token>& tokens,
  253|       |                                                   phi::usize index, Token::Type token_type)
  254|      0|    {
  255|      0|        if (!has_one_more_token(tokens, index))
  256|      0|        {
  257|      0|            return false;
  258|      0|        }
  259|      0|
  260|      0|        return (next_token_is(tokens, index, token_type));
  261|      0|    }
  262|       |
  263|       |    static void AddParseError(ParsedProgram& program, const std::string& message)
  264|  74.8k|    {
  265|  74.8k|        ParseError err;
  266|  74.8k|        err.message = message;
  267|  74.8k|
  268|  74.8k|        PHI_LOG_ERROR("Parsing error: {}", message);
  269|  74.8k|
  270|  74.8k|        program.m_ParseErrors.emplace_back(err);
  271|  74.8k|    }
  272|       |
  273|       |    static std::optional<InstructionArg> parse_instruction_argument(
  274|       |            const Token& token, ArgumentType expected_argument_type,
  275|       |            const std::vector<Token>& tokens, phi::usize& index, ParsedProgram& program)
  276|  20.6k|    {
  277|  20.6k|        PHI_LOG_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
  278|  20.6k|                     magic_enum::enum_name(expected_argument_type));
  279|  20.6k|
  280|  20.6k|        switch (token.GetType())
  281|  20.6k|        {
  282|    676|            case Token::Type::IntegerLiteral: {
  283|    676|                if (!ArgumentTypeIncludes(expected_argument_type,
  284|    676|                                          ArgumentType::AddressDisplacement))
  285|     11|                {
  286|     11|                    AddParseError(program,
  287|     11|                                  fmt::format("Expected {} but got address displacement",
  288|     11|                                              magic_enum::enum_name(expected_argument_type)));
  289|     11|                    return {};
  290|     11|                }
  291|    665|
  292|    665|                // Parse address displacement
  293|    665|                std::int32_t displacement_value{0};
  294|    665|                try
  295|    665|                {
  296|    665|                    displacement_value = std::stoi(token.GetTextString());
  297|    665|                }
  298|    665|                catch (std::invalid_argument& /*e*/)
  299|    665|                {
  300|      0|                    AddParseError(program,
  301|      0|                                  "Failed to parse displacement value for Address displacement");
  302|      0|                    return {};
  303|      0|                }
  304|      1|                catch (std::out_of_range& /*e*/)
  305|      1|                {
  306|      1|                    AddParseError(program, "Value is out of range");
  307|      1|                    return {};
  308|      1|                }
  309|    664|
  310|    664|                if (!has_x_more_tokens(tokens, index, 3u))
  311|      2|                {
  312|      2|                    AddParseError(program,
  313|      2|                                  "Not enough arguments left to parse address displacement");
  314|      2|                    return {};
  315|      2|                }
  316|    662|
  317|    662|                const Token& first_token  = tokens.at(index.get());
  318|    662|                const Token& second_token = tokens.at((index + 1u).get());
  319|    662|                const Token& third_token  = tokens.at((index + 2u).get());
  320|    662|
  321|    662|                if (first_token.GetType() != Token::Type::OpenBracket)
  322|      0|                {
  323|      0|                    AddParseError(program, "Expected open bracket");
  324|      0|                    return {};
  325|      0|                }
  326|    662|
  327|    662|                // Second token is the address
  328|    662|                IntRegisterID reg_id = StringToIntRegister(
  329|    662|                        {second_token.GetText().data(), second_token.GetText().size()});
  330|    662|
  331|    662|                if (reg_id == IntRegisterID::None)
  332|      0|                {
  333|      0|                    AddParseError(program, "Expected IntRegister");
  334|      0|                    return {};
  335|      0|                }
  336|    662|
  337|    662|                if (third_token.GetType() != Token::Type::ClosingBracket)
  338|      1|                {
  339|      1|                    AddParseError(program, "Expected closing bracket");
  340|      1|                    return {};
  341|      1|                }
  342|    661|
  343|    661|                index += 3u;
  344|    661|
  345|    661|                PHI_LOG_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
  346|    661|                             displacement_value, magic_enum::enum_name(reg_id));
  347|    661|
  348|    661|                return ConstructInstructionArgAddressDisplacement(reg_id, displacement_value);
  349|    661|            }
  350|  16.1k|            case Token::Type::Identifier: {
  351|  16.1k|                IntRegisterID reg_id = StringToIntRegister(token.GetTextString());
  352|  16.1k|
  353|  16.1k|                if (reg_id != IntRegisterID::None)
  354|  15.6k|                {
  355|  15.6k|                    if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  356|     18|                    {
  357|     18|                        AddParseError(program,
  358|     18|                                      fmt::format("Got IntRegister but expected '{}'",
  359|     18|                                                  magic_enum::enum_name(expected_argument_type)));
  360|     18|                        return {};
  361|     18|                    }
  362|  15.5k|
  363|  15.5k|                    PHI_LOG_INFO("Parsed identifier as int register {}",
  364|  15.5k|                                 magic_enum::enum_name(reg_id));
  365|  15.5k|
  366|  15.5k|                    return ConstructInstructionArgRegisterInt(reg_id);
  367|  15.5k|                }
  368|    556|
  369|    556|                // Try parsing as FloatRegister
  370|    556|                FloatRegisterID float_reg_id = StringToFloatRegister(token.GetTextString());
  371|    556|
  372|    556|                if (float_reg_id != FloatRegisterID::None)
  373|      0|                {
  374|      0|                    if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  375|      0|                    {
  376|      0|                        AddParseError(program,
  377|      0|                                      fmt::format("Got FloatRegister but expected '{}'",
  378|      0|                                                  magic_enum::enum_name(expected_argument_type)));
  379|      0|                        return {};
  380|      0|                    }
  381|      0|
  382|      0|                    PHI_LOG_INFO("Parsed identifier as float register {}",
  383|      0|                                 magic_enum::enum_name(float_reg_id));
  384|      0|
  385|      0|                    return ConstructInstructionArgRegisterFloat(float_reg_id);
  386|      0|                }
  387|    556|
  388|    556|                // Parse as Label
  389|    556|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  390|    388|                {
  391|    388|                    AddParseError(program,
  392|    388|                                  fmt::format("Got Label but expected '{}'",
  393|    388|                                              magic_enum::enum_name(expected_argument_type)));
  394|    388|                    return {};
  395|    388|                }
  396|    168|
  397|    168|                if (!std::all_of(token.GetText().begin(), token.GetText().end(),
  398|    168|                                 CharIsValidForIdentifer))
  399|      7|                {
  400|      7|                    AddParseError(program, fmt::format("Invalid label identifier found {}",
  401|      7|                                                       token.GetText()));
  402|      7|                    return {};
  403|      7|                }
  404|    161|
  405|    161|                PHI_LOG_INFO("Parsed Label identifier as '{}'", token.GetText());
  406|    161|
  407|    161|                return ConstructInstructionArgLabel(token.GetText());
  408|    161|            }
  409|  3.44k|            case Token::Type::ImmediateInteger: {
  410|  3.44k|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  411|      9|                {
  412|      9|                    AddParseError(program,
  413|      9|                                  fmt::format("Got ImmediateInteger but expected '{}'",
  414|      9|                                              magic_enum::enum_name(expected_argument_type)));
  415|      9|                    return {};
  416|      9|                }
  417|  3.43k|
  418|  3.43k|                std::int32_t value{0};
  419|  3.43k|                try
  420|  3.43k|                {
  421|  3.43k|                    value = std::stoi(token.GetTextString().substr(1));
  422|  3.43k|                }
  423|  3.43k|                catch (std::invalid_argument& /*e*/)
  424|  3.43k|                {
  425|      0|                    AddParseError(program, "Failed to parse immediate Integer value");
  426|      0|                    return {};
  427|      0|                }
  428|      0|                catch (std::out_of_range& /*e*/)
  429|      0|                {
  430|      0|                    AddParseError(program, "Value is out of range");
  431|      0|                    return {};
  432|      0|                }
  433|  3.43k|
  434|  3.43k|                PHI_LOG_INFO("Parsed Immediate Integer with value {}", value);
  435|  3.43k|
  436|  3.43k|                return ConstructInstructionArgImmediateValue(value);
  437|  3.43k|            }
  438|  3.43k|            default:
  439|    361|                AddParseError(program,
  440|    361|                              fmt::format("Unexpected token of type '{}'", token.GetTypeName()));
  441|    361|                return {};
  442|  20.6k|        }
  443|  20.6k|    }
  444|       |
  445|       |    static void consume_x_tokens(phi::usize& index, phi::usize x)
  446|   149k|    {
  447|   149k|        index += x;
  448|   149k|    }
  449|       |
  450|       |    static void consume_current_token(phi::usize& index)
  451|   149k|    {
  452|   149k|        consume_x_tokens(index, 1u);
  453|   149k|    }
  454|       |
  455|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::vector<Token>& tokens)
  456|    690|    {
  457|    690|        ParsedProgram program;
  458|    690|
  459|    690|        phi::Boolean line_has_instruction{false};
  460|    690|
  461|   128k|        for (phi::usize index{0u}; index < tokens.size();)
  462|   127k|        {
  463|   127k|            Token& current_token = tokens.at(index.get());
  464|   127k|
  465|   127k|            consume_current_token(index);
  466|   127k|
  467|   127k|            PHI_LOG_INFO("Parsing '{}'", current_token.DebugInfo());
  468|   127k|
  469|   127k|            switch (current_token.GetType())
  470|   127k|            {
  471|      0|                // Ignore comments
  472|  2.79k|                case Token::Type::Comment:
  473|  2.79k|                    PHI_LOG_DEBUG("Ignoring comment");
  474|  2.79k|                    break;
  475|  23.9k|                case Token::Type::NewLine:
  476|  23.9k|                    PHI_LOG_DEBUG("Ignoring newline");
  477|  23.9k|                    line_has_instruction = false;
  478|  23.9k|                    break;
  479|  80.0k|                case Token::Type::Identifier: {
  480|  80.0k|                    if (line_has_instruction)
  481|    618|                    {
  482|    618|                        AddParseError(program, "Expected new line but got identifer");
  483|    618|                        break;
  484|    618|                    }
  485|  79.4k|
  486|  79.4k|                    // Handle jump labels
  487|  79.4k|                    // Check if the last character of the identifier is a colon
  488|  79.4k|                    if (current_token.GetText().at(current_token.GetText().size() - 1) == ':')
  489|  19.3k|                    {
  490|  19.3k|                        std::string_view label_name = current_token.GetText().substr(
  491|  19.3k|                                0, current_token.GetText().size() - 1);
  492|  19.3k|
  493|  19.3k|                        program.m_JumpData[label_name] =
  494|  19.3k|                                static_cast<std::uint32_t>(program.m_Instructions.size());
  495|  19.3k|
  496|  19.3k|                        PHI_LOG_INFO("Added jump label {} -> {}", label_name,
  497|  19.3k|                                     program.m_Instructions.size());
  498|  19.3k|                        break;
  499|  19.3k|                    }
  500|  60.0k|
  501|  60.0k|                    // Handle normal instructions
  502|  60.0k|                    // First we need to parse the instruction itself so we know how many arguments it expects
  503|  60.0k|                    OpCode opcode = StringToOpCode(current_token.GetTextString());
  504|  60.0k|
  505|  60.0k|                    if (opcode == OpCode::NONE)
  506|  51.9k|                    {
  507|  51.9k|                        AddParseError(program,
  508|  51.9k|                                      fmt::format("Failed to parse instruction '{}' not found.",
  509|  51.9k|                                                  current_token.GetText()));
  510|  51.9k|                        break;
  511|  51.9k|                    }
  512|  8.07k|
  513|  8.07k|                    PHI_LOG_INFO("Instruction opcode: {}", magic_enum::enum_name(opcode));
  514|  8.07k|
  515|  8.07k|                    const InstructionInfo& info = lib.LookUp(opcode);
  516|  8.07k|
  517|  8.07k|                    // Make sure we got no problems here
  518|  8.07k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  519|  8.07k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  520|  8.07k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  521|  8.07k|                    PHI_ASSERT(info.GetExecutor());
  522|  8.07k|
  523|  8.07k|                    phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  524|  8.07k|                    PHI_LOG_INFO("Instruction requires {} arguments",
  525|  8.07k|                                 number_of_argument_required.get());
  526|  8.07k|
  527|  8.07k|                    // Create instruction
  528|  8.07k|                    Instruction instruction(info);
  529|  8.07k|
  530|  8.07k|                    // Parse arguments
  531|  29.5k|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  532|  22.3k|                    {
  533|  22.3k|                        // Get next token
  534|  22.3k|                        if (!has_one_more_token(tokens, index))
  535|     29|                        {
  536|     29|                            AddParseError(
  537|     29|                                    program,
  538|     29|                                    fmt::format("Missing {} arguments for instruction {}",
  539|     29|                                                (number_of_argument_required - argument_num).get(),
  540|     29|                                                magic_enum::enum_name(opcode)));
  541|     29|                            break;
  542|     29|                        }
  543|  22.3k|
  544|  22.3k|                        current_token = tokens.at(index.get());
  545|  22.3k|                        consume_current_token(index);
  546|  22.3k|
  547|  22.3k|                        // Skip commas
  548|  22.3k|                        if (current_token.GetType() == Token::Type::Comma)
  549|  1.61k|                        {
  550|  1.61k|                            PHI_LOG_DEBUG("Skipping comma");
  551|  1.61k|                            continue;
  552|  1.61k|                        }
  553|  20.6k|
  554|  20.6k|                        if (current_token.GetType() == Token::Type::NewLine)
  555|     40|                        {
  556|     40|                            AddParseError(program, "Unexpected end of line");
  557|     40|                            break;
  558|     40|                        }
  559|  20.6k|
  560|  20.6k|                        std::optional<InstructionArg> optional_parsed_argument =
  561|  20.6k|                                parse_instruction_argument(current_token,
  562|  20.6k|                                                           info.GetArgumentType(argument_num),
  563|  20.6k|                                                           tokens, index, program);
  564|  20.6k|                        if (!optional_parsed_argument.has_value())
  565|    798|                        {
  566|    798|                            AddParseError(program, fmt::format("Failed to parse argument number {}",
  567|    798|                                                               argument_num.get()));
  568|    798|                            break;
  569|    798|                        }
  570|  19.8k|
  571|  19.8k|                        // Successfully parsed one argument
  572|  19.8k|                        InstructionArg parsed_argument = optional_parsed_argument.value();
  573|  19.8k|
  574|  19.8k|                        instruction.SetArgument(argument_num, parsed_argument);
  575|  19.8k|                        argument_num++;
  576|  19.8k|
  577|  19.8k|                        PHI_LOG_INFO("Successfully parsed argument {}", argument_num.get());
  578|  19.8k|                    }
  579|  8.07k|
  580|  8.07k|                    // Only add the instruction if we got no parsing errors
  581|  8.07k|                    if (program.m_ParseErrors.empty())
  582|  5.82k|                    {
  583|  5.82k|                        PHI_LOG_INFO("Successfully parsed instruction '{}'",
  584|  5.82k|                                     instruction.DebugInfo());
  585|  5.82k|                        program.m_Instructions.emplace_back(std::move(instruction));
  586|  5.82k|                        line_has_instruction = true;
  587|  5.82k|                    }
  588|  8.07k|                    break;
  589|  8.07k|                }
  590|  8.07k|
  591|  20.6k|                default:
  592|  20.6k|                    AddParseError(program, "Unexpected token");
  593|  20.6k|                    break;
  594|   127k|            }
  595|   127k|        }
  596|    690|
  597|    690|        return program;
  598|    690|    }
  599|       |
  600|       |    ParsedProgram Parser::Parse(const InstructionLibrary& lib, std::string_view source)
  601|    690|    {
  602|    690|        std::vector<Token> tokens = Tokenize(source);
  603|    690|        return Parse(lib, tokens);
  604|    690|    }
  605|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/OpCode.cpp:
    1|       |#include "DLX/OpCode.hpp"
    2|       |
    3|       |#include <magic_enum.hpp>
    4|       |#include <algorithm>
    5|       |
    6|       |namespace dlx
    7|       |{
    8|       |    OpCode StringToOpCode(std::string token)
    9|  60.0k|    {
   10|  60.0k|        std::transform(token.begin(), token.end(), token.begin(), ::toupper);
   11|  60.0k|        std::optional<OpCode> opcode_casted = magic_enum::enum_cast<OpCode>(token);
   12|  60.0k|        if (opcode_casted.has_value())
   13|  8.25k|        {
   14|  8.25k|            // TODO: Bit of a hacky way around magic_enum begin able to cast every member...
   15|  8.25k|            if (opcode_casted.value() == OpCode::NUMBER_OF_ELEMENTS)
   16|      2|            {
   17|      2|                return OpCode::NONE;
   18|      2|            }
   19|  8.24k|            return opcode_casted.value();
   20|  8.24k|        }
   21|  51.8k|
   22|  51.8k|        // None found
   23|  51.8k|        return OpCode::NONE;
   24|  51.8k|    }
   25|       |} // namespace dlx

/home/runner/work/DLXEmu/DLXEmu/DLXEmu-App/DLXLib/src/InstructionArg.cpp:
    1|       |#include "DLX/InstructionArg.hpp"
    2|       |
    3|       |namespace dlx
    4|       |{
    5|       |    InstructionArg::InstructionArg()
    6|       |        : m_Type(ArgumentType::None)
    7|       |        , address_displacement()
    8|  44.0k|    {}
    9|       |
   10|       |    ArgumentType InstructionArg::GetType() const
   11|      0|    {
   12|      0|        return m_Type;
   13|      0|    }
   14|       |
   15|       |    std::string InstructionArg::DebugInfo() const
   16|      0|    {
   17|      0|        return "InstructionArgument";
   18|      0|    }
   19|       |
   20|       |    const InstructionArg::RegisterInt& InstructionArg::AsRegisterInt() const
   21|      0|    {
   22|      0|        PHI_ASSERT(m_Type == ArgumentType::IntRegister);
   23|      0|
   24|      0|        return register_int;
   25|      0|    }
   26|       |
   27|       |    const InstructionArg::RegisterFloat& InstructionArg::AsRegisterFloat() const
   28|      0|    {
   29|      0|        PHI_ASSERT(m_Type == ArgumentType::FloatRegister);
   30|      0|
   31|      0|        return register_float;
   32|      0|    }
   33|       |
   34|       |    const InstructionArg::ImmediateValue& InstructionArg::AsImmediateValue() const
   35|      0|    {
   36|      0|        PHI_ASSERT(m_Type == ArgumentType::ImmediateInteger);
   37|      0|
   38|      0|        return immediate_value;
   39|      0|    }
   40|       |
   41|       |    const InstructionArg::AddressDisplacement& InstructionArg::AsAddressDisplacement() const
   42|      0|    {
   43|      0|        PHI_ASSERT(m_Type == ArgumentType::AddressDisplacement);
   44|      0|
   45|      0|        return address_displacement;
   46|      0|    }
   47|       |
   48|       |    const InstructionArg::Label& InstructionArg::AsLabel() const
   49|      0|    {
   50|      0|        PHI_ASSERT(m_Type == ArgumentType::Label);
   51|      0|
   52|      0|        return label;
   53|      0|    }
   54|       |
   55|       |    phi::Boolean operator==(const InstructionArg& lhs, const InstructionArg& rhs)
   56|      0|    {
   57|      0|        if (lhs.GetType() != rhs.GetType())
   58|      0|        {
   59|      0|            return false;
   60|      0|        }
   61|      0|
   62|      0|        switch (lhs.GetType())
   63|      0|        {
   64|      0|            case ArgumentType::AddressDisplacement:
   65|      0|                return (lhs.AsAddressDisplacement().displacement ==
   66|      0|                        rhs.AsAddressDisplacement().displacement) &&
   67|      0|                       (lhs.AsAddressDisplacement().register_id ==
   68|      0|                        rhs.AsAddressDisplacement().register_id);
   69|      0|            case ArgumentType::ImmediateInteger:
   70|      0|                return lhs.AsImmediateValue().signed_value == rhs.AsImmediateValue().signed_value;
   71|      0|            case ArgumentType::IntRegister:
   72|      0|                return lhs.AsRegisterInt().register_id == rhs.AsRegisterInt().register_id;
   73|      0|            case ArgumentType::FloatRegister:
   74|      0|                return lhs.AsRegisterFloat().register_id == rhs.AsRegisterFloat().register_id;
   75|      0|            case ArgumentType::Label:
   76|      0|                return lhs.AsLabel().label_name == rhs.AsLabel().label_name;
   77|      0|            case ArgumentType::None:
   78|      0|                return true;
   79|      0|            default:
   80|      0|                PHI_ASSERT_NOT_REACHED();
   81|      0|                break;
   82|      0|        }
   83|      0|
   84|      0|        PHI_ASSERT_NOT_REACHED();
   85|      0|        return false;
   86|      0|    }
   87|       |
   88|       |    phi::Boolean operator!=(const InstructionArg& lhs, const InstructionArg& rhs)
   89|      0|    {
   90|      0|        return !(lhs == rhs);
   91|      0|    }
   92|       |
   93|       |    InstructionArg ConstructInstructionArgRegisterInt(IntRegisterID id)
   94|  15.5k|    {
   95|  15.5k|        InstructionArg arg;
   96|  15.5k|        arg.m_Type                   = ArgumentType::IntRegister;
   97|  15.5k|        arg.register_int.register_id = id;
   98|  15.5k|        return arg;
   99|  15.5k|    }
  100|       |
  101|       |    InstructionArg ConstructInstructionArgRegisterFloat(FloatRegisterID id)
  102|      0|    {
  103|      0|        InstructionArg arg;
  104|      0|        arg.m_Type                     = ArgumentType::FloatRegister;
  105|      0|        arg.register_float.register_id = id;
  106|      0|        return arg;
  107|      0|    }
  108|       |
  109|       |    InstructionArg ConstructInstructionArgImmediateValue(phi::i32 value)
  110|  3.43k|    {
  111|  3.43k|        InstructionArg arg;
  112|  3.43k|        arg.m_Type                       = ArgumentType::ImmediateInteger;
  113|  3.43k|        arg.immediate_value.signed_value = value;
  114|  3.43k|        return arg;
  115|  3.43k|    }
  116|       |
  117|       |    InstructionArg ConstructInstructionArgAddressDisplacement(IntRegisterID id,
  118|       |                                                              phi::i32      displacement)
  119|    661|    {
  120|    661|        InstructionArg arg;
  121|    661|        arg.m_Type                            = ArgumentType::AddressDisplacement;
  122|    661|        arg.address_displacement.register_id  = id;
  123|    661|        arg.address_displacement.displacement = displacement;
  124|    661|        return arg;
  125|    661|    }
  126|       |
  127|       |    InstructionArg ConstructInstructionArgLabel(std::string_view label_name)
  128|    161|    {
  129|    161|        InstructionArg arg;
  130|    161|        arg.m_Type           = ArgumentType::Label;
  131|    161|        arg.label.label_name = label_name;
  132|    161|        return arg;
  133|    161|    }
  134|       |} // namespace dlx

