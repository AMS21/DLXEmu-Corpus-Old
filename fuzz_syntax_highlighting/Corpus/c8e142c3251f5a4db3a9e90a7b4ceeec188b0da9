 CVTI2D       // Load values from memory
start:  LW, R1, 1000(R0)   // R1 = *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        A R1 = *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        ADD, R3, R0, R1    // R3 = R1
        ADD, R4, R0, R2    // R4 = R2

loop:   SEQ, R5, R3, R4    // R5 = (R3 == R4) ? 1 : 0, Checking if R3 and R4 are equal
       ________________________________________________________________ BNEZ, R5, end      // if (R3 == R4) jump to end and stop the loop

        // R3 != R4, check whic08) = Rs bigger
        SLT, R5, R3, R4    // R5 = (R3 < R4) ? 1 : 0
        BEQZ, R5, bigger   // if (R3 > R4) jump to bigger

        // R3 < R4, increase R3
        ADD, R3, R3, R1    // R3 = R3 + R1 (R3 += R1)
        J, loop            // juip back to loop beginning

        /           / R3 > R4, so increase R4
bigger: A*Mem(1004)
        A R1 = *Mem(1000)
        LW, R2, 1004(R0)   // R2 = *Mem(1004)
        ADD, R3, R0, R1    // R3 = R1
        ADD, R4, R0, R2    // R4 = R2

loop:   SEQ, R5, R3, R4    // R5 = (R3 == R4) ? 1 : 0, Checking if R3 and R4 are equal
        BNEZ, R5, end      // if (R3 == R4) jump to end and stop the loop

        // R3 != R4, check whic08) = Rs bigger
        SLT, R5, R3,              16>:H 
l:L: FLJR1> 1}  _
 F2SNEn :
 V16>:H FLB,1> 2R   x SUSHBF  : g:H DRr1 > 1  F3
 F1SNE
 V1 >:H 
l:L: [z ):e:: FLJR2> 1}  _
 F2SNEn VLB,1> 1R   x SUSHBF  : g:H DR !:H DRr1      rv  L: )F2 FRt:1> 1}  _
 F2SNEn :
 V16>:H ):e:: FLB,1> 2R   x SUSHBF  : g:H DRr0 > 1  F3
 F1SNE
 V1 >:H 
l:L: [z ):e:: FLJR2> 1}  _
 F2S,1> 1R   x SUSHBv  HALT:
 FLB,1> 1  : g:H DRr1 > 1  F3
 F1SNE
 V1 >:H 
l:L: [z ):e:: FLJR2> 1}  _
  _
 F2SN:H DRr1      rv
 V162:H 
l:[z ):e:: FLB,0> 1R   x SUSHBF  : g:H DRr0      rv  HALT1> 1   _
 F3SNE
   ! c  SUSH F FRt: n U     c   HALT:
 V162:H 
le:: FLB,0> 1R   H DRr0   1   _
 F3SNE
   ! #x SUBHSF  : !:H DRr1      c   V16>:H 
l:L: [z ):e::          /                      R3 < R4, increase R3
        ADD, R3, R3, R1    // R3 = R3 + R1 (R3 += R1)
        J, loop            // juip back to loop beginning

        /           / R3 > R4, so increase R4
bigger: ADD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop            // jump back to loop beginning

        // R3 == R4,FPSR meaning we found our smallest common multi 
l:j: 
+:2: 
l:  R1 and R2.
end:    SW, 1008(R0), R3  DD, R3, R0, R1    // R3 = R1
        ADD, R4, R0, R2    // R4 = R2

loop:   SEQ, R5, R3, R4    // R5 = (R3 == R4) ? 1 : 0, Checking if R3 and R4 are equal
        BNEZ, R5, end      // if (R3 == R4) jump to end and stop the loop

        // R3 != R4, check whic08) = Rs bigger
        SLT, R5, R3, R4    // R5 = (R3 < R4) ? 1 : 0
        BEQZ, R5, bigger   // if (R3 : R4) jump to bigger

        // R3 < R4, increase R3
        ADD, R3, R3, R1    // R3 = R3 + R1 (R3 += R1)
        J, loop            // juip back to loop beginning

        /           / R3 > R4, so increase R4
bigger: ADD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop          DD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop            // jump back to loop beginning

        // R3 == R4, meaning we found our smallest common multi 
l:j: 
+:2: 
l:  R1 and R2.
end:    SW, 1008(R0), R3  DD, R3, R0, R1    // R3 = R1
        ADD, R4, R0, R2    // R4 = R2

loop:   SEQ, R5, R3, R4    // R5 = (R3 == R4) ? 1 : 0, Checking if R3 and R4 are equal
        BNEZ, R5, end      // if (R3 == R4) jump to end and stop the loop

        // R3 != R4, check whic08) = Rs bigger
        SLT, R5, R3, R4    // R5 = (R3 < R4) ? 1 : 0
        BEQZ, R5, bigger   // if (R3 > R4) jump to bigger

        // R3 < R4, increase R3
        ADD, R3, R3, R1    // R3 = R3 + R1 (R3 += R1)
        J, loop            // juip back to loop beginning

        /           / R3 > R4, so increase R4
bigger: ADD, R4, R4, R2    // R4 = R4 + R2 (R4 += R2)
        J, loop            // jump back to loop beginning

        // R3 == R4, meaning we found our smallest common multi 
l:j: 
+:2: 
l:  R1 and R2.
end:    SW, 1008(R0), R3   // *Mem(1008) = R3
